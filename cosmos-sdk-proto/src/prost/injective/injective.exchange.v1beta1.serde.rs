// @generated
#[cfg(feature = "serde")]
impl serde::Serialize for AccountRewards {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        if !self.rewards.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.AccountRewards", len)?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        if !self.rewards.is_empty() {
            struct_ser.serialize_field("rewards", &self.rewards)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for AccountRewards {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account", "rewards"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
            Rewards,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            "rewards" => Ok(GeneratedField::Rewards),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AccountRewards;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.AccountRewards")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AccountRewards, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                let mut rewards__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Rewards => {
                            if rewards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rewards"));
                            }
                            rewards__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AccountRewards {
                    account: account__.unwrap_or_default(),
                    rewards: rewards__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.AccountRewards",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for AccountVolume {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        if !self.volume.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.AccountVolume", len)?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        if !self.volume.is_empty() {
            struct_ser.serialize_field("volume", &self.volume)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for AccountVolume {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account", "volume"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
            Volume,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            "volume" => Ok(GeneratedField::Volume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AccountVolume;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.AccountVolume")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AccountVolume, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                let mut volume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AccountVolume {
                    account: account__.unwrap_or_default(),
                    volume: volume__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.AccountVolume",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ActiveGrant {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.granter.is_empty() {
            len += 1;
        }
        if !self.amount.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.ActiveGrant", len)?;
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        if !self.amount.is_empty() {
            struct_ser.serialize_field("amount", &self.amount)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ActiveGrant {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["granter", "amount"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Granter,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "granter" => Ok(GeneratedField::Granter),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ActiveGrant;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.ActiveGrant")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ActiveGrant, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut granter__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ActiveGrant {
                    granter: granter__.unwrap_or_default(),
                    amount: amount__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.ActiveGrant",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for AdminInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.admin.is_empty() {
            len += 1;
        }
        if self.admin_permissions != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.AdminInfo", len)?;
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if self.admin_permissions != 0 {
            struct_ser.serialize_field("adminPermissions", &self.admin_permissions)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for AdminInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["admin", "admin_permissions", "adminPermissions"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Admin,
            AdminPermissions,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "admin" => Ok(GeneratedField::Admin),
                            "adminPermissions" | "admin_permissions" => {
                                Ok(GeneratedField::AdminPermissions)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AdminInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.AdminInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AdminInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut admin__ = None;
                let mut admin_permissions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminPermissions => {
                            if admin_permissions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminPermissions"));
                            }
                            admin_permissions__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(AdminInfo {
                    admin: admin__.unwrap_or_default(),
                    admin_permissions: admin_permissions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.AdminInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for AggregateAccountVolumeRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        if !self.market_volumes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.AggregateAccountVolumeRecord",
            len,
        )?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        if !self.market_volumes.is_empty() {
            struct_ser.serialize_field("marketVolumes", &self.market_volumes)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for AggregateAccountVolumeRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account", "market_volumes", "marketVolumes"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
            MarketVolumes,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            "marketVolumes" | "market_volumes" => Ok(GeneratedField::MarketVolumes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AggregateAccountVolumeRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.AggregateAccountVolumeRecord")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<AggregateAccountVolumeRecord, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                let mut market_volumes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketVolumes => {
                            if market_volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketVolumes"));
                            }
                            market_volumes__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AggregateAccountVolumeRecord {
                    account: account__.unwrap_or_default(),
                    market_volumes: market_volumes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.AggregateAccountVolumeRecord",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for AggregateSubaccountVolumeRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_volumes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.AggregateSubaccountVolumeRecord",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_volumes.is_empty() {
            struct_ser.serialize_field("marketVolumes", &self.market_volumes)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for AggregateSubaccountVolumeRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccount_id",
            "subaccountId",
            "market_volumes",
            "marketVolumes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketVolumes,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketVolumes" | "market_volumes" => Ok(GeneratedField::MarketVolumes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AggregateSubaccountVolumeRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.AggregateSubaccountVolumeRecord")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<AggregateSubaccountVolumeRecord, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_volumes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketVolumes => {
                            if market_volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketVolumes"));
                            }
                            market_volumes__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AggregateSubaccountVolumeRecord {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_volumes: market_volumes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.AggregateSubaccountVolumeRecord",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for AtomicMarketOrderAccessLevel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Nobody => "Nobody",
            Self::BeginBlockerSmartContractsOnly => "BeginBlockerSmartContractsOnly",
            Self::SmartContractsOnly => "SmartContractsOnly",
            Self::Everyone => "Everyone",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for AtomicMarketOrderAccessLevel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Nobody",
            "BeginBlockerSmartContractsOnly",
            "SmartContractsOnly",
            "Everyone",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AtomicMarketOrderAccessLevel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Nobody" => Ok(AtomicMarketOrderAccessLevel::Nobody),
                    "BeginBlockerSmartContractsOnly" => {
                        Ok(AtomicMarketOrderAccessLevel::BeginBlockerSmartContractsOnly)
                    }
                    "SmartContractsOnly" => Ok(AtomicMarketOrderAccessLevel::SmartContractsOnly),
                    "Everyone" => Ok(AtomicMarketOrderAccessLevel::Everyone),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for AtomicMarketOrderFeeMultiplierScheduleProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.market_fee_multipliers.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.market_fee_multipliers.is_empty() {
            struct_ser.serialize_field("marketFeeMultipliers", &self.market_fee_multipliers)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for AtomicMarketOrderFeeMultiplierScheduleProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "market_fee_multipliers",
            "marketFeeMultipliers",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            MarketFeeMultipliers,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "marketFeeMultipliers" | "market_fee_multipliers" => {
                                Ok(GeneratedField::MarketFeeMultipliers)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AtomicMarketOrderFeeMultiplierScheduleProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<AtomicMarketOrderFeeMultiplierScheduleProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut market_fee_multipliers__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketFeeMultipliers => {
                            if market_fee_multipliers__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "marketFeeMultipliers",
                                ));
                            }
                            market_fee_multipliers__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AtomicMarketOrderFeeMultiplierScheduleProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    market_fee_multipliers: market_fee_multipliers__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Balance {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.denom.is_empty() {
            len += 1;
        }
        if self.deposits.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.Balance", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            struct_ser.serialize_field("denom", &self.denom)?;
        }
        if let Some(v) = self.deposits.as_ref() {
            struct_ser.serialize_field("deposits", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for Balance {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "denom", "deposits"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            Denom,
            Deposits,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "denom" => Ok(GeneratedField::Denom),
                            "deposits" => Ok(GeneratedField::Deposits),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Balance;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.Balance")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Balance, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut denom__ = None;
                let mut deposits__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Denom => {
                            if denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denom"));
                            }
                            denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Deposits => {
                            if deposits__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deposits"));
                            }
                            deposits__ = map_.next_value()?;
                        }
                    }
                }
                Ok(Balance {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    denom: denom__.unwrap_or_default(),
                    deposits: deposits__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.Balance",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BalanceMismatch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.denom.is_empty() {
            len += 1;
        }
        if !self.available.is_empty() {
            len += 1;
        }
        if !self.total.is_empty() {
            len += 1;
        }
        if !self.balance_hold.is_empty() {
            len += 1;
        }
        if !self.expected_total.is_empty() {
            len += 1;
        }
        if !self.difference.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.BalanceMismatch", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            struct_ser.serialize_field("denom", &self.denom)?;
        }
        if !self.available.is_empty() {
            struct_ser.serialize_field("available", &self.available)?;
        }
        if !self.total.is_empty() {
            struct_ser.serialize_field("total", &self.total)?;
        }
        if !self.balance_hold.is_empty() {
            struct_ser.serialize_field("balanceHold", &self.balance_hold)?;
        }
        if !self.expected_total.is_empty() {
            struct_ser.serialize_field("expectedTotal", &self.expected_total)?;
        }
        if !self.difference.is_empty() {
            struct_ser.serialize_field("difference", &self.difference)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BalanceMismatch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccountId",
            "denom",
            "available",
            "total",
            "balance_hold",
            "balanceHold",
            "expected_total",
            "expectedTotal",
            "difference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            Denom,
            Available,
            Total,
            BalanceHold,
            ExpectedTotal,
            Difference,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" => Ok(GeneratedField::SubaccountId),
                            "denom" => Ok(GeneratedField::Denom),
                            "available" => Ok(GeneratedField::Available),
                            "total" => Ok(GeneratedField::Total),
                            "balanceHold" | "balance_hold" => Ok(GeneratedField::BalanceHold),
                            "expectedTotal" | "expected_total" => Ok(GeneratedField::ExpectedTotal),
                            "difference" => Ok(GeneratedField::Difference),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BalanceMismatch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.BalanceMismatch")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BalanceMismatch, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut denom__ = None;
                let mut available__ = None;
                let mut total__ = None;
                let mut balance_hold__ = None;
                let mut expected_total__ = None;
                let mut difference__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Denom => {
                            if denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denom"));
                            }
                            denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Available => {
                            if available__.is_some() {
                                return Err(serde::de::Error::duplicate_field("available"));
                            }
                            available__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Total => {
                            if total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("total"));
                            }
                            total__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BalanceHold => {
                            if balance_hold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceHold"));
                            }
                            balance_hold__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpectedTotal => {
                            if expected_total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedTotal"));
                            }
                            expected_total__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Difference => {
                            if difference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("difference"));
                            }
                            difference__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BalanceMismatch {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    denom: denom__.unwrap_or_default(),
                    available: available__.unwrap_or_default(),
                    total: total__.unwrap_or_default(),
                    balance_hold: balance_hold__.unwrap_or_default(),
                    expected_total: expected_total__.unwrap_or_default(),
                    difference: difference__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BalanceMismatch",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BalanceWithMarginHold {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.denom.is_empty() {
            len += 1;
        }
        if !self.available.is_empty() {
            len += 1;
        }
        if !self.total.is_empty() {
            len += 1;
        }
        if !self.balance_hold.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.BalanceWithMarginHold", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            struct_ser.serialize_field("denom", &self.denom)?;
        }
        if !self.available.is_empty() {
            struct_ser.serialize_field("available", &self.available)?;
        }
        if !self.total.is_empty() {
            struct_ser.serialize_field("total", &self.total)?;
        }
        if !self.balance_hold.is_empty() {
            struct_ser.serialize_field("balanceHold", &self.balance_hold)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BalanceWithMarginHold {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccountId",
            "denom",
            "available",
            "total",
            "balance_hold",
            "balanceHold",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            Denom,
            Available,
            Total,
            BalanceHold,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" => Ok(GeneratedField::SubaccountId),
                            "denom" => Ok(GeneratedField::Denom),
                            "available" => Ok(GeneratedField::Available),
                            "total" => Ok(GeneratedField::Total),
                            "balanceHold" | "balance_hold" => Ok(GeneratedField::BalanceHold),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BalanceWithMarginHold;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.BalanceWithMarginHold")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BalanceWithMarginHold, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut denom__ = None;
                let mut available__ = None;
                let mut total__ = None;
                let mut balance_hold__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Denom => {
                            if denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denom"));
                            }
                            denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Available => {
                            if available__.is_some() {
                                return Err(serde::de::Error::duplicate_field("available"));
                            }
                            available__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Total => {
                            if total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("total"));
                            }
                            total__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BalanceHold => {
                            if balance_hold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceHold"));
                            }
                            balance_hold__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BalanceWithMarginHold {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    denom: denom__.unwrap_or_default(),
                    available: available__.unwrap_or_default(),
                    total: total__.unwrap_or_default(),
                    balance_hold: balance_hold__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BalanceWithMarginHold",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BatchCancelDerivativeOrdersAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.BatchCancelDerivativeOrdersAuthz",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BatchCancelDerivativeOrdersAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchCancelDerivativeOrdersAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.BatchCancelDerivativeOrdersAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BatchCancelDerivativeOrdersAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BatchCancelDerivativeOrdersAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BatchCancelDerivativeOrdersAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BatchCancelSpotOrdersAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.BatchCancelSpotOrdersAuthz", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BatchCancelSpotOrdersAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchCancelSpotOrdersAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.BatchCancelSpotOrdersAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BatchCancelSpotOrdersAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BatchCancelSpotOrdersAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BatchCancelSpotOrdersAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BatchCommunityPoolSpendProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.proposals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.BatchCommunityPoolSpendProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.proposals.is_empty() {
            struct_ser.serialize_field("proposals", &self.proposals)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BatchCommunityPoolSpendProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["title", "description", "proposals"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            Proposals,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "proposals" => Ok(GeneratedField::Proposals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchCommunityPoolSpendProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.BatchCommunityPoolSpendProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BatchCommunityPoolSpendProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut proposals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Proposals => {
                            if proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("proposals"));
                            }
                            proposals__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BatchCommunityPoolSpendProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    proposals: proposals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BatchCommunityPoolSpendProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BatchCreateDerivativeLimitOrdersAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.BatchCreateDerivativeLimitOrdersAuthz",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BatchCreateDerivativeLimitOrdersAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchCreateDerivativeLimitOrdersAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.BatchCreateDerivativeLimitOrdersAuthz",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BatchCreateDerivativeLimitOrdersAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BatchCreateDerivativeLimitOrdersAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BatchCreateDerivativeLimitOrdersAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BatchCreateSpotLimitOrdersAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.BatchCreateSpotLimitOrdersAuthz",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BatchCreateSpotLimitOrdersAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchCreateSpotLimitOrdersAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.BatchCreateSpotLimitOrdersAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BatchCreateSpotLimitOrdersAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BatchCreateSpotLimitOrdersAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BatchCreateSpotLimitOrdersAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BatchExchangeModificationProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.spot_market_param_update_proposals.is_empty() {
            len += 1;
        }
        if !self.derivative_market_param_update_proposals.is_empty() {
            len += 1;
        }
        if !self.spot_market_launch_proposals.is_empty() {
            len += 1;
        }
        if !self.perpetual_market_launch_proposals.is_empty() {
            len += 1;
        }
        if !self.expiry_futures_market_launch_proposals.is_empty() {
            len += 1;
        }
        if self.trading_reward_campaign_update_proposal.is_some() {
            len += 1;
        }
        if !self.binary_options_market_launch_proposals.is_empty() {
            len += 1;
        }
        if !self.binary_options_param_update_proposals.is_empty() {
            len += 1;
        }
        if self.denom_decimals_update_proposal.is_some() {
            len += 1;
        }
        if self.fee_discount_proposal.is_some() {
            len += 1;
        }
        if !self.market_forced_settlement_proposals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.BatchExchangeModificationProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.spot_market_param_update_proposals.is_empty() {
            struct_ser.serialize_field(
                "spotMarketParamUpdateProposals",
                &self.spot_market_param_update_proposals,
            )?;
        }
        if !self.derivative_market_param_update_proposals.is_empty() {
            struct_ser.serialize_field(
                "derivativeMarketParamUpdateProposals",
                &self.derivative_market_param_update_proposals,
            )?;
        }
        if !self.spot_market_launch_proposals.is_empty() {
            struct_ser.serialize_field(
                "spotMarketLaunchProposals",
                &self.spot_market_launch_proposals,
            )?;
        }
        if !self.perpetual_market_launch_proposals.is_empty() {
            struct_ser.serialize_field(
                "perpetualMarketLaunchProposals",
                &self.perpetual_market_launch_proposals,
            )?;
        }
        if !self.expiry_futures_market_launch_proposals.is_empty() {
            struct_ser.serialize_field(
                "expiryFuturesMarketLaunchProposals",
                &self.expiry_futures_market_launch_proposals,
            )?;
        }
        if let Some(v) = self.trading_reward_campaign_update_proposal.as_ref() {
            struct_ser.serialize_field("tradingRewardCampaignUpdateProposal", v)?;
        }
        if !self.binary_options_market_launch_proposals.is_empty() {
            struct_ser.serialize_field(
                "binaryOptionsMarketLaunchProposals",
                &self.binary_options_market_launch_proposals,
            )?;
        }
        if !self.binary_options_param_update_proposals.is_empty() {
            struct_ser.serialize_field(
                "binaryOptionsParamUpdateProposals",
                &self.binary_options_param_update_proposals,
            )?;
        }
        if let Some(v) = self.denom_decimals_update_proposal.as_ref() {
            struct_ser.serialize_field("denomDecimalsUpdateProposal", v)?;
        }
        if let Some(v) = self.fee_discount_proposal.as_ref() {
            struct_ser.serialize_field("feeDiscountProposal", v)?;
        }
        if !self.market_forced_settlement_proposals.is_empty() {
            struct_ser.serialize_field(
                "marketForcedSettlementProposals",
                &self.market_forced_settlement_proposals,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BatchExchangeModificationProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "spot_market_param_update_proposals",
            "spotMarketParamUpdateProposals",
            "derivative_market_param_update_proposals",
            "derivativeMarketParamUpdateProposals",
            "spot_market_launch_proposals",
            "spotMarketLaunchProposals",
            "perpetual_market_launch_proposals",
            "perpetualMarketLaunchProposals",
            "expiry_futures_market_launch_proposals",
            "expiryFuturesMarketLaunchProposals",
            "trading_reward_campaign_update_proposal",
            "tradingRewardCampaignUpdateProposal",
            "binary_options_market_launch_proposals",
            "binaryOptionsMarketLaunchProposals",
            "binary_options_param_update_proposals",
            "binaryOptionsParamUpdateProposals",
            "denom_decimals_update_proposal",
            "denomDecimalsUpdateProposal",
            "fee_discount_proposal",
            "feeDiscountProposal",
            "market_forced_settlement_proposals",
            "marketForcedSettlementProposals",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            SpotMarketParamUpdateProposals,
            DerivativeMarketParamUpdateProposals,
            SpotMarketLaunchProposals,
            PerpetualMarketLaunchProposals,
            ExpiryFuturesMarketLaunchProposals,
            TradingRewardCampaignUpdateProposal,
            BinaryOptionsMarketLaunchProposals,
            BinaryOptionsParamUpdateProposals,
            DenomDecimalsUpdateProposal,
            FeeDiscountProposal,
            MarketForcedSettlementProposals,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "spotMarketParamUpdateProposals"
                            | "spot_market_param_update_proposals" => {
                                Ok(GeneratedField::SpotMarketParamUpdateProposals)
                            }
                            "derivativeMarketParamUpdateProposals"
                            | "derivative_market_param_update_proposals" => {
                                Ok(GeneratedField::DerivativeMarketParamUpdateProposals)
                            }
                            "spotMarketLaunchProposals" | "spot_market_launch_proposals" => {
                                Ok(GeneratedField::SpotMarketLaunchProposals)
                            }
                            "perpetualMarketLaunchProposals"
                            | "perpetual_market_launch_proposals" => {
                                Ok(GeneratedField::PerpetualMarketLaunchProposals)
                            }
                            "expiryFuturesMarketLaunchProposals"
                            | "expiry_futures_market_launch_proposals" => {
                                Ok(GeneratedField::ExpiryFuturesMarketLaunchProposals)
                            }
                            "tradingRewardCampaignUpdateProposal"
                            | "trading_reward_campaign_update_proposal" => {
                                Ok(GeneratedField::TradingRewardCampaignUpdateProposal)
                            }
                            "binaryOptionsMarketLaunchProposals"
                            | "binary_options_market_launch_proposals" => {
                                Ok(GeneratedField::BinaryOptionsMarketLaunchProposals)
                            }
                            "binaryOptionsParamUpdateProposals"
                            | "binary_options_param_update_proposals" => {
                                Ok(GeneratedField::BinaryOptionsParamUpdateProposals)
                            }
                            "denomDecimalsUpdateProposal" | "denom_decimals_update_proposal" => {
                                Ok(GeneratedField::DenomDecimalsUpdateProposal)
                            }
                            "feeDiscountProposal" | "fee_discount_proposal" => {
                                Ok(GeneratedField::FeeDiscountProposal)
                            }
                            "marketForcedSettlementProposals"
                            | "market_forced_settlement_proposals" => {
                                Ok(GeneratedField::MarketForcedSettlementProposals)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchExchangeModificationProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.BatchExchangeModificationProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BatchExchangeModificationProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut spot_market_param_update_proposals__ = None;
                let mut derivative_market_param_update_proposals__ = None;
                let mut spot_market_launch_proposals__ = None;
                let mut perpetual_market_launch_proposals__ = None;
                let mut expiry_futures_market_launch_proposals__ = None;
                let mut trading_reward_campaign_update_proposal__ = None;
                let mut binary_options_market_launch_proposals__ = None;
                let mut binary_options_param_update_proposals__ = None;
                let mut denom_decimals_update_proposal__ = None;
                let mut fee_discount_proposal__ = None;
                let mut market_forced_settlement_proposals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotMarketParamUpdateProposals => {
                            if spot_market_param_update_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotMarketParamUpdateProposals",
                                ));
                            }
                            spot_market_param_update_proposals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeMarketParamUpdateProposals => {
                            if derivative_market_param_update_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeMarketParamUpdateProposals",
                                ));
                            }
                            derivative_market_param_update_proposals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotMarketLaunchProposals => {
                            if spot_market_launch_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotMarketLaunchProposals",
                                ));
                            }
                            spot_market_launch_proposals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PerpetualMarketLaunchProposals => {
                            if perpetual_market_launch_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "perpetualMarketLaunchProposals",
                                ));
                            }
                            perpetual_market_launch_proposals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpiryFuturesMarketLaunchProposals => {
                            if expiry_futures_market_launch_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expiryFuturesMarketLaunchProposals",
                                ));
                            }
                            expiry_futures_market_launch_proposals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradingRewardCampaignUpdateProposal => {
                            if trading_reward_campaign_update_proposal__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardCampaignUpdateProposal",
                                ));
                            }
                            trading_reward_campaign_update_proposal__ = map_.next_value()?;
                        }
                        GeneratedField::BinaryOptionsMarketLaunchProposals => {
                            if binary_options_market_launch_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsMarketLaunchProposals",
                                ));
                            }
                            binary_options_market_launch_proposals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsParamUpdateProposals => {
                            if binary_options_param_update_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsParamUpdateProposals",
                                ));
                            }
                            binary_options_param_update_proposals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DenomDecimalsUpdateProposal => {
                            if denom_decimals_update_proposal__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "denomDecimalsUpdateProposal",
                                ));
                            }
                            denom_decimals_update_proposal__ = map_.next_value()?;
                        }
                        GeneratedField::FeeDiscountProposal => {
                            if fee_discount_proposal__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "feeDiscountProposal",
                                ));
                            }
                            fee_discount_proposal__ = map_.next_value()?;
                        }
                        GeneratedField::MarketForcedSettlementProposals => {
                            if market_forced_settlement_proposals__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "marketForcedSettlementProposals",
                                ));
                            }
                            market_forced_settlement_proposals__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BatchExchangeModificationProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    spot_market_param_update_proposals: spot_market_param_update_proposals__
                        .unwrap_or_default(),
                    derivative_market_param_update_proposals:
                        derivative_market_param_update_proposals__.unwrap_or_default(),
                    spot_market_launch_proposals: spot_market_launch_proposals__
                        .unwrap_or_default(),
                    perpetual_market_launch_proposals: perpetual_market_launch_proposals__
                        .unwrap_or_default(),
                    expiry_futures_market_launch_proposals:
                        expiry_futures_market_launch_proposals__.unwrap_or_default(),
                    trading_reward_campaign_update_proposal:
                        trading_reward_campaign_update_proposal__,
                    binary_options_market_launch_proposals:
                        binary_options_market_launch_proposals__.unwrap_or_default(),
                    binary_options_param_update_proposals: binary_options_param_update_proposals__
                        .unwrap_or_default(),
                    denom_decimals_update_proposal: denom_decimals_update_proposal__,
                    fee_discount_proposal: fee_discount_proposal__,
                    market_forced_settlement_proposals: market_forced_settlement_proposals__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BatchExchangeModificationProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BatchUpdateOrdersAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.spot_markets.is_empty() {
            len += 1;
        }
        if !self.derivative_markets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.BatchUpdateOrdersAuthz", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.spot_markets.is_empty() {
            struct_ser.serialize_field("spotMarkets", &self.spot_markets)?;
        }
        if !self.derivative_markets.is_empty() {
            struct_ser.serialize_field("derivativeMarkets", &self.derivative_markets)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BatchUpdateOrdersAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccount_id",
            "subaccountId",
            "spot_markets",
            "spotMarkets",
            "derivative_markets",
            "derivativeMarkets",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            SpotMarkets,
            DerivativeMarkets,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "spotMarkets" | "spot_markets" => Ok(GeneratedField::SpotMarkets),
                            "derivativeMarkets" | "derivative_markets" => {
                                Ok(GeneratedField::DerivativeMarkets)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchUpdateOrdersAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.BatchUpdateOrdersAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BatchUpdateOrdersAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut spot_markets__ = None;
                let mut derivative_markets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotMarkets => {
                            if spot_markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spotMarkets"));
                            }
                            spot_markets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeMarkets => {
                            if derivative_markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("derivativeMarkets"));
                            }
                            derivative_markets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BatchUpdateOrdersAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    spot_markets: spot_markets__.unwrap_or_default(),
                    derivative_markets: derivative_markets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BatchUpdateOrdersAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BinaryOptionsMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.oracle_symbol.is_empty() {
            len += 1;
        }
        if !self.oracle_provider.is_empty() {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.expiration_timestamp != 0 {
            len += 1;
        }
        if self.settlement_timestamp != 0 {
            len += 1;
        }
        if !self.admin.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            len += 1;
        }
        if self.status != 0 {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.settlement_price.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if self.admin_permissions != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.BinaryOptionsMarket", len)?;
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.oracle_symbol.is_empty() {
            struct_ser.serialize_field("oracleSymbol", &self.oracle_symbol)?;
        }
        if !self.oracle_provider.is_empty() {
            struct_ser.serialize_field("oracleProvider", &self.oracle_provider)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.expiration_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "expirationTimestamp",
                ToString::to_string(&self.expiration_timestamp).as_str(),
            )?;
        }
        if self.settlement_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "settlementTimestamp",
                ToString::to_string(&self.settlement_timestamp).as_str(),
            )?;
        }
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            struct_ser.serialize_field("relayerFeeShareRate", &self.relayer_fee_share_rate)?;
        }
        if self.status != 0 {
            let v = MarketStatus::try_from(self.status).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.status))
            })?;
            struct_ser.serialize_field("status", &v)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.settlement_price.is_empty() {
            struct_ser.serialize_field("settlementPrice", &self.settlement_price)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if self.admin_permissions != 0 {
            struct_ser.serialize_field("adminPermissions", &self.admin_permissions)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BinaryOptionsMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ticker",
            "oracle_symbol",
            "oracleSymbol",
            "oracle_provider",
            "oracleProvider",
            "oracle_type",
            "oracleType",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "expiration_timestamp",
            "expirationTimestamp",
            "settlement_timestamp",
            "settlementTimestamp",
            "admin",
            "quote_denom",
            "quoteDenom",
            "market_id",
            "marketId",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "relayer_fee_share_rate",
            "relayerFeeShareRate",
            "status",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "settlement_price",
            "settlementPrice",
            "min_notional",
            "minNotional",
            "admin_permissions",
            "adminPermissions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ticker,
            OracleSymbol,
            OracleProvider,
            OracleType,
            OracleScaleFactor,
            ExpirationTimestamp,
            SettlementTimestamp,
            Admin,
            QuoteDenom,
            MarketId,
            MakerFeeRate,
            TakerFeeRate,
            RelayerFeeShareRate,
            Status,
            MinPriceTickSize,
            MinQuantityTickSize,
            SettlementPrice,
            MinNotional,
            AdminPermissions,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ticker" => Ok(GeneratedField::Ticker),
                            "oracleSymbol" | "oracle_symbol" => Ok(GeneratedField::OracleSymbol),
                            "oracleProvider" | "oracle_provider" => {
                                Ok(GeneratedField::OracleProvider)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "expirationTimestamp" | "expiration_timestamp" => {
                                Ok(GeneratedField::ExpirationTimestamp)
                            }
                            "settlementTimestamp" | "settlement_timestamp" => {
                                Ok(GeneratedField::SettlementTimestamp)
                            }
                            "admin" => Ok(GeneratedField::Admin),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "relayerFeeShareRate" | "relayer_fee_share_rate" => {
                                Ok(GeneratedField::RelayerFeeShareRate)
                            }
                            "status" => Ok(GeneratedField::Status),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "settlementPrice" | "settlement_price" => {
                                Ok(GeneratedField::SettlementPrice)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "adminPermissions" | "admin_permissions" => {
                                Ok(GeneratedField::AdminPermissions)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BinaryOptionsMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.BinaryOptionsMarket")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BinaryOptionsMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut ticker__ = None;
                let mut oracle_symbol__ = None;
                let mut oracle_provider__ = None;
                let mut oracle_type__ = None;
                let mut oracle_scale_factor__ = None;
                let mut expiration_timestamp__ = None;
                let mut settlement_timestamp__ = None;
                let mut admin__ = None;
                let mut quote_denom__ = None;
                let mut market_id__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut relayer_fee_share_rate__ = None;
                let mut status__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut settlement_price__ = None;
                let mut min_notional__ = None;
                let mut admin_permissions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleSymbol => {
                            if oracle_symbol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleSymbol"));
                            }
                            oracle_symbol__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleProvider => {
                            if oracle_provider__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleProvider"));
                            }
                            oracle_provider__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::ExpirationTimestamp => {
                            if expiration_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expirationTimestamp",
                                ));
                            }
                            expiration_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::SettlementTimestamp => {
                            if settlement_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "settlementTimestamp",
                                ));
                            }
                            settlement_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RelayerFeeShareRate => {
                            if relayer_fee_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "relayerFeeShareRate",
                                ));
                            }
                            relayer_fee_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<MarketStatus>()? as i32);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlementPrice => {
                            if settlement_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlementPrice"));
                            }
                            settlement_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminPermissions => {
                            if admin_permissions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminPermissions"));
                            }
                            admin_permissions__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(BinaryOptionsMarket {
                    ticker: ticker__.unwrap_or_default(),
                    oracle_symbol: oracle_symbol__.unwrap_or_default(),
                    oracle_provider: oracle_provider__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    expiration_timestamp: expiration_timestamp__.unwrap_or_default(),
                    settlement_timestamp: settlement_timestamp__.unwrap_or_default(),
                    admin: admin__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    relayer_fee_share_rate: relayer_fee_share_rate__.unwrap_or_default(),
                    status: status__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    settlement_price: settlement_price__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin_permissions: admin_permissions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BinaryOptionsMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BinaryOptionsMarketLaunchProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.oracle_symbol.is_empty() {
            len += 1;
        }
        if !self.oracle_provider.is_empty() {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.expiration_timestamp != 0 {
            len += 1;
        }
        if self.settlement_timestamp != 0 {
            len += 1;
        }
        if !self.admin.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if self.admin_permissions != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.oracle_symbol.is_empty() {
            struct_ser.serialize_field("oracleSymbol", &self.oracle_symbol)?;
        }
        if !self.oracle_provider.is_empty() {
            struct_ser.serialize_field("oracleProvider", &self.oracle_provider)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.expiration_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "expirationTimestamp",
                ToString::to_string(&self.expiration_timestamp).as_str(),
            )?;
        }
        if self.settlement_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "settlementTimestamp",
                ToString::to_string(&self.settlement_timestamp).as_str(),
            )?;
        }
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if self.admin_permissions != 0 {
            struct_ser.serialize_field("adminPermissions", &self.admin_permissions)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BinaryOptionsMarketLaunchProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "ticker",
            "oracle_symbol",
            "oracleSymbol",
            "oracle_provider",
            "oracleProvider",
            "oracle_type",
            "oracleType",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "expiration_timestamp",
            "expirationTimestamp",
            "settlement_timestamp",
            "settlementTimestamp",
            "admin",
            "quote_denom",
            "quoteDenom",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
            "admin_permissions",
            "adminPermissions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            Ticker,
            OracleSymbol,
            OracleProvider,
            OracleType,
            OracleScaleFactor,
            ExpirationTimestamp,
            SettlementTimestamp,
            Admin,
            QuoteDenom,
            MakerFeeRate,
            TakerFeeRate,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
            AdminPermissions,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "oracleSymbol" | "oracle_symbol" => Ok(GeneratedField::OracleSymbol),
                            "oracleProvider" | "oracle_provider" => {
                                Ok(GeneratedField::OracleProvider)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "expirationTimestamp" | "expiration_timestamp" => {
                                Ok(GeneratedField::ExpirationTimestamp)
                            }
                            "settlementTimestamp" | "settlement_timestamp" => {
                                Ok(GeneratedField::SettlementTimestamp)
                            }
                            "admin" => Ok(GeneratedField::Admin),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "adminPermissions" | "admin_permissions" => {
                                Ok(GeneratedField::AdminPermissions)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BinaryOptionsMarketLaunchProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BinaryOptionsMarketLaunchProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut ticker__ = None;
                let mut oracle_symbol__ = None;
                let mut oracle_provider__ = None;
                let mut oracle_type__ = None;
                let mut oracle_scale_factor__ = None;
                let mut expiration_timestamp__ = None;
                let mut settlement_timestamp__ = None;
                let mut admin__ = None;
                let mut quote_denom__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                let mut admin_permissions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleSymbol => {
                            if oracle_symbol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleSymbol"));
                            }
                            oracle_symbol__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleProvider => {
                            if oracle_provider__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleProvider"));
                            }
                            oracle_provider__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::ExpirationTimestamp => {
                            if expiration_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expirationTimestamp",
                                ));
                            }
                            expiration_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::SettlementTimestamp => {
                            if settlement_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "settlementTimestamp",
                                ));
                            }
                            settlement_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminPermissions => {
                            if admin_permissions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminPermissions"));
                            }
                            admin_permissions__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(BinaryOptionsMarketLaunchProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    oracle_symbol: oracle_symbol__.unwrap_or_default(),
                    oracle_provider: oracle_provider__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    expiration_timestamp: expiration_timestamp__.unwrap_or_default(),
                    settlement_timestamp: settlement_timestamp__.unwrap_or_default(),
                    admin: admin__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin_permissions: admin_permissions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BinaryOptionsMarketParamUpdateProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if self.expiration_timestamp != 0 {
            len += 1;
        }
        if self.settlement_timestamp != 0 {
            len += 1;
        }
        if !self.settlement_price.is_empty() {
            len += 1;
        }
        if !self.admin.is_empty() {
            len += 1;
        }
        if self.status != 0 {
            len += 1;
        }
        if self.oracle_params.is_some() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            struct_ser.serialize_field("relayerFeeShareRate", &self.relayer_fee_share_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if self.expiration_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "expirationTimestamp",
                ToString::to_string(&self.expiration_timestamp).as_str(),
            )?;
        }
        if self.settlement_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "settlementTimestamp",
                ToString::to_string(&self.settlement_timestamp).as_str(),
            )?;
        }
        if !self.settlement_price.is_empty() {
            struct_ser.serialize_field("settlementPrice", &self.settlement_price)?;
        }
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if self.status != 0 {
            let v = MarketStatus::try_from(self.status).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.status))
            })?;
            struct_ser.serialize_field("status", &v)?;
        }
        if let Some(v) = self.oracle_params.as_ref() {
            struct_ser.serialize_field("oracleParams", v)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for BinaryOptionsMarketParamUpdateProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "market_id",
            "marketId",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "relayer_fee_share_rate",
            "relayerFeeShareRate",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "expiration_timestamp",
            "expirationTimestamp",
            "settlement_timestamp",
            "settlementTimestamp",
            "settlement_price",
            "settlementPrice",
            "admin",
            "status",
            "oracle_params",
            "oracleParams",
            "ticker",
            "min_notional",
            "minNotional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            MarketId,
            MakerFeeRate,
            TakerFeeRate,
            RelayerFeeShareRate,
            MinPriceTickSize,
            MinQuantityTickSize,
            ExpirationTimestamp,
            SettlementTimestamp,
            SettlementPrice,
            Admin,
            Status,
            OracleParams,
            Ticker,
            MinNotional,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "relayerFeeShareRate" | "relayer_fee_share_rate" => {
                                Ok(GeneratedField::RelayerFeeShareRate)
                            }
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "expirationTimestamp" | "expiration_timestamp" => {
                                Ok(GeneratedField::ExpirationTimestamp)
                            }
                            "settlementTimestamp" | "settlement_timestamp" => {
                                Ok(GeneratedField::SettlementTimestamp)
                            }
                            "settlementPrice" | "settlement_price" => {
                                Ok(GeneratedField::SettlementPrice)
                            }
                            "admin" => Ok(GeneratedField::Admin),
                            "status" => Ok(GeneratedField::Status),
                            "oracleParams" | "oracle_params" => Ok(GeneratedField::OracleParams),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BinaryOptionsMarketParamUpdateProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<BinaryOptionsMarketParamUpdateProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut market_id__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut relayer_fee_share_rate__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut expiration_timestamp__ = None;
                let mut settlement_timestamp__ = None;
                let mut settlement_price__ = None;
                let mut admin__ = None;
                let mut status__ = None;
                let mut oracle_params__ = None;
                let mut ticker__ = None;
                let mut min_notional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RelayerFeeShareRate => {
                            if relayer_fee_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "relayerFeeShareRate",
                                ));
                            }
                            relayer_fee_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpirationTimestamp => {
                            if expiration_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expirationTimestamp",
                                ));
                            }
                            expiration_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::SettlementTimestamp => {
                            if settlement_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "settlementTimestamp",
                                ));
                            }
                            settlement_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::SettlementPrice => {
                            if settlement_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlementPrice"));
                            }
                            settlement_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<MarketStatus>()? as i32);
                        }
                        GeneratedField::OracleParams => {
                            if oracle_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleParams"));
                            }
                            oracle_params__ = map_.next_value()?;
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BinaryOptionsMarketParamUpdateProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    relayer_fee_share_rate: relayer_fee_share_rate__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    expiration_timestamp: expiration_timestamp__.unwrap_or_default(),
                    settlement_timestamp: settlement_timestamp__.unwrap_or_default(),
                    settlement_price: settlement_price__.unwrap_or_default(),
                    admin: admin__.unwrap_or_default(),
                    status: status__.unwrap_or_default(),
                    oracle_params: oracle_params__,
                    ticker: ticker__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CampaignRewardPool {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.start_timestamp != 0 {
            len += 1;
        }
        if !self.max_campaign_rewards.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.CampaignRewardPool", len)?;
        if self.start_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "startTimestamp",
                ToString::to_string(&self.start_timestamp).as_str(),
            )?;
        }
        if !self.max_campaign_rewards.is_empty() {
            struct_ser.serialize_field("maxCampaignRewards", &self.max_campaign_rewards)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CampaignRewardPool {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "start_timestamp",
            "startTimestamp",
            "max_campaign_rewards",
            "maxCampaignRewards",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StartTimestamp,
            MaxCampaignRewards,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "startTimestamp" | "start_timestamp" => {
                                Ok(GeneratedField::StartTimestamp)
                            }
                            "maxCampaignRewards" | "max_campaign_rewards" => {
                                Ok(GeneratedField::MaxCampaignRewards)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CampaignRewardPool;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.CampaignRewardPool")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CampaignRewardPool, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut start_timestamp__ = None;
                let mut max_campaign_rewards__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StartTimestamp => {
                            if start_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTimestamp"));
                            }
                            start_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::MaxCampaignRewards => {
                            if max_campaign_rewards__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maxCampaignRewards",
                                ));
                            }
                            max_campaign_rewards__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CampaignRewardPool {
                    start_timestamp: start_timestamp__.unwrap_or_default(),
                    max_campaign_rewards: max_campaign_rewards__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.CampaignRewardPool",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CancelDerivativeOrderAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.CancelDerivativeOrderAuthz", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CancelDerivativeOrderAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CancelDerivativeOrderAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.CancelDerivativeOrderAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<CancelDerivativeOrderAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CancelDerivativeOrderAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.CancelDerivativeOrderAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CancelSpotOrderAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.CancelSpotOrderAuthz", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CancelSpotOrderAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CancelSpotOrderAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.CancelSpotOrderAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<CancelSpotOrderAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CancelSpotOrderAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.CancelSpotOrderAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CancellationStrategy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::UnspecifiedOrder => "UnspecifiedOrder",
            Self::FromWorstToBest => "FromWorstToBest",
            Self::FromBestToWorst => "FromBestToWorst",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CancellationStrategy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["UnspecifiedOrder", "FromWorstToBest", "FromBestToWorst"];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CancellationStrategy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UnspecifiedOrder" => Ok(CancellationStrategy::UnspecifiedOrder),
                    "FromWorstToBest" => Ok(CancellationStrategy::FromWorstToBest),
                    "FromBestToWorst" => Ok(CancellationStrategy::FromBestToWorst),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ConditionalDerivativeOrderBook {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.limit_buy_orders.is_empty() {
            len += 1;
        }
        if !self.market_buy_orders.is_empty() {
            len += 1;
        }
        if !self.limit_sell_orders.is_empty() {
            len += 1;
        }
        if !self.market_sell_orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.ConditionalDerivativeOrderBook",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.limit_buy_orders.is_empty() {
            struct_ser.serialize_field("limitBuyOrders", &self.limit_buy_orders)?;
        }
        if !self.market_buy_orders.is_empty() {
            struct_ser.serialize_field("marketBuyOrders", &self.market_buy_orders)?;
        }
        if !self.limit_sell_orders.is_empty() {
            struct_ser.serialize_field("limitSellOrders", &self.limit_sell_orders)?;
        }
        if !self.market_sell_orders.is_empty() {
            struct_ser.serialize_field("marketSellOrders", &self.market_sell_orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ConditionalDerivativeOrderBook {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "limit_buy_orders",
            "limitBuyOrders",
            "market_buy_orders",
            "marketBuyOrders",
            "limit_sell_orders",
            "limitSellOrders",
            "market_sell_orders",
            "marketSellOrders",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            LimitBuyOrders,
            MarketBuyOrders,
            LimitSellOrders,
            MarketSellOrders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "limitBuyOrders" | "limit_buy_orders" => {
                                Ok(GeneratedField::LimitBuyOrders)
                            }
                            "marketBuyOrders" | "market_buy_orders" => {
                                Ok(GeneratedField::MarketBuyOrders)
                            }
                            "limitSellOrders" | "limit_sell_orders" => {
                                Ok(GeneratedField::LimitSellOrders)
                            }
                            "marketSellOrders" | "market_sell_orders" => {
                                Ok(GeneratedField::MarketSellOrders)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConditionalDerivativeOrderBook;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.ConditionalDerivativeOrderBook")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<ConditionalDerivativeOrderBook, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut limit_buy_orders__ = None;
                let mut market_buy_orders__ = None;
                let mut limit_sell_orders__ = None;
                let mut market_sell_orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LimitBuyOrders => {
                            if limit_buy_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitBuyOrders"));
                            }
                            limit_buy_orders__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketBuyOrders => {
                            if market_buy_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketBuyOrders"));
                            }
                            market_buy_orders__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LimitSellOrders => {
                            if limit_sell_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitSellOrders"));
                            }
                            limit_sell_orders__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketSellOrders => {
                            if market_sell_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketSellOrders"));
                            }
                            market_sell_orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ConditionalDerivativeOrderBook {
                    market_id: market_id__.unwrap_or_default(),
                    limit_buy_orders: limit_buy_orders__.unwrap_or_default(),
                    market_buy_orders: market_buy_orders__.unwrap_or_default(),
                    limit_sell_orders: limit_sell_orders__.unwrap_or_default(),
                    market_sell_orders: market_sell_orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.ConditionalDerivativeOrderBook",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CreateDerivativeLimitOrderAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.CreateDerivativeLimitOrderAuthz",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CreateDerivativeLimitOrderAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateDerivativeLimitOrderAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.CreateDerivativeLimitOrderAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<CreateDerivativeLimitOrderAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateDerivativeLimitOrderAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.CreateDerivativeLimitOrderAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CreateDerivativeMarketOrderAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.CreateDerivativeMarketOrderAuthz",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CreateDerivativeMarketOrderAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateDerivativeMarketOrderAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.CreateDerivativeMarketOrderAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<CreateDerivativeMarketOrderAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateDerivativeMarketOrderAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.CreateDerivativeMarketOrderAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CreateSpotLimitOrderAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.CreateSpotLimitOrderAuthz", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CreateSpotLimitOrderAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateSpotLimitOrderAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.CreateSpotLimitOrderAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<CreateSpotLimitOrderAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateSpotLimitOrderAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.CreateSpotLimitOrderAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CreateSpotMarketOrderAuthz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.CreateSpotMarketOrderAuthz", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for CreateSpotMarketOrderAuthz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CreateSpotMarketOrderAuthz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.CreateSpotMarketOrderAuthz")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<CreateSpotMarketOrderAuthz, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CreateSpotMarketOrderAuthz {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.CreateSpotMarketOrderAuthz",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DenomDecimals {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.denom.is_empty() {
            len += 1;
        }
        if self.decimals != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DenomDecimals", len)?;
        if !self.denom.is_empty() {
            struct_ser.serialize_field("denom", &self.denom)?;
        }
        if self.decimals != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("decimals", ToString::to_string(&self.decimals).as_str())?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DenomDecimals {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["denom", "decimals"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Denom,
            Decimals,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "denom" => Ok(GeneratedField::Denom),
                            "decimals" => Ok(GeneratedField::Decimals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DenomDecimals;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DenomDecimals")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DenomDecimals, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut denom__ = None;
                let mut decimals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Denom => {
                            if denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denom"));
                            }
                            denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Decimals => {
                            if decimals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decimals"));
                            }
                            decimals__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(DenomDecimals {
                    denom: denom__.unwrap_or_default(),
                    decimals: decimals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DenomDecimals",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Deposit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.available_balance.is_empty() {
            len += 1;
        }
        if !self.total_balance.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.Deposit", len)?;
        if !self.available_balance.is_empty() {
            struct_ser.serialize_field("availableBalance", &self.available_balance)?;
        }
        if !self.total_balance.is_empty() {
            struct_ser.serialize_field("totalBalance", &self.total_balance)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for Deposit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "available_balance",
            "availableBalance",
            "total_balance",
            "totalBalance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AvailableBalance,
            TotalBalance,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "availableBalance" | "available_balance" => {
                                Ok(GeneratedField::AvailableBalance)
                            }
                            "totalBalance" | "total_balance" => Ok(GeneratedField::TotalBalance),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Deposit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.Deposit")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Deposit, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut available_balance__ = None;
                let mut total_balance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AvailableBalance => {
                            if available_balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("availableBalance"));
                            }
                            available_balance__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TotalBalance => {
                            if total_balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalBalance"));
                            }
                            total_balance__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Deposit {
                    available_balance: available_balance__.unwrap_or_default(),
                    total_balance: total_balance__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.Deposit",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DepositUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.denom.is_empty() {
            len += 1;
        }
        if !self.deposits.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DepositUpdate", len)?;
        if !self.denom.is_empty() {
            struct_ser.serialize_field("denom", &self.denom)?;
        }
        if !self.deposits.is_empty() {
            struct_ser.serialize_field("deposits", &self.deposits)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DepositUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["denom", "deposits"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Denom,
            Deposits,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "denom" => Ok(GeneratedField::Denom),
                            "deposits" => Ok(GeneratedField::Deposits),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DepositUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DepositUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DepositUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut denom__ = None;
                let mut deposits__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Denom => {
                            if denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denom"));
                            }
                            denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Deposits => {
                            if deposits__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deposits"));
                            }
                            deposits__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DepositUpdate {
                    denom: denom__.unwrap_or_default(),
                    deposits: deposits__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DepositUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeLimitOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.order_info.is_some() {
            len += 1;
        }
        if self.order_type != 0 {
            len += 1;
        }
        if !self.margin.is_empty() {
            len += 1;
        }
        if !self.fillable.is_empty() {
            len += 1;
        }
        if !self.trigger_price.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DerivativeLimitOrder", len)?;
        if let Some(v) = self.order_info.as_ref() {
            struct_ser.serialize_field("orderInfo", v)?;
        }
        if self.order_type != 0 {
            let v = OrderType::try_from(self.order_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.order_type))
            })?;
            struct_ser.serialize_field("orderType", &v)?;
        }
        if !self.margin.is_empty() {
            struct_ser.serialize_field("margin", &self.margin)?;
        }
        if !self.fillable.is_empty() {
            struct_ser.serialize_field("fillable", &self.fillable)?;
        }
        if !self.trigger_price.is_empty() {
            struct_ser.serialize_field("triggerPrice", &self.trigger_price)?;
        }
        if !self.order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "orderHash",
                pbjson::private::base64::encode(&self.order_hash).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeLimitOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "order_info",
            "orderInfo",
            "order_type",
            "orderType",
            "margin",
            "fillable",
            "trigger_price",
            "triggerPrice",
            "order_hash",
            "orderHash",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderInfo,
            OrderType,
            Margin,
            Fillable,
            TriggerPrice,
            OrderHash,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderInfo" | "order_info" => Ok(GeneratedField::OrderInfo),
                            "orderType" | "order_type" => Ok(GeneratedField::OrderType),
                            "margin" => Ok(GeneratedField::Margin),
                            "fillable" => Ok(GeneratedField::Fillable),
                            "triggerPrice" | "trigger_price" => Ok(GeneratedField::TriggerPrice),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeLimitOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativeLimitOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<DerivativeLimitOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_info__ = None;
                let mut order_type__ = None;
                let mut margin__ = None;
                let mut fillable__ = None;
                let mut trigger_price__ = None;
                let mut order_hash__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderInfo => {
                            if order_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderInfo"));
                            }
                            order_info__ = map_.next_value()?;
                        }
                        GeneratedField::OrderType => {
                            if order_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderType"));
                            }
                            order_type__ = Some(map_.next_value::<OrderType>()? as i32);
                        }
                        GeneratedField::Margin => {
                            if margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("margin"));
                            }
                            margin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fillable => {
                            if fillable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fillable"));
                            }
                            fillable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TriggerPrice => {
                            if trigger_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggerPrice"));
                            }
                            trigger_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(DerivativeLimitOrder {
                    order_info: order_info__,
                    order_type: order_type__.unwrap_or_default(),
                    margin: margin__.unwrap_or_default(),
                    fillable: fillable__.unwrap_or_default(),
                    trigger_price: trigger_price__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeLimitOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.oracle_base.is_empty() {
            len += 1;
        }
        if !self.oracle_quote.is_empty() {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            len += 1;
        }
        if self.is_perpetual {
            len += 1;
        }
        if self.status != 0 {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if !self.admin.is_empty() {
            len += 1;
        }
        if self.admin_permissions != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DerivativeMarket", len)?;
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.oracle_base.is_empty() {
            struct_ser.serialize_field("oracleBase", &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            struct_ser.serialize_field("oracleQuote", &self.oracle_quote)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            struct_ser.serialize_field("initialMarginRatio", &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field("maintenanceMarginRatio", &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            struct_ser.serialize_field("relayerFeeShareRate", &self.relayer_fee_share_rate)?;
        }
        if self.is_perpetual {
            struct_ser.serialize_field("isPerpetual", &self.is_perpetual)?;
        }
        if self.status != 0 {
            let v = MarketStatus::try_from(self.status).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.status))
            })?;
            struct_ser.serialize_field("status", &v)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if self.admin_permissions != 0 {
            struct_ser.serialize_field("adminPermissions", &self.admin_permissions)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ticker",
            "oracle_base",
            "oracleBase",
            "oracle_quote",
            "oracleQuote",
            "oracle_type",
            "oracleType",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "quote_denom",
            "quoteDenom",
            "market_id",
            "marketId",
            "initial_margin_ratio",
            "initialMarginRatio",
            "maintenance_margin_ratio",
            "maintenanceMarginRatio",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "relayer_fee_share_rate",
            "relayerFeeShareRate",
            "isPerpetual",
            "status",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
            "admin",
            "admin_permissions",
            "adminPermissions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ticker,
            OracleBase,
            OracleQuote,
            OracleType,
            OracleScaleFactor,
            QuoteDenom,
            MarketId,
            InitialMarginRatio,
            MaintenanceMarginRatio,
            MakerFeeRate,
            TakerFeeRate,
            RelayerFeeShareRate,
            IsPerpetual,
            Status,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
            Admin,
            AdminPermissions,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ticker" => Ok(GeneratedField::Ticker),
                            "oracleBase" | "oracle_base" => Ok(GeneratedField::OracleBase),
                            "oracleQuote" | "oracle_quote" => Ok(GeneratedField::OracleQuote),
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "initialMarginRatio" | "initial_margin_ratio" => {
                                Ok(GeneratedField::InitialMarginRatio)
                            }
                            "maintenanceMarginRatio" | "maintenance_margin_ratio" => {
                                Ok(GeneratedField::MaintenanceMarginRatio)
                            }
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "relayerFeeShareRate" | "relayer_fee_share_rate" => {
                                Ok(GeneratedField::RelayerFeeShareRate)
                            }
                            "isPerpetual" => Ok(GeneratedField::IsPerpetual),
                            "status" => Ok(GeneratedField::Status),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "admin" => Ok(GeneratedField::Admin),
                            "adminPermissions" | "admin_permissions" => {
                                Ok(GeneratedField::AdminPermissions)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativeMarket")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DerivativeMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut ticker__ = None;
                let mut oracle_base__ = None;
                let mut oracle_quote__ = None;
                let mut oracle_type__ = None;
                let mut oracle_scale_factor__ = None;
                let mut quote_denom__ = None;
                let mut market_id__ = None;
                let mut initial_margin_ratio__ = None;
                let mut maintenance_margin_ratio__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut relayer_fee_share_rate__ = None;
                let mut is_perpetual__ = None;
                let mut status__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                let mut admin__ = None;
                let mut admin_permissions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleBase => {
                            if oracle_base__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleBase"));
                            }
                            oracle_base__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleQuote => {
                            if oracle_quote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleQuote"));
                            }
                            oracle_quote__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InitialMarginRatio => {
                            if initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "initialMarginRatio",
                                ));
                            }
                            initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaintenanceMarginRatio => {
                            if maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maintenanceMarginRatio",
                                ));
                            }
                            maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RelayerFeeShareRate => {
                            if relayer_fee_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "relayerFeeShareRate",
                                ));
                            }
                            relayer_fee_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsPerpetual => {
                            if is_perpetual__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isPerpetual"));
                            }
                            is_perpetual__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<MarketStatus>()? as i32);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminPermissions => {
                            if admin_permissions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminPermissions"));
                            }
                            admin_permissions__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(DerivativeMarket {
                    ticker: ticker__.unwrap_or_default(),
                    oracle_base: oracle_base__.unwrap_or_default(),
                    oracle_quote: oracle_quote__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    initial_margin_ratio: initial_margin_ratio__.unwrap_or_default(),
                    maintenance_margin_ratio: maintenance_margin_ratio__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    relayer_fee_share_rate: relayer_fee_share_rate__.unwrap_or_default(),
                    is_perpetual: is_perpetual__.unwrap_or_default(),
                    status: status__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin: admin__.unwrap_or_default(),
                    admin_permissions: admin_permissions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeMarketOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.order_info.is_some() {
            len += 1;
        }
        if self.order_type != 0 {
            len += 1;
        }
        if !self.margin.is_empty() {
            len += 1;
        }
        if !self.margin_hold.is_empty() {
            len += 1;
        }
        if !self.trigger_price.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DerivativeMarketOrder", len)?;
        if let Some(v) = self.order_info.as_ref() {
            struct_ser.serialize_field("orderInfo", v)?;
        }
        if self.order_type != 0 {
            let v = OrderType::try_from(self.order_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.order_type))
            })?;
            struct_ser.serialize_field("orderType", &v)?;
        }
        if !self.margin.is_empty() {
            struct_ser.serialize_field("margin", &self.margin)?;
        }
        if !self.margin_hold.is_empty() {
            struct_ser.serialize_field("marginHold", &self.margin_hold)?;
        }
        if !self.trigger_price.is_empty() {
            struct_ser.serialize_field("triggerPrice", &self.trigger_price)?;
        }
        if !self.order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "orderHash",
                pbjson::private::base64::encode(&self.order_hash).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeMarketOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "order_info",
            "orderInfo",
            "order_type",
            "orderType",
            "margin",
            "margin_hold",
            "marginHold",
            "trigger_price",
            "triggerPrice",
            "order_hash",
            "orderHash",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderInfo,
            OrderType,
            Margin,
            MarginHold,
            TriggerPrice,
            OrderHash,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderInfo" | "order_info" => Ok(GeneratedField::OrderInfo),
                            "orderType" | "order_type" => Ok(GeneratedField::OrderType),
                            "margin" => Ok(GeneratedField::Margin),
                            "marginHold" | "margin_hold" => Ok(GeneratedField::MarginHold),
                            "triggerPrice" | "trigger_price" => Ok(GeneratedField::TriggerPrice),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeMarketOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativeMarketOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<DerivativeMarketOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_info__ = None;
                let mut order_type__ = None;
                let mut margin__ = None;
                let mut margin_hold__ = None;
                let mut trigger_price__ = None;
                let mut order_hash__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderInfo => {
                            if order_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderInfo"));
                            }
                            order_info__ = map_.next_value()?;
                        }
                        GeneratedField::OrderType => {
                            if order_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderType"));
                            }
                            order_type__ = Some(map_.next_value::<OrderType>()? as i32);
                        }
                        GeneratedField::Margin => {
                            if margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("margin"));
                            }
                            margin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarginHold => {
                            if margin_hold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marginHold"));
                            }
                            margin_hold__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TriggerPrice => {
                            if trigger_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggerPrice"));
                            }
                            trigger_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(DerivativeMarketOrder {
                    order_info: order_info__,
                    order_type: order_type__.unwrap_or_default(),
                    margin: margin__.unwrap_or_default(),
                    margin_hold: margin_hold__.unwrap_or_default(),
                    trigger_price: trigger_price__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeMarketOrderCancel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market_order.is_some() {
            len += 1;
        }
        if !self.cancel_quantity.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketOrderCancel",
            len,
        )?;
        if let Some(v) = self.market_order.as_ref() {
            struct_ser.serialize_field("marketOrder", v)?;
        }
        if !self.cancel_quantity.is_empty() {
            struct_ser.serialize_field("cancelQuantity", &self.cancel_quantity)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeMarketOrderCancel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_order",
            "marketOrder",
            "cancel_quantity",
            "cancelQuantity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketOrder,
            CancelQuantity,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketOrder" | "market_order" => Ok(GeneratedField::MarketOrder),
                            "cancelQuantity" | "cancel_quantity" => {
                                Ok(GeneratedField::CancelQuantity)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeMarketOrderCancel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativeMarketOrderCancel")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<DerivativeMarketOrderCancel, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_order__ = None;
                let mut cancel_quantity__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketOrder => {
                            if market_order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketOrder"));
                            }
                            market_order__ = map_.next_value()?;
                        }
                        GeneratedField::CancelQuantity => {
                            if cancel_quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cancelQuantity"));
                            }
                            cancel_quantity__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DerivativeMarketOrderCancel {
                    market_order: market_order__,
                    cancel_quantity: cancel_quantity__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketOrderCancel",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeMarketOrderResults {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.fee.is_empty() {
            len += 1;
        }
        if self.position_delta.is_some() {
            len += 1;
        }
        if !self.payout.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketOrderResults",
            len,
        )?;
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.fee.is_empty() {
            struct_ser.serialize_field("fee", &self.fee)?;
        }
        if let Some(v) = self.position_delta.as_ref() {
            struct_ser.serialize_field("positionDelta", v)?;
        }
        if !self.payout.is_empty() {
            struct_ser.serialize_field("payout", &self.payout)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeMarketOrderResults {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "quantity",
            "price",
            "fee",
            "position_delta",
            "positionDelta",
            "payout",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Quantity,
            Price,
            Fee,
            PositionDelta,
            Payout,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "quantity" => Ok(GeneratedField::Quantity),
                            "price" => Ok(GeneratedField::Price),
                            "fee" => Ok(GeneratedField::Fee),
                            "positionDelta" | "position_delta" => Ok(GeneratedField::PositionDelta),
                            "payout" => Ok(GeneratedField::Payout),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeMarketOrderResults;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.DerivativeMarketOrderResults")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<DerivativeMarketOrderResults, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut quantity__ = None;
                let mut price__ = None;
                let mut fee__ = None;
                let mut position_delta__ = None;
                let mut payout__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fee => {
                            if fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fee"));
                            }
                            fee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PositionDelta => {
                            if position_delta__.is_some() {
                                return Err(serde::de::Error::duplicate_field("positionDelta"));
                            }
                            position_delta__ = map_.next_value()?;
                        }
                        GeneratedField::Payout => {
                            if payout__.is_some() {
                                return Err(serde::de::Error::duplicate_field("payout"));
                            }
                            payout__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DerivativeMarketOrderResults {
                    quantity: quantity__.unwrap_or_default(),
                    price: price__.unwrap_or_default(),
                    fee: fee__.unwrap_or_default(),
                    position_delta: position_delta__,
                    payout: payout__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketOrderResults",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeMarketParamUpdateProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.hourly_interest_rate.is_empty() {
            len += 1;
        }
        if !self.hourly_funding_rate_cap.is_empty() {
            len += 1;
        }
        if self.status != 0 {
            len += 1;
        }
        if self.oracle_params.is_some() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if self.admin_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            struct_ser.serialize_field("initialMarginRatio", &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field("maintenanceMarginRatio", &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            struct_ser.serialize_field("relayerFeeShareRate", &self.relayer_fee_share_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.hourly_interest_rate.is_empty() {
            struct_ser.serialize_field("HourlyInterestRate", &self.hourly_interest_rate)?;
        }
        if !self.hourly_funding_rate_cap.is_empty() {
            struct_ser.serialize_field("HourlyFundingRateCap", &self.hourly_funding_rate_cap)?;
        }
        if self.status != 0 {
            let v = MarketStatus::try_from(self.status).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.status))
            })?;
            struct_ser.serialize_field("status", &v)?;
        }
        if let Some(v) = self.oracle_params.as_ref() {
            struct_ser.serialize_field("oracleParams", v)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if let Some(v) = self.admin_info.as_ref() {
            struct_ser.serialize_field("adminInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeMarketParamUpdateProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "market_id",
            "marketId",
            "initial_margin_ratio",
            "initialMarginRatio",
            "maintenance_margin_ratio",
            "maintenanceMarginRatio",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "relayer_fee_share_rate",
            "relayerFeeShareRate",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "HourlyInterestRate",
            "HourlyFundingRateCap",
            "status",
            "oracle_params",
            "oracleParams",
            "ticker",
            "min_notional",
            "minNotional",
            "admin_info",
            "adminInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            MarketId,
            InitialMarginRatio,
            MaintenanceMarginRatio,
            MakerFeeRate,
            TakerFeeRate,
            RelayerFeeShareRate,
            MinPriceTickSize,
            MinQuantityTickSize,
            HourlyInterestRate,
            HourlyFundingRateCap,
            Status,
            OracleParams,
            Ticker,
            MinNotional,
            AdminInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "initialMarginRatio" | "initial_margin_ratio" => {
                                Ok(GeneratedField::InitialMarginRatio)
                            }
                            "maintenanceMarginRatio" | "maintenance_margin_ratio" => {
                                Ok(GeneratedField::MaintenanceMarginRatio)
                            }
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "relayerFeeShareRate" | "relayer_fee_share_rate" => {
                                Ok(GeneratedField::RelayerFeeShareRate)
                            }
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "HourlyInterestRate" => Ok(GeneratedField::HourlyInterestRate),
                            "HourlyFundingRateCap" => Ok(GeneratedField::HourlyFundingRateCap),
                            "status" => Ok(GeneratedField::Status),
                            "oracleParams" | "oracle_params" => Ok(GeneratedField::OracleParams),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "adminInfo" | "admin_info" => Ok(GeneratedField::AdminInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeMarketParamUpdateProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<DerivativeMarketParamUpdateProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut market_id__ = None;
                let mut initial_margin_ratio__ = None;
                let mut maintenance_margin_ratio__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut relayer_fee_share_rate__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut hourly_interest_rate__ = None;
                let mut hourly_funding_rate_cap__ = None;
                let mut status__ = None;
                let mut oracle_params__ = None;
                let mut ticker__ = None;
                let mut min_notional__ = None;
                let mut admin_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InitialMarginRatio => {
                            if initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "initialMarginRatio",
                                ));
                            }
                            initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaintenanceMarginRatio => {
                            if maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maintenanceMarginRatio",
                                ));
                            }
                            maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RelayerFeeShareRate => {
                            if relayer_fee_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "relayerFeeShareRate",
                                ));
                            }
                            relayer_fee_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HourlyInterestRate => {
                            if hourly_interest_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "HourlyInterestRate",
                                ));
                            }
                            hourly_interest_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HourlyFundingRateCap => {
                            if hourly_funding_rate_cap__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "HourlyFundingRateCap",
                                ));
                            }
                            hourly_funding_rate_cap__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<MarketStatus>()? as i32);
                        }
                        GeneratedField::OracleParams => {
                            if oracle_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleParams"));
                            }
                            oracle_params__ = map_.next_value()?;
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminInfo => {
                            if admin_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminInfo"));
                            }
                            admin_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DerivativeMarketParamUpdateProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    initial_margin_ratio: initial_margin_ratio__.unwrap_or_default(),
                    maintenance_margin_ratio: maintenance_margin_ratio__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    relayer_fee_share_rate: relayer_fee_share_rate__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    hourly_interest_rate: hourly_interest_rate__.unwrap_or_default(),
                    hourly_funding_rate_cap: hourly_funding_rate_cap__.unwrap_or_default(),
                    status: status__.unwrap_or_default(),
                    oracle_params: oracle_params__,
                    ticker: ticker__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin_info: admin_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeMarketSettlementInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.settlement_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketSettlementInfo",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.settlement_price.is_empty() {
            struct_ser.serialize_field("settlementPrice", &self.settlement_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeMarketSettlementInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "settlement_price",
            "settlementPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SettlementPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "settlementPrice" | "settlement_price" => {
                                Ok(GeneratedField::SettlementPrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeMarketSettlementInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.DerivativeMarketSettlementInfo")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<DerivativeMarketSettlementInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut settlement_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlementPrice => {
                            if settlement_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlementPrice"));
                            }
                            settlement_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DerivativeMarketSettlementInfo {
                    market_id: market_id__.unwrap_or_default(),
                    settlement_price: settlement_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeMarketSettlementInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.order_info.is_some() {
            len += 1;
        }
        if self.order_type != 0 {
            len += 1;
        }
        if !self.margin.is_empty() {
            len += 1;
        }
        if !self.trigger_price.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DerivativeOrder", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.order_info.as_ref() {
            struct_ser.serialize_field("orderInfo", v)?;
        }
        if self.order_type != 0 {
            let v = OrderType::try_from(self.order_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.order_type))
            })?;
            struct_ser.serialize_field("orderType", &v)?;
        }
        if !self.margin.is_empty() {
            struct_ser.serialize_field("margin", &self.margin)?;
        }
        if !self.trigger_price.is_empty() {
            struct_ser.serialize_field("triggerPrice", &self.trigger_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "order_info",
            "orderInfo",
            "order_type",
            "orderType",
            "margin",
            "trigger_price",
            "triggerPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            OrderInfo,
            OrderType,
            Margin,
            TriggerPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "orderInfo" | "order_info" => Ok(GeneratedField::OrderInfo),
                            "orderType" | "order_type" => Ok(GeneratedField::OrderType),
                            "margin" => Ok(GeneratedField::Margin),
                            "triggerPrice" | "trigger_price" => Ok(GeneratedField::TriggerPrice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativeOrder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DerivativeOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut order_info__ = None;
                let mut order_type__ = None;
                let mut margin__ = None;
                let mut trigger_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderInfo => {
                            if order_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderInfo"));
                            }
                            order_info__ = map_.next_value()?;
                        }
                        GeneratedField::OrderType => {
                            if order_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderType"));
                            }
                            order_type__ = Some(map_.next_value::<OrderType>()? as i32);
                        }
                        GeneratedField::Margin => {
                            if margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("margin"));
                            }
                            margin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TriggerPrice => {
                            if trigger_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggerPrice"));
                            }
                            trigger_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DerivativeOrder {
                    market_id: market_id__.unwrap_or_default(),
                    order_info: order_info__,
                    order_type: order_type__.unwrap_or_default(),
                    margin: margin__.unwrap_or_default(),
                    trigger_price: trigger_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeOrderBook {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_buy_side {
            len += 1;
        }
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DerivativeOrderBook", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_buy_side {
            struct_ser.serialize_field("isBuySide", &self.is_buy_side)?;
        }
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeOrderBook {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "isBuySide", "orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsBuySide,
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isBuySide" => Ok(GeneratedField::IsBuySide),
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeOrderBook;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativeOrderBook")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DerivativeOrderBook, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_buy_side__ = None;
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuySide => {
                            if is_buy_side__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuySide"));
                            }
                            is_buy_side__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DerivativeOrderBook {
                    market_id: market_id__.unwrap_or_default(),
                    is_buy_side: is_buy_side__.unwrap_or_default(),
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeOrderBook",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativePosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.position.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DerivativePosition", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.position.as_ref() {
            struct_ser.serialize_field("position", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativePosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccount_id",
            "subaccountId",
            "market_id",
            "marketId",
            "position",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketId,
            Position,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "position" => Ok(GeneratedField::Position),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativePosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativePosition")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DerivativePosition, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_id__ = None;
                let mut position__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Position => {
                            if position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("position"));
                            }
                            position__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DerivativePosition {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    position: position__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativePosition",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DerivativeTradeLog {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if self.position_delta.is_some() {
            len += 1;
        }
        if !self.payout.is_empty() {
            len += 1;
        }
        if !self.fee.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.fee_recipient_address.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        if !self.pnl.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.DerivativeTradeLog", len)?;
        if !self.subaccount_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "subaccountId",
                pbjson::private::base64::encode(&self.subaccount_id).as_str(),
            )?;
        }
        if let Some(v) = self.position_delta.as_ref() {
            struct_ser.serialize_field("positionDelta", v)?;
        }
        if !self.payout.is_empty() {
            struct_ser.serialize_field("payout", &self.payout)?;
        }
        if !self.fee.is_empty() {
            struct_ser.serialize_field("fee", &self.fee)?;
        }
        if !self.order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "orderHash",
                pbjson::private::base64::encode(&self.order_hash).as_str(),
            )?;
        }
        if !self.fee_recipient_address.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "feeRecipientAddress",
                pbjson::private::base64::encode(&self.fee_recipient_address).as_str(),
            )?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        if !self.pnl.is_empty() {
            struct_ser.serialize_field("pnl", &self.pnl)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for DerivativeTradeLog {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccount_id",
            "subaccountId",
            "position_delta",
            "positionDelta",
            "payout",
            "fee",
            "order_hash",
            "orderHash",
            "fee_recipient_address",
            "feeRecipientAddress",
            "cid",
            "pnl",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            PositionDelta,
            Payout,
            Fee,
            OrderHash,
            FeeRecipientAddress,
            Cid,
            Pnl,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "positionDelta" | "position_delta" => Ok(GeneratedField::PositionDelta),
                            "payout" => Ok(GeneratedField::Payout),
                            "fee" => Ok(GeneratedField::Fee),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "feeRecipientAddress" | "fee_recipient_address" => {
                                Ok(GeneratedField::FeeRecipientAddress)
                            }
                            "cid" => Ok(GeneratedField::Cid),
                            "pnl" => Ok(GeneratedField::Pnl),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivativeTradeLog;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.DerivativeTradeLog")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DerivativeTradeLog, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut position_delta__ = None;
                let mut payout__ = None;
                let mut fee__ = None;
                let mut order_hash__ = None;
                let mut fee_recipient_address__ = None;
                let mut cid__ = None;
                let mut pnl__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::PositionDelta => {
                            if position_delta__.is_some() {
                                return Err(serde::de::Error::duplicate_field("positionDelta"));
                            }
                            position_delta__ = map_.next_value()?;
                        }
                        GeneratedField::Payout => {
                            if payout__.is_some() {
                                return Err(serde::de::Error::duplicate_field("payout"));
                            }
                            payout__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fee => {
                            if fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fee"));
                            }
                            fee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::FeeRecipientAddress => {
                            if fee_recipient_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "feeRecipientAddress",
                                ));
                            }
                            fee_recipient_address__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Pnl => {
                            if pnl__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pnl"));
                            }
                            pnl__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DerivativeTradeLog {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    position_delta: position_delta__,
                    payout: payout__.unwrap_or_default(),
                    fee: fee__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    fee_recipient_address: fee_recipient_address__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                    pnl: pnl__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.DerivativeTradeLog",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EffectiveGrant {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.granter.is_empty() {
            len += 1;
        }
        if !self.net_granted_stake.is_empty() {
            len += 1;
        }
        if self.is_valid {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EffectiveGrant", len)?;
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        if !self.net_granted_stake.is_empty() {
            struct_ser.serialize_field("netGrantedStake", &self.net_granted_stake)?;
        }
        if self.is_valid {
            struct_ser.serialize_field("isValid", &self.is_valid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EffectiveGrant {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "granter",
            "net_granted_stake",
            "netGrantedStake",
            "is_valid",
            "isValid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Granter,
            NetGrantedStake,
            IsValid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "granter" => Ok(GeneratedField::Granter),
                            "netGrantedStake" | "net_granted_stake" => {
                                Ok(GeneratedField::NetGrantedStake)
                            }
                            "isValid" | "is_valid" => Ok(GeneratedField::IsValid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EffectiveGrant;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EffectiveGrant")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EffectiveGrant, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut granter__ = None;
                let mut net_granted_stake__ = None;
                let mut is_valid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NetGrantedStake => {
                            if net_granted_stake__.is_some() {
                                return Err(serde::de::Error::duplicate_field("netGrantedStake"));
                            }
                            net_granted_stake__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsValid => {
                            if is_valid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isValid"));
                            }
                            is_valid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EffectiveGrant {
                    granter: granter__.unwrap_or_default(),
                    net_granted_stake: net_granted_stake__.unwrap_or_default(),
                    is_valid: is_valid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EffectiveGrant",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EffectivePosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_long {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.entry_price.is_empty() {
            len += 1;
        }
        if !self.effective_margin.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EffectivePosition", len)?;
        if self.is_long {
            struct_ser.serialize_field("isLong", &self.is_long)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.entry_price.is_empty() {
            struct_ser.serialize_field("entryPrice", &self.entry_price)?;
        }
        if !self.effective_margin.is_empty() {
            struct_ser.serialize_field("effectiveMargin", &self.effective_margin)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EffectivePosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_long",
            "isLong",
            "quantity",
            "entry_price",
            "entryPrice",
            "effective_margin",
            "effectiveMargin",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsLong,
            Quantity,
            EntryPrice,
            EffectiveMargin,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isLong" | "is_long" => Ok(GeneratedField::IsLong),
                            "quantity" => Ok(GeneratedField::Quantity),
                            "entryPrice" | "entry_price" => Ok(GeneratedField::EntryPrice),
                            "effectiveMargin" | "effective_margin" => {
                                Ok(GeneratedField::EffectiveMargin)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EffectivePosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EffectivePosition")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EffectivePosition, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut is_long__ = None;
                let mut quantity__ = None;
                let mut entry_price__ = None;
                let mut effective_margin__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsLong => {
                            if is_long__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLong"));
                            }
                            is_long__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::EntryPrice => {
                            if entry_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("entryPrice"));
                            }
                            entry_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::EffectiveMargin => {
                            if effective_margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("effectiveMargin"));
                            }
                            effective_margin__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EffectivePosition {
                    is_long: is_long__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                    entry_price: entry_price__.unwrap_or_default(),
                    effective_margin: effective_margin__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EffectivePosition",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventAllPositionsHaircut {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.settle_price.is_empty() {
            len += 1;
        }
        if !self.missing_funds_rate.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventAllPositionsHaircut", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.settle_price.is_empty() {
            struct_ser.serialize_field("settlePrice", &self.settle_price)?;
        }
        if !self.missing_funds_rate.is_empty() {
            struct_ser.serialize_field("missingFundsRate", &self.missing_funds_rate)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventAllPositionsHaircut {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "settle_price",
            "settlePrice",
            "missing_funds_rate",
            "missingFundsRate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SettlePrice,
            MissingFundsRate,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "settlePrice" | "settle_price" => Ok(GeneratedField::SettlePrice),
                            "missingFundsRate" | "missing_funds_rate" => {
                                Ok(GeneratedField::MissingFundsRate)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventAllPositionsHaircut;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventAllPositionsHaircut")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventAllPositionsHaircut, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut settle_price__ = None;
                let mut missing_funds_rate__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlePrice => {
                            if settle_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlePrice"));
                            }
                            settle_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingFundsRate => {
                            if missing_funds_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missingFundsRate"));
                            }
                            missing_funds_rate__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventAllPositionsHaircut {
                    market_id: market_id__.unwrap_or_default(),
                    settle_price: settle_price__.unwrap_or_default(),
                    missing_funds_rate: missing_funds_rate__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventAllPositionsHaircut",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventAtomicMarketOrderFeeMultipliersUpdated {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_fee_multipliers.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated",
            len,
        )?;
        if !self.market_fee_multipliers.is_empty() {
            struct_ser.serialize_field("marketFeeMultipliers", &self.market_fee_multipliers)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventAtomicMarketOrderFeeMultipliersUpdated {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_fee_multipliers", "marketFeeMultipliers"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketFeeMultipliers,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketFeeMultipliers" | "market_fee_multipliers" => {
                                Ok(GeneratedField::MarketFeeMultipliers)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventAtomicMarketOrderFeeMultipliersUpdated;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventAtomicMarketOrderFeeMultipliersUpdated, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_fee_multipliers__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketFeeMultipliers => {
                            if market_fee_multipliers__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "marketFeeMultipliers",
                                ));
                            }
                            market_fee_multipliers__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventAtomicMarketOrderFeeMultipliersUpdated {
                    market_fee_multipliers: market_fee_multipliers__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventBatchDepositUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.deposit_updates.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventBatchDepositUpdate", len)?;
        if !self.deposit_updates.is_empty() {
            struct_ser.serialize_field("depositUpdates", &self.deposit_updates)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventBatchDepositUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["deposit_updates", "depositUpdates"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DepositUpdates,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "depositUpdates" | "deposit_updates" => {
                                Ok(GeneratedField::DepositUpdates)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventBatchDepositUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventBatchDepositUpdate")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventBatchDepositUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut deposit_updates__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DepositUpdates => {
                            if deposit_updates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("depositUpdates"));
                            }
                            deposit_updates__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventBatchDepositUpdate {
                    deposit_updates: deposit_updates__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventBatchDepositUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventBatchDerivativeExecution {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_buy {
            len += 1;
        }
        if self.is_liquidation {
            len += 1;
        }
        if !self.cumulative_funding.is_empty() {
            len += 1;
        }
        if self.execution_type != 0 {
            len += 1;
        }
        if !self.trades.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventBatchDerivativeExecution",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_buy {
            struct_ser.serialize_field("isBuy", &self.is_buy)?;
        }
        if self.is_liquidation {
            struct_ser.serialize_field("isLiquidation", &self.is_liquidation)?;
        }
        if !self.cumulative_funding.is_empty() {
            struct_ser.serialize_field("cumulativeFunding", &self.cumulative_funding)?;
        }
        if self.execution_type != 0 {
            let v = ExecutionType::try_from(self.execution_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.execution_type))
            })?;
            struct_ser.serialize_field("executionType", &v)?;
        }
        if !self.trades.is_empty() {
            struct_ser.serialize_field("trades", &self.trades)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventBatchDerivativeExecution {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "is_buy",
            "isBuy",
            "is_liquidation",
            "isLiquidation",
            "cumulative_funding",
            "cumulativeFunding",
            "executionType",
            "trades",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsBuy,
            IsLiquidation,
            CumulativeFunding,
            ExecutionType,
            Trades,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isBuy" | "is_buy" => Ok(GeneratedField::IsBuy),
                            "isLiquidation" | "is_liquidation" => Ok(GeneratedField::IsLiquidation),
                            "cumulativeFunding" | "cumulative_funding" => {
                                Ok(GeneratedField::CumulativeFunding)
                            }
                            "executionType" => Ok(GeneratedField::ExecutionType),
                            "trades" => Ok(GeneratedField::Trades),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventBatchDerivativeExecution;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventBatchDerivativeExecution")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventBatchDerivativeExecution, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_buy__ = None;
                let mut is_liquidation__ = None;
                let mut cumulative_funding__ = None;
                let mut execution_type__ = None;
                let mut trades__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuy => {
                            if is_buy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuy"));
                            }
                            is_buy__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsLiquidation => {
                            if is_liquidation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLiquidation"));
                            }
                            is_liquidation__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CumulativeFunding => {
                            if cumulative_funding__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cumulativeFunding"));
                            }
                            cumulative_funding__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExecutionType => {
                            if execution_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("executionType"));
                            }
                            execution_type__ = Some(map_.next_value::<ExecutionType>()? as i32);
                        }
                        GeneratedField::Trades => {
                            if trades__.is_some() {
                                return Err(serde::de::Error::duplicate_field("trades"));
                            }
                            trades__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventBatchDerivativeExecution {
                    market_id: market_id__.unwrap_or_default(),
                    is_buy: is_buy__.unwrap_or_default(),
                    is_liquidation: is_liquidation__.unwrap_or_default(),
                    cumulative_funding: cumulative_funding__.unwrap_or_default(),
                    execution_type: execution_type__.unwrap_or_default(),
                    trades: trades__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventBatchDerivativeExecution",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventBatchDerivativePosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.positions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventBatchDerivativePosition",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.positions.is_empty() {
            struct_ser.serialize_field("positions", &self.positions)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventBatchDerivativePosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "positions"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Positions,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "positions" => Ok(GeneratedField::Positions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventBatchDerivativePosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventBatchDerivativePosition")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventBatchDerivativePosition, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut positions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Positions => {
                            if positions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("positions"));
                            }
                            positions__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventBatchDerivativePosition {
                    market_id: market_id__.unwrap_or_default(),
                    positions: positions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventBatchDerivativePosition",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventBatchSpotExecution {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_buy {
            len += 1;
        }
        if self.execution_type != 0 {
            len += 1;
        }
        if !self.trades.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventBatchSpotExecution", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_buy {
            struct_ser.serialize_field("isBuy", &self.is_buy)?;
        }
        if self.execution_type != 0 {
            let v = ExecutionType::try_from(self.execution_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.execution_type))
            })?;
            struct_ser.serialize_field("executionType", &v)?;
        }
        if !self.trades.is_empty() {
            struct_ser.serialize_field("trades", &self.trades)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventBatchSpotExecution {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "is_buy",
            "isBuy",
            "executionType",
            "trades",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsBuy,
            ExecutionType,
            Trades,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isBuy" | "is_buy" => Ok(GeneratedField::IsBuy),
                            "executionType" => Ok(GeneratedField::ExecutionType),
                            "trades" => Ok(GeneratedField::Trades),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventBatchSpotExecution;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventBatchSpotExecution")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventBatchSpotExecution, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_buy__ = None;
                let mut execution_type__ = None;
                let mut trades__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuy => {
                            if is_buy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuy"));
                            }
                            is_buy__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExecutionType => {
                            if execution_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("executionType"));
                            }
                            execution_type__ = Some(map_.next_value::<ExecutionType>()? as i32);
                        }
                        GeneratedField::Trades => {
                            if trades__.is_some() {
                                return Err(serde::de::Error::duplicate_field("trades"));
                            }
                            trades__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventBatchSpotExecution {
                    market_id: market_id__.unwrap_or_default(),
                    is_buy: is_buy__.unwrap_or_default(),
                    execution_type: execution_type__.unwrap_or_default(),
                    trades: trades__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventBatchSpotExecution",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventBinaryOptionsMarketUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate",
            len,
        )?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventBinaryOptionsMarketUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventBinaryOptionsMarketUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventBinaryOptionsMarketUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventBinaryOptionsMarketUpdate { market: market__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventCancelConditionalDerivativeOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_limit_cancel {
            len += 1;
        }
        if self.limit_order.is_some() {
            len += 1;
        }
        if self.market_order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_limit_cancel {
            struct_ser.serialize_field("isLimitCancel", &self.is_limit_cancel)?;
        }
        if let Some(v) = self.limit_order.as_ref() {
            struct_ser.serialize_field("limitOrder", v)?;
        }
        if let Some(v) = self.market_order.as_ref() {
            struct_ser.serialize_field("marketOrder", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventCancelConditionalDerivativeOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "isLimitCancel",
            "limit_order",
            "limitOrder",
            "market_order",
            "marketOrder",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsLimitCancel,
            LimitOrder,
            MarketOrder,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isLimitCancel" => Ok(GeneratedField::IsLimitCancel),
                            "limitOrder" | "limit_order" => Ok(GeneratedField::LimitOrder),
                            "marketOrder" | "market_order" => Ok(GeneratedField::MarketOrder),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventCancelConditionalDerivativeOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventCancelConditionalDerivativeOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_limit_cancel__ = None;
                let mut limit_order__ = None;
                let mut market_order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsLimitCancel => {
                            if is_limit_cancel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLimitCancel"));
                            }
                            is_limit_cancel__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LimitOrder => {
                            if limit_order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitOrder"));
                            }
                            limit_order__ = map_.next_value()?;
                        }
                        GeneratedField::MarketOrder => {
                            if market_order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketOrder"));
                            }
                            market_order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventCancelConditionalDerivativeOrder {
                    market_id: market_id__.unwrap_or_default(),
                    is_limit_cancel: is_limit_cancel__.unwrap_or_default(),
                    limit_order: limit_order__,
                    market_order: market_order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventCancelDerivativeOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_limit_cancel {
            len += 1;
        }
        if self.limit_order.is_some() {
            len += 1;
        }
        if self.market_order_cancel.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventCancelDerivativeOrder", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_limit_cancel {
            struct_ser.serialize_field("isLimitCancel", &self.is_limit_cancel)?;
        }
        if let Some(v) = self.limit_order.as_ref() {
            struct_ser.serialize_field("limitOrder", v)?;
        }
        if let Some(v) = self.market_order_cancel.as_ref() {
            struct_ser.serialize_field("marketOrderCancel", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventCancelDerivativeOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "isLimitCancel",
            "limit_order",
            "limitOrder",
            "market_order_cancel",
            "marketOrderCancel",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsLimitCancel,
            LimitOrder,
            MarketOrderCancel,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isLimitCancel" => Ok(GeneratedField::IsLimitCancel),
                            "limitOrder" | "limit_order" => Ok(GeneratedField::LimitOrder),
                            "marketOrderCancel" | "market_order_cancel" => {
                                Ok(GeneratedField::MarketOrderCancel)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventCancelDerivativeOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventCancelDerivativeOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventCancelDerivativeOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_limit_cancel__ = None;
                let mut limit_order__ = None;
                let mut market_order_cancel__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsLimitCancel => {
                            if is_limit_cancel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLimitCancel"));
                            }
                            is_limit_cancel__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LimitOrder => {
                            if limit_order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitOrder"));
                            }
                            limit_order__ = map_.next_value()?;
                        }
                        GeneratedField::MarketOrderCancel => {
                            if market_order_cancel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketOrderCancel"));
                            }
                            market_order_cancel__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventCancelDerivativeOrder {
                    market_id: market_id__.unwrap_or_default(),
                    is_limit_cancel: is_limit_cancel__.unwrap_or_default(),
                    limit_order: limit_order__,
                    market_order_cancel: market_order_cancel__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventCancelDerivativeOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventCancelSpotOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventCancelSpotOrder", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventCancelSpotOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "order"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventCancelSpotOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventCancelSpotOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventCancelSpotOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventCancelSpotOrder {
                    market_id: market_id__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventCancelSpotOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventConditionalDerivativeOrderTrigger {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_limit_trigger {
            len += 1;
        }
        if !self.triggered_order_hash.is_empty() {
            len += 1;
        }
        if !self.placed_order_hash.is_empty() {
            len += 1;
        }
        if !self.triggered_order_cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger",
            len,
        )?;
        if !self.market_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "marketId",
                pbjson::private::base64::encode(&self.market_id).as_str(),
            )?;
        }
        if self.is_limit_trigger {
            struct_ser.serialize_field("isLimitTrigger", &self.is_limit_trigger)?;
        }
        if !self.triggered_order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "triggeredOrderHash",
                pbjson::private::base64::encode(&self.triggered_order_hash).as_str(),
            )?;
        }
        if !self.placed_order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "placedOrderHash",
                pbjson::private::base64::encode(&self.placed_order_hash).as_str(),
            )?;
        }
        if !self.triggered_order_cid.is_empty() {
            struct_ser.serialize_field("triggeredOrderCid", &self.triggered_order_cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventConditionalDerivativeOrderTrigger {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "isLimitTrigger",
            "triggered_order_hash",
            "triggeredOrderHash",
            "placed_order_hash",
            "placedOrderHash",
            "triggered_order_cid",
            "triggeredOrderCid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsLimitTrigger,
            TriggeredOrderHash,
            PlacedOrderHash,
            TriggeredOrderCid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isLimitTrigger" => Ok(GeneratedField::IsLimitTrigger),
                            "triggeredOrderHash" | "triggered_order_hash" => {
                                Ok(GeneratedField::TriggeredOrderHash)
                            }
                            "placedOrderHash" | "placed_order_hash" => {
                                Ok(GeneratedField::PlacedOrderHash)
                            }
                            "triggeredOrderCid" | "triggered_order_cid" => {
                                Ok(GeneratedField::TriggeredOrderCid)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventConditionalDerivativeOrderTrigger;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventConditionalDerivativeOrderTrigger, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_limit_trigger__ = None;
                let mut triggered_order_hash__ = None;
                let mut placed_order_hash__ = None;
                let mut triggered_order_cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::IsLimitTrigger => {
                            if is_limit_trigger__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLimitTrigger"));
                            }
                            is_limit_trigger__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TriggeredOrderHash => {
                            if triggered_order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "triggeredOrderHash",
                                ));
                            }
                            triggered_order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::PlacedOrderHash => {
                            if placed_order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("placedOrderHash"));
                            }
                            placed_order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::TriggeredOrderCid => {
                            if triggered_order_cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggeredOrderCid"));
                            }
                            triggered_order_cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventConditionalDerivativeOrderTrigger {
                    market_id: market_id__.unwrap_or_default(),
                    is_limit_trigger: is_limit_trigger__.unwrap_or_default(),
                    triggered_order_hash: triggered_order_hash__.unwrap_or_default(),
                    placed_order_hash: placed_order_hash__.unwrap_or_default(),
                    triggered_order_cid: triggered_order_cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventDerivativeMarketPaused {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.settle_price.is_empty() {
            len += 1;
        }
        if !self.total_missing_funds.is_empty() {
            len += 1;
        }
        if !self.missing_funds_rate.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventDerivativeMarketPaused",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.settle_price.is_empty() {
            struct_ser.serialize_field("settlePrice", &self.settle_price)?;
        }
        if !self.total_missing_funds.is_empty() {
            struct_ser.serialize_field("totalMissingFunds", &self.total_missing_funds)?;
        }
        if !self.missing_funds_rate.is_empty() {
            struct_ser.serialize_field("missingFundsRate", &self.missing_funds_rate)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventDerivativeMarketPaused {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "settle_price",
            "settlePrice",
            "total_missing_funds",
            "totalMissingFunds",
            "missing_funds_rate",
            "missingFundsRate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SettlePrice,
            TotalMissingFunds,
            MissingFundsRate,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "settlePrice" | "settle_price" => Ok(GeneratedField::SettlePrice),
                            "totalMissingFunds" | "total_missing_funds" => {
                                Ok(GeneratedField::TotalMissingFunds)
                            }
                            "missingFundsRate" | "missing_funds_rate" => {
                                Ok(GeneratedField::MissingFundsRate)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventDerivativeMarketPaused;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventDerivativeMarketPaused")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventDerivativeMarketPaused, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut settle_price__ = None;
                let mut total_missing_funds__ = None;
                let mut missing_funds_rate__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlePrice => {
                            if settle_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlePrice"));
                            }
                            settle_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TotalMissingFunds => {
                            if total_missing_funds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalMissingFunds"));
                            }
                            total_missing_funds__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingFundsRate => {
                            if missing_funds_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("missingFundsRate"));
                            }
                            missing_funds_rate__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventDerivativeMarketPaused {
                    market_id: market_id__.unwrap_or_default(),
                    settle_price: settle_price__.unwrap_or_default(),
                    total_missing_funds: total_missing_funds__.unwrap_or_default(),
                    missing_funds_rate: missing_funds_rate__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventDerivativeMarketPaused",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventExpiryFuturesMarketUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        if self.expiry_futures_market_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate",
            len,
        )?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        if let Some(v) = self.expiry_futures_market_info.as_ref() {
            struct_ser.serialize_field("expiryFuturesMarketInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventExpiryFuturesMarketUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market",
            "expiry_futures_market_info",
            "expiryFuturesMarketInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
            ExpiryFuturesMarketInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            "expiryFuturesMarketInfo" | "expiry_futures_market_info" => {
                                Ok(GeneratedField::ExpiryFuturesMarketInfo)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventExpiryFuturesMarketUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventExpiryFuturesMarketUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                let mut expiry_futures_market_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                        GeneratedField::ExpiryFuturesMarketInfo => {
                            if expiry_futures_market_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expiryFuturesMarketInfo",
                                ));
                            }
                            expiry_futures_market_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventExpiryFuturesMarketUpdate {
                    market: market__,
                    expiry_futures_market_info: expiry_futures_market_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventFeeDiscountSchedule {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.schedule.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventFeeDiscountSchedule", len)?;
        if let Some(v) = self.schedule.as_ref() {
            struct_ser.serialize_field("schedule", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventFeeDiscountSchedule {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["schedule"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Schedule,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "schedule" => Ok(GeneratedField::Schedule),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventFeeDiscountSchedule;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventFeeDiscountSchedule")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventFeeDiscountSchedule, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut schedule__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Schedule => {
                            if schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field("schedule"));
                            }
                            schedule__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventFeeDiscountSchedule {
                    schedule: schedule__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventFeeDiscountSchedule",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventGrantActivation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.grantee.is_empty() {
            len += 1;
        }
        if !self.granter.is_empty() {
            len += 1;
        }
        if !self.amount.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventGrantActivation", len)?;
        if !self.grantee.is_empty() {
            struct_ser.serialize_field("grantee", &self.grantee)?;
        }
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        if !self.amount.is_empty() {
            struct_ser.serialize_field("amount", &self.amount)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventGrantActivation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["grantee", "granter", "amount"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Grantee,
            Granter,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "grantee" => Ok(GeneratedField::Grantee),
                            "granter" => Ok(GeneratedField::Granter),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventGrantActivation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventGrantActivation")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventGrantActivation, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut grantee__ = None;
                let mut granter__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Grantee => {
                            if grantee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantee"));
                            }
                            grantee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventGrantActivation {
                    grantee: grantee__.unwrap_or_default(),
                    granter: granter__.unwrap_or_default(),
                    amount: amount__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventGrantActivation",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventGrantAuthorizations {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.granter.is_empty() {
            len += 1;
        }
        if !self.grants.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventGrantAuthorizations", len)?;
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        if !self.grants.is_empty() {
            struct_ser.serialize_field("grants", &self.grants)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventGrantAuthorizations {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["granter", "grants"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Granter,
            Grants,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "granter" => Ok(GeneratedField::Granter),
                            "grants" => Ok(GeneratedField::Grants),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventGrantAuthorizations;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventGrantAuthorizations")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventGrantAuthorizations, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut granter__ = None;
                let mut grants__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Grants => {
                            if grants__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grants"));
                            }
                            grants__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventGrantAuthorizations {
                    granter: granter__.unwrap_or_default(),
                    grants: grants__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventGrantAuthorizations",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventInvalidGrant {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.grantee.is_empty() {
            len += 1;
        }
        if !self.granter.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventInvalidGrant", len)?;
        if !self.grantee.is_empty() {
            struct_ser.serialize_field("grantee", &self.grantee)?;
        }
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventInvalidGrant {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["grantee", "granter"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Grantee,
            Granter,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "grantee" => Ok(GeneratedField::Grantee),
                            "granter" => Ok(GeneratedField::Granter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventInvalidGrant;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventInvalidGrant")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EventInvalidGrant, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut grantee__ = None;
                let mut granter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Grantee => {
                            if grantee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantee"));
                            }
                            grantee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventInvalidGrant {
                    grantee: grantee__.unwrap_or_default(),
                    granter: granter__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventInvalidGrant",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventLostFundsFromLiquidation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.lost_funds_from_available_during_payout.is_empty() {
            len += 1;
        }
        if !self.lost_funds_from_order_cancels.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventLostFundsFromLiquidation",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "subaccountId",
                pbjson::private::base64::encode(&self.subaccount_id).as_str(),
            )?;
        }
        if !self.lost_funds_from_available_during_payout.is_empty() {
            struct_ser.serialize_field(
                "lostFundsFromAvailableDuringPayout",
                &self.lost_funds_from_available_during_payout,
            )?;
        }
        if !self.lost_funds_from_order_cancels.is_empty() {
            struct_ser.serialize_field(
                "lostFundsFromOrderCancels",
                &self.lost_funds_from_order_cancels,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventLostFundsFromLiquidation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "lost_funds_from_available_during_payout",
            "lostFundsFromAvailableDuringPayout",
            "lost_funds_from_order_cancels",
            "lostFundsFromOrderCancels",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
            LostFundsFromAvailableDuringPayout,
            LostFundsFromOrderCancels,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "lostFundsFromAvailableDuringPayout"
                            | "lost_funds_from_available_during_payout" => {
                                Ok(GeneratedField::LostFundsFromAvailableDuringPayout)
                            }
                            "lostFundsFromOrderCancels" | "lost_funds_from_order_cancels" => {
                                Ok(GeneratedField::LostFundsFromOrderCancels)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventLostFundsFromLiquidation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventLostFundsFromLiquidation")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventLostFundsFromLiquidation, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut lost_funds_from_available_during_payout__ = None;
                let mut lost_funds_from_order_cancels__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::LostFundsFromAvailableDuringPayout => {
                            if lost_funds_from_available_during_payout__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "lostFundsFromAvailableDuringPayout",
                                ));
                            }
                            lost_funds_from_available_during_payout__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LostFundsFromOrderCancels => {
                            if lost_funds_from_order_cancels__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "lostFundsFromOrderCancels",
                                ));
                            }
                            lost_funds_from_order_cancels__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventLostFundsFromLiquidation {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    lost_funds_from_available_during_payout:
                        lost_funds_from_available_during_payout__.unwrap_or_default(),
                    lost_funds_from_order_cancels: lost_funds_from_order_cancels__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventLostFundsFromLiquidation",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventMarketBeyondBankruptcy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.settle_price.is_empty() {
            len += 1;
        }
        if !self.missing_market_funds.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventMarketBeyondBankruptcy",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.settle_price.is_empty() {
            struct_ser.serialize_field("settlePrice", &self.settle_price)?;
        }
        if !self.missing_market_funds.is_empty() {
            struct_ser.serialize_field("missingMarketFunds", &self.missing_market_funds)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventMarketBeyondBankruptcy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "settle_price",
            "settlePrice",
            "missing_market_funds",
            "missingMarketFunds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SettlePrice,
            MissingMarketFunds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "settlePrice" | "settle_price" => Ok(GeneratedField::SettlePrice),
                            "missingMarketFunds" | "missing_market_funds" => {
                                Ok(GeneratedField::MissingMarketFunds)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventMarketBeyondBankruptcy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventMarketBeyondBankruptcy")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventMarketBeyondBankruptcy, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut settle_price__ = None;
                let mut missing_market_funds__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlePrice => {
                            if settle_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlePrice"));
                            }
                            settle_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MissingMarketFunds => {
                            if missing_market_funds__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "missingMarketFunds",
                                ));
                            }
                            missing_market_funds__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventMarketBeyondBankruptcy {
                    market_id: market_id__.unwrap_or_default(),
                    settle_price: settle_price__.unwrap_or_default(),
                    missing_market_funds: missing_market_funds__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventMarketBeyondBankruptcy",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventNewConditionalDerivativeOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        if !self.hash.is_empty() {
            len += 1;
        }
        if self.is_market {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventNewConditionalDerivativeOrder",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        if !self.hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser
                .serialize_field("hash", pbjson::private::base64::encode(&self.hash).as_str())?;
        }
        if self.is_market {
            struct_ser.serialize_field("isMarket", &self.is_market)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventNewConditionalDerivativeOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "order",
            "hash",
            "is_market",
            "isMarket",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Order,
            Hash,
            IsMarket,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "order" => Ok(GeneratedField::Order),
                            "hash" => Ok(GeneratedField::Hash),
                            "isMarket" | "is_market" => Ok(GeneratedField::IsMarket),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventNewConditionalDerivativeOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.EventNewConditionalDerivativeOrder",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventNewConditionalDerivativeOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut order__ = None;
                let mut hash__ = None;
                let mut is_market__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                        GeneratedField::Hash => {
                            if hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hash"));
                            }
                            hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::IsMarket => {
                            if is_market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isMarket"));
                            }
                            is_market__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventNewConditionalDerivativeOrder {
                    market_id: market_id__.unwrap_or_default(),
                    order: order__,
                    hash: hash__.unwrap_or_default(),
                    is_market: is_market__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventNewConditionalDerivativeOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventNewDerivativeOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.buy_orders.is_empty() {
            len += 1;
        }
        if !self.sell_orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventNewDerivativeOrders", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.buy_orders.is_empty() {
            struct_ser.serialize_field("buyOrders", &self.buy_orders)?;
        }
        if !self.sell_orders.is_empty() {
            struct_ser.serialize_field("sellOrders", &self.sell_orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventNewDerivativeOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "buy_orders",
            "buyOrders",
            "sell_orders",
            "sellOrders",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            BuyOrders,
            SellOrders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "buyOrders" | "buy_orders" => Ok(GeneratedField::BuyOrders),
                            "sellOrders" | "sell_orders" => Ok(GeneratedField::SellOrders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventNewDerivativeOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventNewDerivativeOrders")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventNewDerivativeOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut buy_orders__ = None;
                let mut sell_orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BuyOrders => {
                            if buy_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("buyOrders"));
                            }
                            buy_orders__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SellOrders => {
                            if sell_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sellOrders"));
                            }
                            sell_orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventNewDerivativeOrders {
                    market_id: market_id__.unwrap_or_default(),
                    buy_orders: buy_orders__.unwrap_or_default(),
                    sell_orders: sell_orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventNewDerivativeOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventNewSpotOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.buy_orders.is_empty() {
            len += 1;
        }
        if !self.sell_orders.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventNewSpotOrders", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.buy_orders.is_empty() {
            struct_ser.serialize_field("buyOrders", &self.buy_orders)?;
        }
        if !self.sell_orders.is_empty() {
            struct_ser.serialize_field("sellOrders", &self.sell_orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventNewSpotOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "buy_orders",
            "buyOrders",
            "sell_orders",
            "sellOrders",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            BuyOrders,
            SellOrders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "buyOrders" | "buy_orders" => Ok(GeneratedField::BuyOrders),
                            "sellOrders" | "sell_orders" => Ok(GeneratedField::SellOrders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventNewSpotOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventNewSpotOrders")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EventNewSpotOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut buy_orders__ = None;
                let mut sell_orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BuyOrders => {
                            if buy_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("buyOrders"));
                            }
                            buy_orders__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SellOrders => {
                            if sell_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sellOrders"));
                            }
                            sell_orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventNewSpotOrders {
                    market_id: market_id__.unwrap_or_default(),
                    buy_orders: buy_orders__.unwrap_or_default(),
                    sell_orders: sell_orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventNewSpotOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventOrderCancelFail {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventOrderCancelFail", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventOrderCancelFail {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "order_hash",
            "orderHash",
            "cid",
            "description",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
            OrderHash,
            Cid,
            Description,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            "description" => Ok(GeneratedField::Description),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventOrderCancelFail;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventOrderCancelFail")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventOrderCancelFail, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut order_hash__ = None;
                let mut cid__ = None;
                let mut description__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventOrderCancelFail {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventOrderCancelFail",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventOrderFail {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        if !self.hashes.is_empty() {
            len += 1;
        }
        if !self.flags.is_empty() {
            len += 1;
        }
        if !self.cids.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventOrderFail", len)?;
        if !self.account.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "account",
                pbjson::private::base64::encode(&self.account).as_str(),
            )?;
        }
        if !self.hashes.is_empty() {
            struct_ser.serialize_field(
                "hashes",
                &self
                    .hashes
                    .iter()
                    .map(pbjson::private::base64::encode)
                    .collect::<Vec<_>>(),
            )?;
        }
        if !self.flags.is_empty() {
            struct_ser.serialize_field("flags", &self.flags)?;
        }
        if !self.cids.is_empty() {
            struct_ser.serialize_field("cids", &self.cids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventOrderFail {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account", "hashes", "flags", "cids"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
            Hashes,
            Flags,
            Cids,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            "hashes" => Ok(GeneratedField::Hashes),
                            "flags" => Ok(GeneratedField::Flags),
                            "cids" => Ok(GeneratedField::Cids),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventOrderFail;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventOrderFail")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EventOrderFail, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                let mut hashes__ = None;
                let mut flags__ = None;
                let mut cids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Hashes => {
                            if hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hashes"));
                            }
                            hashes__ = Some(
                                map_.next_value::<Vec<::pbjson::private::BytesDeserialize<_>>>()?
                                    .into_iter()
                                    .map(|x| x.0)
                                    .collect(),
                            );
                        }
                        GeneratedField::Flags => {
                            if flags__.is_some() {
                                return Err(serde::de::Error::duplicate_field("flags"));
                            }
                            flags__ = Some(
                                map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter()
                                    .map(|x| x.0)
                                    .collect(),
                            );
                        }
                        GeneratedField::Cids => {
                            if cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cids"));
                            }
                            cids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventOrderFail {
                    account: account__.unwrap_or_default(),
                    hashes: hashes__.unwrap_or_default(),
                    flags: flags__.unwrap_or_default(),
                    cids: cids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventOrderFail",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventOrderbookUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.spot_updates.is_empty() {
            len += 1;
        }
        if !self.derivative_updates.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventOrderbookUpdate", len)?;
        if !self.spot_updates.is_empty() {
            struct_ser.serialize_field("spotUpdates", &self.spot_updates)?;
        }
        if !self.derivative_updates.is_empty() {
            struct_ser.serialize_field("derivativeUpdates", &self.derivative_updates)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventOrderbookUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "spot_updates",
            "spotUpdates",
            "derivative_updates",
            "derivativeUpdates",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SpotUpdates,
            DerivativeUpdates,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "spotUpdates" | "spot_updates" => Ok(GeneratedField::SpotUpdates),
                            "derivativeUpdates" | "derivative_updates" => {
                                Ok(GeneratedField::DerivativeUpdates)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventOrderbookUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventOrderbookUpdate")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventOrderbookUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut spot_updates__ = None;
                let mut derivative_updates__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SpotUpdates => {
                            if spot_updates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spotUpdates"));
                            }
                            spot_updates__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeUpdates => {
                            if derivative_updates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("derivativeUpdates"));
                            }
                            derivative_updates__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventOrderbookUpdate {
                    spot_updates: spot_updates__.unwrap_or_default(),
                    derivative_updates: derivative_updates__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventOrderbookUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventPerpetualMarketFundingUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.funding.is_some() {
            len += 1;
        }
        if self.is_hourly_funding {
            len += 1;
        }
        if !self.funding_rate.is_empty() {
            len += 1;
        }
        if !self.mark_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.funding.as_ref() {
            struct_ser.serialize_field("funding", v)?;
        }
        if self.is_hourly_funding {
            struct_ser.serialize_field("isHourlyFunding", &self.is_hourly_funding)?;
        }
        if !self.funding_rate.is_empty() {
            struct_ser.serialize_field("fundingRate", &self.funding_rate)?;
        }
        if !self.mark_price.is_empty() {
            struct_ser.serialize_field("markPrice", &self.mark_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventPerpetualMarketFundingUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "funding",
            "is_hourly_funding",
            "isHourlyFunding",
            "funding_rate",
            "fundingRate",
            "mark_price",
            "markPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Funding,
            IsHourlyFunding,
            FundingRate,
            MarkPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "funding" => Ok(GeneratedField::Funding),
                            "isHourlyFunding" | "is_hourly_funding" => {
                                Ok(GeneratedField::IsHourlyFunding)
                            }
                            "fundingRate" | "funding_rate" => Ok(GeneratedField::FundingRate),
                            "markPrice" | "mark_price" => Ok(GeneratedField::MarkPrice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventPerpetualMarketFundingUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventPerpetualMarketFundingUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut funding__ = None;
                let mut is_hourly_funding__ = None;
                let mut funding_rate__ = None;
                let mut mark_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funding => {
                            if funding__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funding"));
                            }
                            funding__ = map_.next_value()?;
                        }
                        GeneratedField::IsHourlyFunding => {
                            if is_hourly_funding__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isHourlyFunding"));
                            }
                            is_hourly_funding__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FundingRate => {
                            if funding_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fundingRate"));
                            }
                            funding_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarkPrice => {
                            if mark_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("markPrice"));
                            }
                            mark_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventPerpetualMarketFundingUpdate {
                    market_id: market_id__.unwrap_or_default(),
                    funding: funding__,
                    is_hourly_funding: is_hourly_funding__.unwrap_or_default(),
                    funding_rate: funding_rate__.unwrap_or_default(),
                    mark_price: mark_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventPerpetualMarketUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        if self.perpetual_market_info.is_some() {
            len += 1;
        }
        if self.funding.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventPerpetualMarketUpdate", len)?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        if let Some(v) = self.perpetual_market_info.as_ref() {
            struct_ser.serialize_field("perpetualMarketInfo", v)?;
        }
        if let Some(v) = self.funding.as_ref() {
            struct_ser.serialize_field("funding", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventPerpetualMarketUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market",
            "perpetual_market_info",
            "perpetualMarketInfo",
            "funding",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
            PerpetualMarketInfo,
            Funding,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            "perpetualMarketInfo" | "perpetual_market_info" => {
                                Ok(GeneratedField::PerpetualMarketInfo)
                            }
                            "funding" => Ok(GeneratedField::Funding),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventPerpetualMarketUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventPerpetualMarketUpdate")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventPerpetualMarketUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                let mut perpetual_market_info__ = None;
                let mut funding__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                        GeneratedField::PerpetualMarketInfo => {
                            if perpetual_market_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "perpetualMarketInfo",
                                ));
                            }
                            perpetual_market_info__ = map_.next_value()?;
                        }
                        GeneratedField::Funding => {
                            if funding__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funding"));
                            }
                            funding__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventPerpetualMarketUpdate {
                    market: market__,
                    perpetual_market_info: perpetual_market_info__,
                    funding: funding__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventPerpetualMarketUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventSpotMarketUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.EventSpotMarketUpdate", len)?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventSpotMarketUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventSpotMarketUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventSpotMarketUpdate")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventSpotMarketUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventSpotMarketUpdate { market: market__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventSpotMarketUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventSubaccountBalanceTransfer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.src_subaccount_id.is_empty() {
            len += 1;
        }
        if !self.dst_subaccount_id.is_empty() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventSubaccountBalanceTransfer",
            len,
        )?;
        if !self.src_subaccount_id.is_empty() {
            struct_ser.serialize_field("srcSubaccountId", &self.src_subaccount_id)?;
        }
        if !self.dst_subaccount_id.is_empty() {
            struct_ser.serialize_field("dstSubaccountId", &self.dst_subaccount_id)?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventSubaccountBalanceTransfer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "src_subaccount_id",
            "srcSubaccountId",
            "dst_subaccount_id",
            "dstSubaccountId",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SrcSubaccountId,
            DstSubaccountId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "srcSubaccountId" | "src_subaccount_id" => {
                                Ok(GeneratedField::SrcSubaccountId)
                            }
                            "dstSubaccountId" | "dst_subaccount_id" => {
                                Ok(GeneratedField::DstSubaccountId)
                            }
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventSubaccountBalanceTransfer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventSubaccountBalanceTransfer")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventSubaccountBalanceTransfer, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut src_subaccount_id__ = None;
                let mut dst_subaccount_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SrcSubaccountId => {
                            if src_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("srcSubaccountId"));
                            }
                            src_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DstSubaccountId => {
                            if dst_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dstSubaccountId"));
                            }
                            dst_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventSubaccountBalanceTransfer {
                    src_subaccount_id: src_subaccount_id__.unwrap_or_default(),
                    dst_subaccount_id: dst_subaccount_id__.unwrap_or_default(),
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventSubaccountBalanceTransfer",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventSubaccountDeposit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.src_address.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventSubaccountDeposit", len)?;
        if !self.src_address.is_empty() {
            struct_ser.serialize_field("srcAddress", &self.src_address)?;
        }
        if !self.subaccount_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "subaccountId",
                pbjson::private::base64::encode(&self.subaccount_id).as_str(),
            )?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventSubaccountDeposit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "src_address",
            "srcAddress",
            "subaccount_id",
            "subaccountId",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SrcAddress,
            SubaccountId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "srcAddress" | "src_address" => Ok(GeneratedField::SrcAddress),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventSubaccountDeposit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventSubaccountDeposit")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventSubaccountDeposit, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut src_address__ = None;
                let mut subaccount_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SrcAddress => {
                            if src_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("srcAddress"));
                            }
                            src_address__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventSubaccountDeposit {
                    src_address: src_address__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventSubaccountDeposit",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventSubaccountWithdraw {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.dst_address.is_empty() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.EventSubaccountWithdraw", len)?;
        if !self.subaccount_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "subaccountId",
                pbjson::private::base64::encode(&self.subaccount_id).as_str(),
            )?;
        }
        if !self.dst_address.is_empty() {
            struct_ser.serialize_field("dstAddress", &self.dst_address)?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventSubaccountWithdraw {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccount_id",
            "subaccountId",
            "dst_address",
            "dstAddress",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            DstAddress,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "dstAddress" | "dst_address" => Ok(GeneratedField::DstAddress),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventSubaccountWithdraw;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.EventSubaccountWithdraw")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventSubaccountWithdraw, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut dst_address__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::DstAddress => {
                            if dst_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dstAddress"));
                            }
                            dst_address__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EventSubaccountWithdraw {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    dst_address: dst_address__.unwrap_or_default(),
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventSubaccountWithdraw",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventTradingRewardCampaignUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.campaign_info.is_some() {
            len += 1;
        }
        if !self.campaign_reward_pools.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventTradingRewardCampaignUpdate",
            len,
        )?;
        if let Some(v) = self.campaign_info.as_ref() {
            struct_ser.serialize_field("campaignInfo", v)?;
        }
        if !self.campaign_reward_pools.is_empty() {
            struct_ser.serialize_field("campaignRewardPools", &self.campaign_reward_pools)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventTradingRewardCampaignUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "campaign_info",
            "campaignInfo",
            "campaign_reward_pools",
            "campaignRewardPools",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CampaignInfo,
            CampaignRewardPools,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "campaignInfo" | "campaign_info" => Ok(GeneratedField::CampaignInfo),
                            "campaignRewardPools" | "campaign_reward_pools" => {
                                Ok(GeneratedField::CampaignRewardPools)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventTradingRewardCampaignUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventTradingRewardCampaignUpdate")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventTradingRewardCampaignUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut campaign_info__ = None;
                let mut campaign_reward_pools__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CampaignInfo => {
                            if campaign_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("campaignInfo"));
                            }
                            campaign_info__ = map_.next_value()?;
                        }
                        GeneratedField::CampaignRewardPools => {
                            if campaign_reward_pools__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "campaignRewardPools",
                                ));
                            }
                            campaign_reward_pools__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventTradingRewardCampaignUpdate {
                    campaign_info: campaign_info__,
                    campaign_reward_pools: campaign_reward_pools__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventTradingRewardCampaignUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for EventTradingRewardDistribution {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account_rewards.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.EventTradingRewardDistribution",
            len,
        )?;
        if !self.account_rewards.is_empty() {
            struct_ser.serialize_field("accountRewards", &self.account_rewards)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for EventTradingRewardDistribution {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account_rewards", "accountRewards"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AccountRewards,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accountRewards" | "account_rewards" => {
                                Ok(GeneratedField::AccountRewards)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventTradingRewardDistribution;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.EventTradingRewardDistribution")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<EventTradingRewardDistribution, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account_rewards__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AccountRewards => {
                            if account_rewards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountRewards"));
                            }
                            account_rewards__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventTradingRewardDistribution {
                    account_rewards: account_rewards__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.EventTradingRewardDistribution",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ExchangeEnableProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if self.exchange_type != 0 {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.ExchangeEnableProposal", len)?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if self.exchange_type != 0 {
            let v = ExchangeType::try_from(self.exchange_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.exchange_type))
            })?;
            struct_ser.serialize_field("exchangeType", &v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ExchangeEnableProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["title", "description", "exchangeType"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            ExchangeType,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "exchangeType" => Ok(GeneratedField::ExchangeType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExchangeEnableProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.ExchangeEnableProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<ExchangeEnableProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut exchange_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExchangeType => {
                            if exchange_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exchangeType"));
                            }
                            exchange_type__ = Some(map_.next_value::<ExchangeType>()? as i32);
                        }
                    }
                }
                Ok(ExchangeEnableProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    exchange_type: exchange_type__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.ExchangeEnableProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ExchangeType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ExchangeUnspecified => "EXCHANGE_UNSPECIFIED",
            Self::Spot => "SPOT",
            Self::Derivatives => "DERIVATIVES",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ExchangeType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["EXCHANGE_UNSPECIFIED", "SPOT", "DERIVATIVES"];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExchangeType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EXCHANGE_UNSPECIFIED" => Ok(ExchangeType::ExchangeUnspecified),
                    "SPOT" => Ok(ExchangeType::Spot),
                    "DERIVATIVES" => Ok(ExchangeType::Derivatives),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ExecutionType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::UnspecifiedExecutionType => "UnspecifiedExecutionType",
            Self::Market => "Market",
            Self::LimitFill => "LimitFill",
            Self::LimitMatchRestingOrder => "LimitMatchRestingOrder",
            Self::LimitMatchNewOrder => "LimitMatchNewOrder",
            Self::MarketLiquidation => "MarketLiquidation",
            Self::ExpiryMarketSettlement => "ExpiryMarketSettlement",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ExecutionType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnspecifiedExecutionType",
            "Market",
            "LimitFill",
            "LimitMatchRestingOrder",
            "LimitMatchNewOrder",
            "MarketLiquidation",
            "ExpiryMarketSettlement",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecutionType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UnspecifiedExecutionType" => Ok(ExecutionType::UnspecifiedExecutionType),
                    "Market" => Ok(ExecutionType::Market),
                    "LimitFill" => Ok(ExecutionType::LimitFill),
                    "LimitMatchRestingOrder" => Ok(ExecutionType::LimitMatchRestingOrder),
                    "LimitMatchNewOrder" => Ok(ExecutionType::LimitMatchNewOrder),
                    "MarketLiquidation" => Ok(ExecutionType::MarketLiquidation),
                    "ExpiryMarketSettlement" => Ok(ExecutionType::ExpiryMarketSettlement),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ExpiryFuturesMarketInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.expiration_timestamp != 0 {
            len += 1;
        }
        if self.twap_start_timestamp != 0 {
            len += 1;
        }
        if !self.expiration_twap_start_price_cumulative.is_empty() {
            len += 1;
        }
        if !self.settlement_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.ExpiryFuturesMarketInfo", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.expiration_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "expirationTimestamp",
                ToString::to_string(&self.expiration_timestamp).as_str(),
            )?;
        }
        if self.twap_start_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "twapStartTimestamp",
                ToString::to_string(&self.twap_start_timestamp).as_str(),
            )?;
        }
        if !self.expiration_twap_start_price_cumulative.is_empty() {
            struct_ser.serialize_field(
                "expirationTwapStartPriceCumulative",
                &self.expiration_twap_start_price_cumulative,
            )?;
        }
        if !self.settlement_price.is_empty() {
            struct_ser.serialize_field("settlementPrice", &self.settlement_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ExpiryFuturesMarketInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "expiration_timestamp",
            "expirationTimestamp",
            "twap_start_timestamp",
            "twapStartTimestamp",
            "expiration_twap_start_price_cumulative",
            "expirationTwapStartPriceCumulative",
            "settlement_price",
            "settlementPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            ExpirationTimestamp,
            TwapStartTimestamp,
            ExpirationTwapStartPriceCumulative,
            SettlementPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "expirationTimestamp" | "expiration_timestamp" => {
                                Ok(GeneratedField::ExpirationTimestamp)
                            }
                            "twapStartTimestamp" | "twap_start_timestamp" => {
                                Ok(GeneratedField::TwapStartTimestamp)
                            }
                            "expirationTwapStartPriceCumulative"
                            | "expiration_twap_start_price_cumulative" => {
                                Ok(GeneratedField::ExpirationTwapStartPriceCumulative)
                            }
                            "settlementPrice" | "settlement_price" => {
                                Ok(GeneratedField::SettlementPrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExpiryFuturesMarketInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.ExpiryFuturesMarketInfo")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<ExpiryFuturesMarketInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut expiration_timestamp__ = None;
                let mut twap_start_timestamp__ = None;
                let mut expiration_twap_start_price_cumulative__ = None;
                let mut settlement_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpirationTimestamp => {
                            if expiration_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expirationTimestamp",
                                ));
                            }
                            expiration_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::TwapStartTimestamp => {
                            if twap_start_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "twapStartTimestamp",
                                ));
                            }
                            twap_start_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::ExpirationTwapStartPriceCumulative => {
                            if expiration_twap_start_price_cumulative__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expirationTwapStartPriceCumulative",
                                ));
                            }
                            expiration_twap_start_price_cumulative__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlementPrice => {
                            if settlement_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlementPrice"));
                            }
                            settlement_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ExpiryFuturesMarketInfo {
                    market_id: market_id__.unwrap_or_default(),
                    expiration_timestamp: expiration_timestamp__.unwrap_or_default(),
                    twap_start_timestamp: twap_start_timestamp__.unwrap_or_default(),
                    expiration_twap_start_price_cumulative:
                        expiration_twap_start_price_cumulative__.unwrap_or_default(),
                    settlement_price: settlement_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.ExpiryFuturesMarketInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ExpiryFuturesMarketInfoState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.market_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.ExpiryFuturesMarketInfoState",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.market_info.as_ref() {
            struct_ser.serialize_field("marketInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ExpiryFuturesMarketInfoState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "market_info", "marketInfo"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            MarketInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "marketInfo" | "market_info" => Ok(GeneratedField::MarketInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExpiryFuturesMarketInfoState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.ExpiryFuturesMarketInfoState")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<ExpiryFuturesMarketInfoState, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut market_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketInfo => {
                            if market_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketInfo"));
                            }
                            market_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ExpiryFuturesMarketInfoState {
                    market_id: market_id__.unwrap_or_default(),
                    market_info: market_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.ExpiryFuturesMarketInfoState",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ExpiryFuturesMarketLaunchProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.oracle_base.is_empty() {
            len += 1;
        }
        if !self.oracle_quote.is_empty() {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if self.expiry != 0 {
            len += 1;
        }
        if !self.initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if self.admin_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            struct_ser.serialize_field("oracleBase", &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            struct_ser.serialize_field("oracleQuote", &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if self.expiry != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("expiry", ToString::to_string(&self.expiry).as_str())?;
        }
        if !self.initial_margin_ratio.is_empty() {
            struct_ser.serialize_field("initialMarginRatio", &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field("maintenanceMarginRatio", &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if let Some(v) = self.admin_info.as_ref() {
            struct_ser.serialize_field("adminInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ExpiryFuturesMarketLaunchProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "ticker",
            "quote_denom",
            "quoteDenom",
            "oracle_base",
            "oracleBase",
            "oracle_quote",
            "oracleQuote",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "oracle_type",
            "oracleType",
            "expiry",
            "initial_margin_ratio",
            "initialMarginRatio",
            "maintenance_margin_ratio",
            "maintenanceMarginRatio",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
            "admin_info",
            "adminInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            Ticker,
            QuoteDenom,
            OracleBase,
            OracleQuote,
            OracleScaleFactor,
            OracleType,
            Expiry,
            InitialMarginRatio,
            MaintenanceMarginRatio,
            MakerFeeRate,
            TakerFeeRate,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
            AdminInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "oracleBase" | "oracle_base" => Ok(GeneratedField::OracleBase),
                            "oracleQuote" | "oracle_quote" => Ok(GeneratedField::OracleQuote),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "expiry" => Ok(GeneratedField::Expiry),
                            "initialMarginRatio" | "initial_margin_ratio" => {
                                Ok(GeneratedField::InitialMarginRatio)
                            }
                            "maintenanceMarginRatio" | "maintenance_margin_ratio" => {
                                Ok(GeneratedField::MaintenanceMarginRatio)
                            }
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "adminInfo" | "admin_info" => Ok(GeneratedField::AdminInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExpiryFuturesMarketLaunchProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<ExpiryFuturesMarketLaunchProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut ticker__ = None;
                let mut quote_denom__ = None;
                let mut oracle_base__ = None;
                let mut oracle_quote__ = None;
                let mut oracle_scale_factor__ = None;
                let mut oracle_type__ = None;
                let mut expiry__ = None;
                let mut initial_margin_ratio__ = None;
                let mut maintenance_margin_ratio__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                let mut admin_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleBase => {
                            if oracle_base__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleBase"));
                            }
                            oracle_base__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleQuote => {
                            if oracle_quote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleQuote"));
                            }
                            oracle_quote__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::Expiry => {
                            if expiry__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expiry"));
                            }
                            expiry__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::InitialMarginRatio => {
                            if initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "initialMarginRatio",
                                ));
                            }
                            initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaintenanceMarginRatio => {
                            if maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maintenanceMarginRatio",
                                ));
                            }
                            maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminInfo => {
                            if admin_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminInfo"));
                            }
                            admin_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ExpiryFuturesMarketLaunchProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    oracle_base: oracle_base__.unwrap_or_default(),
                    oracle_quote: oracle_quote__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    expiry: expiry__.unwrap_or_default(),
                    initial_margin_ratio: initial_margin_ratio__.unwrap_or_default(),
                    maintenance_margin_ratio: maintenance_margin_ratio__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin_info: admin_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FeeDiscountAccountTierTtl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        if self.tier_ttl.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.FeeDiscountAccountTierTTL", len)?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        if let Some(v) = self.tier_ttl.as_ref() {
            struct_ser.serialize_field("tierTtl", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FeeDiscountAccountTierTtl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account", "tier_ttl", "tierTtl"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
            TierTtl,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            "tierTtl" | "tier_ttl" => Ok(GeneratedField::TierTtl),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FeeDiscountAccountTierTtl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FeeDiscountAccountTierTTL")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<FeeDiscountAccountTierTtl, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                let mut tier_ttl__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TierTtl => {
                            if tier_ttl__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tierTtl"));
                            }
                            tier_ttl__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FeeDiscountAccountTierTtl {
                    account: account__.unwrap_or_default(),
                    tier_ttl: tier_ttl__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FeeDiscountAccountTierTTL",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FeeDiscountBucketVolumeAccounts {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bucket_start_timestamp != 0 {
            len += 1;
        }
        if !self.account_volume.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts",
            len,
        )?;
        if self.bucket_start_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "bucketStartTimestamp",
                ToString::to_string(&self.bucket_start_timestamp).as_str(),
            )?;
        }
        if !self.account_volume.is_empty() {
            struct_ser.serialize_field("accountVolume", &self.account_volume)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FeeDiscountBucketVolumeAccounts {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bucket_start_timestamp",
            "bucketStartTimestamp",
            "account_volume",
            "accountVolume",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BucketStartTimestamp,
            AccountVolume,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bucketStartTimestamp" | "bucket_start_timestamp" => {
                                Ok(GeneratedField::BucketStartTimestamp)
                            }
                            "accountVolume" | "account_volume" => Ok(GeneratedField::AccountVolume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FeeDiscountBucketVolumeAccounts;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<FeeDiscountBucketVolumeAccounts, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut bucket_start_timestamp__ = None;
                let mut account_volume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BucketStartTimestamp => {
                            if bucket_start_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "bucketStartTimestamp",
                                ));
                            }
                            bucket_start_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::AccountVolume => {
                            if account_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountVolume"));
                            }
                            account_volume__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FeeDiscountBucketVolumeAccounts {
                    bucket_start_timestamp: bucket_start_timestamp__.unwrap_or_default(),
                    account_volume: account_volume__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FeeDiscountProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if self.schedule.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.FeeDiscountProposal", len)?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if let Some(v) = self.schedule.as_ref() {
            struct_ser.serialize_field("schedule", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FeeDiscountProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["title", "description", "schedule"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            Schedule,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "schedule" => Ok(GeneratedField::Schedule),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FeeDiscountProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FeeDiscountProposal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FeeDiscountProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut schedule__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Schedule => {
                            if schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field("schedule"));
                            }
                            schedule__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FeeDiscountProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    schedule: schedule__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FeeDiscountProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FeeDiscountSchedule {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bucket_count != 0 {
            len += 1;
        }
        if self.bucket_duration != 0 {
            len += 1;
        }
        if !self.quote_denoms.is_empty() {
            len += 1;
        }
        if !self.tier_infos.is_empty() {
            len += 1;
        }
        if !self.disqualified_market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.FeeDiscountSchedule", len)?;
        if self.bucket_count != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "bucketCount",
                ToString::to_string(&self.bucket_count).as_str(),
            )?;
        }
        if self.bucket_duration != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "bucketDuration",
                ToString::to_string(&self.bucket_duration).as_str(),
            )?;
        }
        if !self.quote_denoms.is_empty() {
            struct_ser.serialize_field("quoteDenoms", &self.quote_denoms)?;
        }
        if !self.tier_infos.is_empty() {
            struct_ser.serialize_field("tierInfos", &self.tier_infos)?;
        }
        if !self.disqualified_market_ids.is_empty() {
            struct_ser.serialize_field("disqualifiedMarketIds", &self.disqualified_market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FeeDiscountSchedule {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bucket_count",
            "bucketCount",
            "bucket_duration",
            "bucketDuration",
            "quote_denoms",
            "quoteDenoms",
            "tier_infos",
            "tierInfos",
            "disqualified_market_ids",
            "disqualifiedMarketIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BucketCount,
            BucketDuration,
            QuoteDenoms,
            TierInfos,
            DisqualifiedMarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bucketCount" | "bucket_count" => Ok(GeneratedField::BucketCount),
                            "bucketDuration" | "bucket_duration" => {
                                Ok(GeneratedField::BucketDuration)
                            }
                            "quoteDenoms" | "quote_denoms" => Ok(GeneratedField::QuoteDenoms),
                            "tierInfos" | "tier_infos" => Ok(GeneratedField::TierInfos),
                            "disqualifiedMarketIds" | "disqualified_market_ids" => {
                                Ok(GeneratedField::DisqualifiedMarketIds)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FeeDiscountSchedule;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FeeDiscountSchedule")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FeeDiscountSchedule, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut bucket_count__ = None;
                let mut bucket_duration__ = None;
                let mut quote_denoms__ = None;
                let mut tier_infos__ = None;
                let mut disqualified_market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BucketCount => {
                            if bucket_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bucketCount"));
                            }
                            bucket_count__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::BucketDuration => {
                            if bucket_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bucketDuration"));
                            }
                            bucket_duration__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::QuoteDenoms => {
                            if quote_denoms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenoms"));
                            }
                            quote_denoms__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TierInfos => {
                            if tier_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tierInfos"));
                            }
                            tier_infos__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DisqualifiedMarketIds => {
                            if disqualified_market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "disqualifiedMarketIds",
                                ));
                            }
                            disqualified_market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FeeDiscountSchedule {
                    bucket_count: bucket_count__.unwrap_or_default(),
                    bucket_duration: bucket_duration__.unwrap_or_default(),
                    quote_denoms: quote_denoms__.unwrap_or_default(),
                    tier_infos: tier_infos__.unwrap_or_default(),
                    disqualified_market_ids: disqualified_market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FeeDiscountSchedule",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FeeDiscountTierInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.maker_discount_rate.is_empty() {
            len += 1;
        }
        if !self.taker_discount_rate.is_empty() {
            len += 1;
        }
        if !self.staked_amount.is_empty() {
            len += 1;
        }
        if !self.volume.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.FeeDiscountTierInfo", len)?;
        if !self.maker_discount_rate.is_empty() {
            struct_ser.serialize_field("makerDiscountRate", &self.maker_discount_rate)?;
        }
        if !self.taker_discount_rate.is_empty() {
            struct_ser.serialize_field("takerDiscountRate", &self.taker_discount_rate)?;
        }
        if !self.staked_amount.is_empty() {
            struct_ser.serialize_field("stakedAmount", &self.staked_amount)?;
        }
        if !self.volume.is_empty() {
            struct_ser.serialize_field("volume", &self.volume)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FeeDiscountTierInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "maker_discount_rate",
            "makerDiscountRate",
            "taker_discount_rate",
            "takerDiscountRate",
            "staked_amount",
            "stakedAmount",
            "volume",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MakerDiscountRate,
            TakerDiscountRate,
            StakedAmount,
            Volume,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "makerDiscountRate" | "maker_discount_rate" => {
                                Ok(GeneratedField::MakerDiscountRate)
                            }
                            "takerDiscountRate" | "taker_discount_rate" => {
                                Ok(GeneratedField::TakerDiscountRate)
                            }
                            "stakedAmount" | "staked_amount" => Ok(GeneratedField::StakedAmount),
                            "volume" => Ok(GeneratedField::Volume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FeeDiscountTierInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FeeDiscountTierInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FeeDiscountTierInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut maker_discount_rate__ = None;
                let mut taker_discount_rate__ = None;
                let mut staked_amount__ = None;
                let mut volume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MakerDiscountRate => {
                            if maker_discount_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerDiscountRate"));
                            }
                            maker_discount_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerDiscountRate => {
                            if taker_discount_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerDiscountRate"));
                            }
                            taker_discount_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StakedAmount => {
                            if staked_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stakedAmount"));
                            }
                            staked_amount__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FeeDiscountTierInfo {
                    maker_discount_rate: maker_discount_rate__.unwrap_or_default(),
                    taker_discount_rate: taker_discount_rate__.unwrap_or_default(),
                    staked_amount: staked_amount__.unwrap_or_default(),
                    volume: volume__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FeeDiscountTierInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FeeDiscountTierTtl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tier != 0 {
            len += 1;
        }
        if self.ttl_timestamp != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.FeeDiscountTierTTL", len)?;
        if self.tier != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("tier", ToString::to_string(&self.tier).as_str())?;
        }
        if self.ttl_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "ttlTimestamp",
                ToString::to_string(&self.ttl_timestamp).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FeeDiscountTierTtl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["tier", "ttl_timestamp", "ttlTimestamp"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Tier,
            TtlTimestamp,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tier" => Ok(GeneratedField::Tier),
                            "ttlTimestamp" | "ttl_timestamp" => Ok(GeneratedField::TtlTimestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FeeDiscountTierTtl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FeeDiscountTierTTL")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FeeDiscountTierTtl, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut tier__ = None;
                let mut ttl_timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Tier => {
                            if tier__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tier"));
                            }
                            tier__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::TtlTimestamp => {
                            if ttl_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ttlTimestamp"));
                            }
                            ttl_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(FeeDiscountTierTtl {
                    tier: tier__.unwrap_or_default(),
                    ttl_timestamp: ttl_timestamp__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FeeDiscountTierTTL",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FullActiveGrant {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.grantee.is_empty() {
            len += 1;
        }
        if self.active_grant.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.FullActiveGrant", len)?;
        if !self.grantee.is_empty() {
            struct_ser.serialize_field("grantee", &self.grantee)?;
        }
        if let Some(v) = self.active_grant.as_ref() {
            struct_ser.serialize_field("activeGrant", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FullActiveGrant {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["grantee", "active_grant", "activeGrant"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Grantee,
            ActiveGrant,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "grantee" => Ok(GeneratedField::Grantee),
                            "activeGrant" | "active_grant" => Ok(GeneratedField::ActiveGrant),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FullActiveGrant;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FullActiveGrant")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FullActiveGrant, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut grantee__ = None;
                let mut active_grant__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Grantee => {
                            if grantee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantee"));
                            }
                            grantee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ActiveGrant => {
                            if active_grant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("activeGrant"));
                            }
                            active_grant__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FullActiveGrant {
                    grantee: grantee__.unwrap_or_default(),
                    active_grant: active_grant__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FullActiveGrant",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FullDerivativeMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        if !self.mark_price.is_empty() {
            len += 1;
        }
        if self.mid_price_and_tob.is_some() {
            len += 1;
        }
        if self.info.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.FullDerivativeMarket", len)?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        if !self.mark_price.is_empty() {
            struct_ser.serialize_field("markPrice", &self.mark_price)?;
        }
        if let Some(v) = self.mid_price_and_tob.as_ref() {
            struct_ser.serialize_field("midPriceAndTob", v)?;
        }
        if let Some(v) = self.info.as_ref() {
            match v {
                full_derivative_market::Info::PerpetualInfo(v) => {
                    struct_ser.serialize_field("perpetualInfo", v)?;
                }
                full_derivative_market::Info::FuturesInfo(v) => {
                    struct_ser.serialize_field("futuresInfo", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FullDerivativeMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market",
            "mark_price",
            "markPrice",
            "mid_price_and_tob",
            "midPriceAndTob",
            "perpetual_info",
            "perpetualInfo",
            "futures_info",
            "futuresInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
            MarkPrice,
            MidPriceAndTob,
            PerpetualInfo,
            FuturesInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            "markPrice" | "mark_price" => Ok(GeneratedField::MarkPrice),
                            "midPriceAndTob" | "mid_price_and_tob" => {
                                Ok(GeneratedField::MidPriceAndTob)
                            }
                            "perpetualInfo" | "perpetual_info" => Ok(GeneratedField::PerpetualInfo),
                            "futuresInfo" | "futures_info" => Ok(GeneratedField::FuturesInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FullDerivativeMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FullDerivativeMarket")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<FullDerivativeMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                let mut mark_price__ = None;
                let mut mid_price_and_tob__ = None;
                let mut info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                        GeneratedField::MarkPrice => {
                            if mark_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("markPrice"));
                            }
                            mark_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MidPriceAndTob => {
                            if mid_price_and_tob__.is_some() {
                                return Err(serde::de::Error::duplicate_field("midPriceAndTob"));
                            }
                            mid_price_and_tob__ = map_.next_value()?;
                        }
                        GeneratedField::PerpetualInfo => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("perpetualInfo"));
                            }
                            info__ = map_
                                .next_value::<::std::option::Option<_>>()?
                                .map(full_derivative_market::Info::PerpetualInfo);
                        }
                        GeneratedField::FuturesInfo => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("futuresInfo"));
                            }
                            info__ = map_
                                .next_value::<::std::option::Option<_>>()?
                                .map(full_derivative_market::Info::FuturesInfo);
                        }
                    }
                }
                Ok(FullDerivativeMarket {
                    market: market__,
                    mark_price: mark_price__.unwrap_or_default(),
                    mid_price_and_tob: mid_price_and_tob__,
                    info: info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FullDerivativeMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FullGrantAuthorizations {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.granter.is_empty() {
            len += 1;
        }
        if !self.total_grant_amount.is_empty() {
            len += 1;
        }
        if self.last_delegations_checked_time != 0 {
            len += 1;
        }
        if !self.grants.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.FullGrantAuthorizations", len)?;
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        if !self.total_grant_amount.is_empty() {
            struct_ser.serialize_field("totalGrantAmount", &self.total_grant_amount)?;
        }
        if self.last_delegations_checked_time != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "lastDelegationsCheckedTime",
                ToString::to_string(&self.last_delegations_checked_time).as_str(),
            )?;
        }
        if !self.grants.is_empty() {
            struct_ser.serialize_field("grants", &self.grants)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FullGrantAuthorizations {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "granter",
            "total_grant_amount",
            "totalGrantAmount",
            "last_delegations_checked_time",
            "lastDelegationsCheckedTime",
            "grants",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Granter,
            TotalGrantAmount,
            LastDelegationsCheckedTime,
            Grants,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "granter" => Ok(GeneratedField::Granter),
                            "totalGrantAmount" | "total_grant_amount" => {
                                Ok(GeneratedField::TotalGrantAmount)
                            }
                            "lastDelegationsCheckedTime" | "last_delegations_checked_time" => {
                                Ok(GeneratedField::LastDelegationsCheckedTime)
                            }
                            "grants" => Ok(GeneratedField::Grants),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FullGrantAuthorizations;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FullGrantAuthorizations")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<FullGrantAuthorizations, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut granter__ = None;
                let mut total_grant_amount__ = None;
                let mut last_delegations_checked_time__ = None;
                let mut grants__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TotalGrantAmount => {
                            if total_grant_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalGrantAmount"));
                            }
                            total_grant_amount__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LastDelegationsCheckedTime => {
                            if last_delegations_checked_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "lastDelegationsCheckedTime",
                                ));
                            }
                            last_delegations_checked_time__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Grants => {
                            if grants__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grants"));
                            }
                            grants__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FullGrantAuthorizations {
                    granter: granter__.unwrap_or_default(),
                    total_grant_amount: total_grant_amount__.unwrap_or_default(),
                    last_delegations_checked_time: last_delegations_checked_time__
                        .unwrap_or_default(),
                    grants: grants__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FullGrantAuthorizations",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for FullSpotMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        if self.mid_price_and_tob.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.FullSpotMarket", len)?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        if let Some(v) = self.mid_price_and_tob.as_ref() {
            struct_ser.serialize_field("midPriceAndTob", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for FullSpotMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market", "mid_price_and_tob", "midPriceAndTob"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
            MidPriceAndTob,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            "midPriceAndTob" | "mid_price_and_tob" => {
                                Ok(GeneratedField::MidPriceAndTob)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FullSpotMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.FullSpotMarket")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FullSpotMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                let mut mid_price_and_tob__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                        GeneratedField::MidPriceAndTob => {
                            if mid_price_and_tob__.is_some() {
                                return Err(serde::de::Error::duplicate_field("midPriceAndTob"));
                            }
                            mid_price_and_tob__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FullSpotMarket {
                    market: market__,
                    mid_price_and_tob: mid_price_and_tob__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.FullSpotMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for GenesisState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.params.is_some() {
            len += 1;
        }
        if !self.spot_markets.is_empty() {
            len += 1;
        }
        if !self.derivative_markets.is_empty() {
            len += 1;
        }
        if !self.spot_orderbook.is_empty() {
            len += 1;
        }
        if !self.derivative_orderbook.is_empty() {
            len += 1;
        }
        if !self.balances.is_empty() {
            len += 1;
        }
        if !self.positions.is_empty() {
            len += 1;
        }
        if !self.subaccount_trade_nonces.is_empty() {
            len += 1;
        }
        if !self.expiry_futures_market_info_state.is_empty() {
            len += 1;
        }
        if !self.perpetual_market_info.is_empty() {
            len += 1;
        }
        if !self.perpetual_market_funding_state.is_empty() {
            len += 1;
        }
        if !self.derivative_market_settlement_scheduled.is_empty() {
            len += 1;
        }
        if self.is_spot_exchange_enabled {
            len += 1;
        }
        if self.is_derivatives_exchange_enabled {
            len += 1;
        }
        if self.trading_reward_campaign_info.is_some() {
            len += 1;
        }
        if !self.trading_reward_pool_campaign_schedule.is_empty() {
            len += 1;
        }
        if !self.trading_reward_campaign_account_points.is_empty() {
            len += 1;
        }
        if self.fee_discount_schedule.is_some() {
            len += 1;
        }
        if !self.fee_discount_account_tier_ttl.is_empty() {
            len += 1;
        }
        if !self.fee_discount_bucket_volume_accounts.is_empty() {
            len += 1;
        }
        if self.is_first_fee_cycle_finished {
            len += 1;
        }
        if !self
            .pending_trading_reward_pool_campaign_schedule
            .is_empty()
        {
            len += 1;
        }
        if !self
            .pending_trading_reward_campaign_account_points
            .is_empty()
        {
            len += 1;
        }
        if !self.rewards_opt_out_addresses.is_empty() {
            len += 1;
        }
        if !self.historical_trade_records.is_empty() {
            len += 1;
        }
        if !self.binary_options_markets.is_empty() {
            len += 1;
        }
        if !self
            .binary_options_market_ids_scheduled_for_settlement
            .is_empty()
        {
            len += 1;
        }
        if !self.spot_market_ids_scheduled_to_force_close.is_empty() {
            len += 1;
        }
        if !self.denom_decimals.is_empty() {
            len += 1;
        }
        if !self.conditional_derivative_orderbooks.is_empty() {
            len += 1;
        }
        if !self.market_fee_multipliers.is_empty() {
            len += 1;
        }
        if !self.orderbook_sequences.is_empty() {
            len += 1;
        }
        if !self.subaccount_volumes.is_empty() {
            len += 1;
        }
        if !self.market_volumes.is_empty() {
            len += 1;
        }
        if !self.grant_authorizations.is_empty() {
            len += 1;
        }
        if !self.active_grants.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.GenesisState", len)?;
        if let Some(v) = self.params.as_ref() {
            struct_ser.serialize_field("params", v)?;
        }
        if !self.spot_markets.is_empty() {
            struct_ser.serialize_field("spotMarkets", &self.spot_markets)?;
        }
        if !self.derivative_markets.is_empty() {
            struct_ser.serialize_field("derivativeMarkets", &self.derivative_markets)?;
        }
        if !self.spot_orderbook.is_empty() {
            struct_ser.serialize_field("spotOrderbook", &self.spot_orderbook)?;
        }
        if !self.derivative_orderbook.is_empty() {
            struct_ser.serialize_field("derivativeOrderbook", &self.derivative_orderbook)?;
        }
        if !self.balances.is_empty() {
            struct_ser.serialize_field("balances", &self.balances)?;
        }
        if !self.positions.is_empty() {
            struct_ser.serialize_field("positions", &self.positions)?;
        }
        if !self.subaccount_trade_nonces.is_empty() {
            struct_ser.serialize_field("subaccountTradeNonces", &self.subaccount_trade_nonces)?;
        }
        if !self.expiry_futures_market_info_state.is_empty() {
            struct_ser.serialize_field(
                "expiryFuturesMarketInfoState",
                &self.expiry_futures_market_info_state,
            )?;
        }
        if !self.perpetual_market_info.is_empty() {
            struct_ser.serialize_field("perpetualMarketInfo", &self.perpetual_market_info)?;
        }
        if !self.perpetual_market_funding_state.is_empty() {
            struct_ser.serialize_field(
                "perpetualMarketFundingState",
                &self.perpetual_market_funding_state,
            )?;
        }
        if !self.derivative_market_settlement_scheduled.is_empty() {
            struct_ser.serialize_field(
                "derivativeMarketSettlementScheduled",
                &self.derivative_market_settlement_scheduled,
            )?;
        }
        if self.is_spot_exchange_enabled {
            struct_ser.serialize_field("isSpotExchangeEnabled", &self.is_spot_exchange_enabled)?;
        }
        if self.is_derivatives_exchange_enabled {
            struct_ser.serialize_field(
                "isDerivativesExchangeEnabled",
                &self.is_derivatives_exchange_enabled,
            )?;
        }
        if let Some(v) = self.trading_reward_campaign_info.as_ref() {
            struct_ser.serialize_field("tradingRewardCampaignInfo", v)?;
        }
        if !self.trading_reward_pool_campaign_schedule.is_empty() {
            struct_ser.serialize_field(
                "tradingRewardPoolCampaignSchedule",
                &self.trading_reward_pool_campaign_schedule,
            )?;
        }
        if !self.trading_reward_campaign_account_points.is_empty() {
            struct_ser.serialize_field(
                "tradingRewardCampaignAccountPoints",
                &self.trading_reward_campaign_account_points,
            )?;
        }
        if let Some(v) = self.fee_discount_schedule.as_ref() {
            struct_ser.serialize_field("feeDiscountSchedule", v)?;
        }
        if !self.fee_discount_account_tier_ttl.is_empty() {
            struct_ser.serialize_field(
                "feeDiscountAccountTierTtl",
                &self.fee_discount_account_tier_ttl,
            )?;
        }
        if !self.fee_discount_bucket_volume_accounts.is_empty() {
            struct_ser.serialize_field(
                "feeDiscountBucketVolumeAccounts",
                &self.fee_discount_bucket_volume_accounts,
            )?;
        }
        if self.is_first_fee_cycle_finished {
            struct_ser
                .serialize_field("isFirstFeeCycleFinished", &self.is_first_fee_cycle_finished)?;
        }
        if !self
            .pending_trading_reward_pool_campaign_schedule
            .is_empty()
        {
            struct_ser.serialize_field(
                "pendingTradingRewardPoolCampaignSchedule",
                &self.pending_trading_reward_pool_campaign_schedule,
            )?;
        }
        if !self
            .pending_trading_reward_campaign_account_points
            .is_empty()
        {
            struct_ser.serialize_field(
                "pendingTradingRewardCampaignAccountPoints",
                &self.pending_trading_reward_campaign_account_points,
            )?;
        }
        if !self.rewards_opt_out_addresses.is_empty() {
            struct_ser
                .serialize_field("rewardsOptOutAddresses", &self.rewards_opt_out_addresses)?;
        }
        if !self.historical_trade_records.is_empty() {
            struct_ser.serialize_field("historicalTradeRecords", &self.historical_trade_records)?;
        }
        if !self.binary_options_markets.is_empty() {
            struct_ser.serialize_field("binaryOptionsMarkets", &self.binary_options_markets)?;
        }
        if !self
            .binary_options_market_ids_scheduled_for_settlement
            .is_empty()
        {
            struct_ser.serialize_field(
                "binaryOptionsMarketIdsScheduledForSettlement",
                &self.binary_options_market_ids_scheduled_for_settlement,
            )?;
        }
        if !self.spot_market_ids_scheduled_to_force_close.is_empty() {
            struct_ser.serialize_field(
                "spotMarketIdsScheduledToForceClose",
                &self.spot_market_ids_scheduled_to_force_close,
            )?;
        }
        if !self.denom_decimals.is_empty() {
            struct_ser.serialize_field("denomDecimals", &self.denom_decimals)?;
        }
        if !self.conditional_derivative_orderbooks.is_empty() {
            struct_ser.serialize_field(
                "conditionalDerivativeOrderbooks",
                &self.conditional_derivative_orderbooks,
            )?;
        }
        if !self.market_fee_multipliers.is_empty() {
            struct_ser.serialize_field("marketFeeMultipliers", &self.market_fee_multipliers)?;
        }
        if !self.orderbook_sequences.is_empty() {
            struct_ser.serialize_field("orderbookSequences", &self.orderbook_sequences)?;
        }
        if !self.subaccount_volumes.is_empty() {
            struct_ser.serialize_field("subaccountVolumes", &self.subaccount_volumes)?;
        }
        if !self.market_volumes.is_empty() {
            struct_ser.serialize_field("marketVolumes", &self.market_volumes)?;
        }
        if !self.grant_authorizations.is_empty() {
            struct_ser.serialize_field("grantAuthorizations", &self.grant_authorizations)?;
        }
        if !self.active_grants.is_empty() {
            struct_ser.serialize_field("activeGrants", &self.active_grants)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for GenesisState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "params",
            "spot_markets",
            "spotMarkets",
            "derivative_markets",
            "derivativeMarkets",
            "spot_orderbook",
            "spotOrderbook",
            "derivative_orderbook",
            "derivativeOrderbook",
            "balances",
            "positions",
            "subaccount_trade_nonces",
            "subaccountTradeNonces",
            "expiry_futures_market_info_state",
            "expiryFuturesMarketInfoState",
            "perpetual_market_info",
            "perpetualMarketInfo",
            "perpetual_market_funding_state",
            "perpetualMarketFundingState",
            "derivative_market_settlement_scheduled",
            "derivativeMarketSettlementScheduled",
            "is_spot_exchange_enabled",
            "isSpotExchangeEnabled",
            "is_derivatives_exchange_enabled",
            "isDerivativesExchangeEnabled",
            "trading_reward_campaign_info",
            "tradingRewardCampaignInfo",
            "trading_reward_pool_campaign_schedule",
            "tradingRewardPoolCampaignSchedule",
            "trading_reward_campaign_account_points",
            "tradingRewardCampaignAccountPoints",
            "fee_discount_schedule",
            "feeDiscountSchedule",
            "fee_discount_account_tier_ttl",
            "feeDiscountAccountTierTtl",
            "fee_discount_bucket_volume_accounts",
            "feeDiscountBucketVolumeAccounts",
            "is_first_fee_cycle_finished",
            "isFirstFeeCycleFinished",
            "pending_trading_reward_pool_campaign_schedule",
            "pendingTradingRewardPoolCampaignSchedule",
            "pending_trading_reward_campaign_account_points",
            "pendingTradingRewardCampaignAccountPoints",
            "rewards_opt_out_addresses",
            "rewardsOptOutAddresses",
            "historical_trade_records",
            "historicalTradeRecords",
            "binary_options_markets",
            "binaryOptionsMarkets",
            "binary_options_market_ids_scheduled_for_settlement",
            "binaryOptionsMarketIdsScheduledForSettlement",
            "spot_market_ids_scheduled_to_force_close",
            "spotMarketIdsScheduledToForceClose",
            "denom_decimals",
            "denomDecimals",
            "conditional_derivative_orderbooks",
            "conditionalDerivativeOrderbooks",
            "market_fee_multipliers",
            "marketFeeMultipliers",
            "orderbook_sequences",
            "orderbookSequences",
            "subaccount_volumes",
            "subaccountVolumes",
            "market_volumes",
            "marketVolumes",
            "grant_authorizations",
            "grantAuthorizations",
            "active_grants",
            "activeGrants",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Params,
            SpotMarkets,
            DerivativeMarkets,
            SpotOrderbook,
            DerivativeOrderbook,
            Balances,
            Positions,
            SubaccountTradeNonces,
            ExpiryFuturesMarketInfoState,
            PerpetualMarketInfo,
            PerpetualMarketFundingState,
            DerivativeMarketSettlementScheduled,
            IsSpotExchangeEnabled,
            IsDerivativesExchangeEnabled,
            TradingRewardCampaignInfo,
            TradingRewardPoolCampaignSchedule,
            TradingRewardCampaignAccountPoints,
            FeeDiscountSchedule,
            FeeDiscountAccountTierTtl,
            FeeDiscountBucketVolumeAccounts,
            IsFirstFeeCycleFinished,
            PendingTradingRewardPoolCampaignSchedule,
            PendingTradingRewardCampaignAccountPoints,
            RewardsOptOutAddresses,
            HistoricalTradeRecords,
            BinaryOptionsMarkets,
            BinaryOptionsMarketIdsScheduledForSettlement,
            SpotMarketIdsScheduledToForceClose,
            DenomDecimals,
            ConditionalDerivativeOrderbooks,
            MarketFeeMultipliers,
            OrderbookSequences,
            SubaccountVolumes,
            MarketVolumes,
            GrantAuthorizations,
            ActiveGrants,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "params" => Ok(GeneratedField::Params),
                            "spotMarkets" | "spot_markets" => Ok(GeneratedField::SpotMarkets),
                            "derivativeMarkets" | "derivative_markets" => {
                                Ok(GeneratedField::DerivativeMarkets)
                            }
                            "spotOrderbook" | "spot_orderbook" => Ok(GeneratedField::SpotOrderbook),
                            "derivativeOrderbook" | "derivative_orderbook" => {
                                Ok(GeneratedField::DerivativeOrderbook)
                            }
                            "balances" => Ok(GeneratedField::Balances),
                            "positions" => Ok(GeneratedField::Positions),
                            "subaccountTradeNonces" | "subaccount_trade_nonces" => {
                                Ok(GeneratedField::SubaccountTradeNonces)
                            }
                            "expiryFuturesMarketInfoState" | "expiry_futures_market_info_state" => {
                                Ok(GeneratedField::ExpiryFuturesMarketInfoState)
                            }
                            "perpetualMarketInfo" | "perpetual_market_info" => {
                                Ok(GeneratedField::PerpetualMarketInfo)
                            }
                            "perpetualMarketFundingState" | "perpetual_market_funding_state" => {
                                Ok(GeneratedField::PerpetualMarketFundingState)
                            }
                            "derivativeMarketSettlementScheduled"
                            | "derivative_market_settlement_scheduled" => {
                                Ok(GeneratedField::DerivativeMarketSettlementScheduled)
                            }
                            "isSpotExchangeEnabled" | "is_spot_exchange_enabled" => {
                                Ok(GeneratedField::IsSpotExchangeEnabled)
                            }
                            "isDerivativesExchangeEnabled" | "is_derivatives_exchange_enabled" => {
                                Ok(GeneratedField::IsDerivativesExchangeEnabled)
                            }
                            "tradingRewardCampaignInfo" | "trading_reward_campaign_info" => {
                                Ok(GeneratedField::TradingRewardCampaignInfo)
                            }
                            "tradingRewardPoolCampaignSchedule"
                            | "trading_reward_pool_campaign_schedule" => {
                                Ok(GeneratedField::TradingRewardPoolCampaignSchedule)
                            }
                            "tradingRewardCampaignAccountPoints"
                            | "trading_reward_campaign_account_points" => {
                                Ok(GeneratedField::TradingRewardCampaignAccountPoints)
                            }
                            "feeDiscountSchedule" | "fee_discount_schedule" => {
                                Ok(GeneratedField::FeeDiscountSchedule)
                            }
                            "feeDiscountAccountTierTtl" | "fee_discount_account_tier_ttl" => {
                                Ok(GeneratedField::FeeDiscountAccountTierTtl)
                            }
                            "feeDiscountBucketVolumeAccounts"
                            | "fee_discount_bucket_volume_accounts" => {
                                Ok(GeneratedField::FeeDiscountBucketVolumeAccounts)
                            }
                            "isFirstFeeCycleFinished" | "is_first_fee_cycle_finished" => {
                                Ok(GeneratedField::IsFirstFeeCycleFinished)
                            }
                            "pendingTradingRewardPoolCampaignSchedule"
                            | "pending_trading_reward_pool_campaign_schedule" => {
                                Ok(GeneratedField::PendingTradingRewardPoolCampaignSchedule)
                            }
                            "pendingTradingRewardCampaignAccountPoints"
                            | "pending_trading_reward_campaign_account_points" => {
                                Ok(GeneratedField::PendingTradingRewardCampaignAccountPoints)
                            }
                            "rewardsOptOutAddresses" | "rewards_opt_out_addresses" => {
                                Ok(GeneratedField::RewardsOptOutAddresses)
                            }
                            "historicalTradeRecords" | "historical_trade_records" => {
                                Ok(GeneratedField::HistoricalTradeRecords)
                            }
                            "binaryOptionsMarkets" | "binary_options_markets" => {
                                Ok(GeneratedField::BinaryOptionsMarkets)
                            }
                            "binaryOptionsMarketIdsScheduledForSettlement"
                            | "binary_options_market_ids_scheduled_for_settlement" => {
                                Ok(GeneratedField::BinaryOptionsMarketIdsScheduledForSettlement)
                            }
                            "spotMarketIdsScheduledToForceClose"
                            | "spot_market_ids_scheduled_to_force_close" => {
                                Ok(GeneratedField::SpotMarketIdsScheduledToForceClose)
                            }
                            "denomDecimals" | "denom_decimals" => Ok(GeneratedField::DenomDecimals),
                            "conditionalDerivativeOrderbooks"
                            | "conditional_derivative_orderbooks" => {
                                Ok(GeneratedField::ConditionalDerivativeOrderbooks)
                            }
                            "marketFeeMultipliers" | "market_fee_multipliers" => {
                                Ok(GeneratedField::MarketFeeMultipliers)
                            }
                            "orderbookSequences" | "orderbook_sequences" => {
                                Ok(GeneratedField::OrderbookSequences)
                            }
                            "subaccountVolumes" | "subaccount_volumes" => {
                                Ok(GeneratedField::SubaccountVolumes)
                            }
                            "marketVolumes" | "market_volumes" => Ok(GeneratedField::MarketVolumes),
                            "grantAuthorizations" | "grant_authorizations" => {
                                Ok(GeneratedField::GrantAuthorizations)
                            }
                            "activeGrants" | "active_grants" => Ok(GeneratedField::ActiveGrants),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GenesisState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.GenesisState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GenesisState, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut params__ = None;
                let mut spot_markets__ = None;
                let mut derivative_markets__ = None;
                let mut spot_orderbook__ = None;
                let mut derivative_orderbook__ = None;
                let mut balances__ = None;
                let mut positions__ = None;
                let mut subaccount_trade_nonces__ = None;
                let mut expiry_futures_market_info_state__ = None;
                let mut perpetual_market_info__ = None;
                let mut perpetual_market_funding_state__ = None;
                let mut derivative_market_settlement_scheduled__ = None;
                let mut is_spot_exchange_enabled__ = None;
                let mut is_derivatives_exchange_enabled__ = None;
                let mut trading_reward_campaign_info__ = None;
                let mut trading_reward_pool_campaign_schedule__ = None;
                let mut trading_reward_campaign_account_points__ = None;
                let mut fee_discount_schedule__ = None;
                let mut fee_discount_account_tier_ttl__ = None;
                let mut fee_discount_bucket_volume_accounts__ = None;
                let mut is_first_fee_cycle_finished__ = None;
                let mut pending_trading_reward_pool_campaign_schedule__ = None;
                let mut pending_trading_reward_campaign_account_points__ = None;
                let mut rewards_opt_out_addresses__ = None;
                let mut historical_trade_records__ = None;
                let mut binary_options_markets__ = None;
                let mut binary_options_market_ids_scheduled_for_settlement__ = None;
                let mut spot_market_ids_scheduled_to_force_close__ = None;
                let mut denom_decimals__ = None;
                let mut conditional_derivative_orderbooks__ = None;
                let mut market_fee_multipliers__ = None;
                let mut orderbook_sequences__ = None;
                let mut subaccount_volumes__ = None;
                let mut market_volumes__ = None;
                let mut grant_authorizations__ = None;
                let mut active_grants__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Params => {
                            if params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("params"));
                            }
                            params__ = map_.next_value()?;
                        }
                        GeneratedField::SpotMarkets => {
                            if spot_markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spotMarkets"));
                            }
                            spot_markets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeMarkets => {
                            if derivative_markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("derivativeMarkets"));
                            }
                            derivative_markets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotOrderbook => {
                            if spot_orderbook__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spotOrderbook"));
                            }
                            spot_orderbook__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeOrderbook => {
                            if derivative_orderbook__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeOrderbook",
                                ));
                            }
                            derivative_orderbook__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Balances => {
                            if balances__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balances"));
                            }
                            balances__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Positions => {
                            if positions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("positions"));
                            }
                            positions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountTradeNonces => {
                            if subaccount_trade_nonces__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "subaccountTradeNonces",
                                ));
                            }
                            subaccount_trade_nonces__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpiryFuturesMarketInfoState => {
                            if expiry_futures_market_info_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expiryFuturesMarketInfoState",
                                ));
                            }
                            expiry_futures_market_info_state__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PerpetualMarketInfo => {
                            if perpetual_market_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "perpetualMarketInfo",
                                ));
                            }
                            perpetual_market_info__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PerpetualMarketFundingState => {
                            if perpetual_market_funding_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "perpetualMarketFundingState",
                                ));
                            }
                            perpetual_market_funding_state__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeMarketSettlementScheduled => {
                            if derivative_market_settlement_scheduled__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeMarketSettlementScheduled",
                                ));
                            }
                            derivative_market_settlement_scheduled__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsSpotExchangeEnabled => {
                            if is_spot_exchange_enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "isSpotExchangeEnabled",
                                ));
                            }
                            is_spot_exchange_enabled__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsDerivativesExchangeEnabled => {
                            if is_derivatives_exchange_enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "isDerivativesExchangeEnabled",
                                ));
                            }
                            is_derivatives_exchange_enabled__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradingRewardCampaignInfo => {
                            if trading_reward_campaign_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardCampaignInfo",
                                ));
                            }
                            trading_reward_campaign_info__ = map_.next_value()?;
                        }
                        GeneratedField::TradingRewardPoolCampaignSchedule => {
                            if trading_reward_pool_campaign_schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardPoolCampaignSchedule",
                                ));
                            }
                            trading_reward_pool_campaign_schedule__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradingRewardCampaignAccountPoints => {
                            if trading_reward_campaign_account_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardCampaignAccountPoints",
                                ));
                            }
                            trading_reward_campaign_account_points__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FeeDiscountSchedule => {
                            if fee_discount_schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "feeDiscountSchedule",
                                ));
                            }
                            fee_discount_schedule__ = map_.next_value()?;
                        }
                        GeneratedField::FeeDiscountAccountTierTtl => {
                            if fee_discount_account_tier_ttl__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "feeDiscountAccountTierTtl",
                                ));
                            }
                            fee_discount_account_tier_ttl__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FeeDiscountBucketVolumeAccounts => {
                            if fee_discount_bucket_volume_accounts__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "feeDiscountBucketVolumeAccounts",
                                ));
                            }
                            fee_discount_bucket_volume_accounts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsFirstFeeCycleFinished => {
                            if is_first_fee_cycle_finished__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "isFirstFeeCycleFinished",
                                ));
                            }
                            is_first_fee_cycle_finished__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PendingTradingRewardPoolCampaignSchedule => {
                            if pending_trading_reward_pool_campaign_schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "pendingTradingRewardPoolCampaignSchedule",
                                ));
                            }
                            pending_trading_reward_pool_campaign_schedule__ =
                                Some(map_.next_value()?);
                        }
                        GeneratedField::PendingTradingRewardCampaignAccountPoints => {
                            if pending_trading_reward_campaign_account_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "pendingTradingRewardCampaignAccountPoints",
                                ));
                            }
                            pending_trading_reward_campaign_account_points__ =
                                Some(map_.next_value()?);
                        }
                        GeneratedField::RewardsOptOutAddresses => {
                            if rewards_opt_out_addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "rewardsOptOutAddresses",
                                ));
                            }
                            rewards_opt_out_addresses__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HistoricalTradeRecords => {
                            if historical_trade_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "historicalTradeRecords",
                                ));
                            }
                            historical_trade_records__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsMarkets => {
                            if binary_options_markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsMarkets",
                                ));
                            }
                            binary_options_markets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsMarketIdsScheduledForSettlement => {
                            if binary_options_market_ids_scheduled_for_settlement__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsMarketIdsScheduledForSettlement",
                                ));
                            }
                            binary_options_market_ids_scheduled_for_settlement__ =
                                Some(map_.next_value()?);
                        }
                        GeneratedField::SpotMarketIdsScheduledToForceClose => {
                            if spot_market_ids_scheduled_to_force_close__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotMarketIdsScheduledToForceClose",
                                ));
                            }
                            spot_market_ids_scheduled_to_force_close__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DenomDecimals => {
                            if denom_decimals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denomDecimals"));
                            }
                            denom_decimals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ConditionalDerivativeOrderbooks => {
                            if conditional_derivative_orderbooks__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "conditionalDerivativeOrderbooks",
                                ));
                            }
                            conditional_derivative_orderbooks__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketFeeMultipliers => {
                            if market_fee_multipliers__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "marketFeeMultipliers",
                                ));
                            }
                            market_fee_multipliers__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderbookSequences => {
                            if orderbook_sequences__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "orderbookSequences",
                                ));
                            }
                            orderbook_sequences__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountVolumes => {
                            if subaccount_volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountVolumes"));
                            }
                            subaccount_volumes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketVolumes => {
                            if market_volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketVolumes"));
                            }
                            market_volumes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GrantAuthorizations => {
                            if grant_authorizations__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "grantAuthorizations",
                                ));
                            }
                            grant_authorizations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ActiveGrants => {
                            if active_grants__.is_some() {
                                return Err(serde::de::Error::duplicate_field("activeGrants"));
                            }
                            active_grants__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(GenesisState {
                    params: params__,
                    spot_markets: spot_markets__.unwrap_or_default(),
                    derivative_markets: derivative_markets__.unwrap_or_default(),
                    spot_orderbook: spot_orderbook__.unwrap_or_default(),
                    derivative_orderbook: derivative_orderbook__.unwrap_or_default(),
                    balances: balances__.unwrap_or_default(),
                    positions: positions__.unwrap_or_default(),
                    subaccount_trade_nonces: subaccount_trade_nonces__.unwrap_or_default(),
                    expiry_futures_market_info_state: expiry_futures_market_info_state__
                        .unwrap_or_default(),
                    perpetual_market_info: perpetual_market_info__.unwrap_or_default(),
                    perpetual_market_funding_state: perpetual_market_funding_state__
                        .unwrap_or_default(),
                    derivative_market_settlement_scheduled:
                        derivative_market_settlement_scheduled__.unwrap_or_default(),
                    is_spot_exchange_enabled: is_spot_exchange_enabled__.unwrap_or_default(),
                    is_derivatives_exchange_enabled: is_derivatives_exchange_enabled__
                        .unwrap_or_default(),
                    trading_reward_campaign_info: trading_reward_campaign_info__,
                    trading_reward_pool_campaign_schedule: trading_reward_pool_campaign_schedule__
                        .unwrap_or_default(),
                    trading_reward_campaign_account_points:
                        trading_reward_campaign_account_points__.unwrap_or_default(),
                    fee_discount_schedule: fee_discount_schedule__,
                    fee_discount_account_tier_ttl: fee_discount_account_tier_ttl__
                        .unwrap_or_default(),
                    fee_discount_bucket_volume_accounts: fee_discount_bucket_volume_accounts__
                        .unwrap_or_default(),
                    is_first_fee_cycle_finished: is_first_fee_cycle_finished__.unwrap_or_default(),
                    pending_trading_reward_pool_campaign_schedule:
                        pending_trading_reward_pool_campaign_schedule__.unwrap_or_default(),
                    pending_trading_reward_campaign_account_points:
                        pending_trading_reward_campaign_account_points__.unwrap_or_default(),
                    rewards_opt_out_addresses: rewards_opt_out_addresses__.unwrap_or_default(),
                    historical_trade_records: historical_trade_records__.unwrap_or_default(),
                    binary_options_markets: binary_options_markets__.unwrap_or_default(),
                    binary_options_market_ids_scheduled_for_settlement:
                        binary_options_market_ids_scheduled_for_settlement__.unwrap_or_default(),
                    spot_market_ids_scheduled_to_force_close:
                        spot_market_ids_scheduled_to_force_close__.unwrap_or_default(),
                    denom_decimals: denom_decimals__.unwrap_or_default(),
                    conditional_derivative_orderbooks: conditional_derivative_orderbooks__
                        .unwrap_or_default(),
                    market_fee_multipliers: market_fee_multipliers__.unwrap_or_default(),
                    orderbook_sequences: orderbook_sequences__.unwrap_or_default(),
                    subaccount_volumes: subaccount_volumes__.unwrap_or_default(),
                    market_volumes: market_volumes__.unwrap_or_default(),
                    grant_authorizations: grant_authorizations__.unwrap_or_default(),
                    active_grants: active_grants__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.GenesisState",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for GrantAuthorization {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.grantee.is_empty() {
            len += 1;
        }
        if !self.amount.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.GrantAuthorization", len)?;
        if !self.grantee.is_empty() {
            struct_ser.serialize_field("grantee", &self.grantee)?;
        }
        if !self.amount.is_empty() {
            struct_ser.serialize_field("amount", &self.amount)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for GrantAuthorization {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["grantee", "amount"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Grantee,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "grantee" => Ok(GeneratedField::Grantee),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GrantAuthorization;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.GrantAuthorization")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GrantAuthorization, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut grantee__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Grantee => {
                            if grantee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantee"));
                            }
                            grantee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(GrantAuthorization {
                    grantee: grantee__.unwrap_or_default(),
                    amount: amount__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.GrantAuthorization",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Level {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.p.is_empty() {
            len += 1;
        }
        if !self.q.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.Level", len)?;
        if !self.p.is_empty() {
            struct_ser.serialize_field("p", &self.p)?;
        }
        if !self.q.is_empty() {
            struct_ser.serialize_field("q", &self.q)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for Level {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["p", "q"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            P,
            Q,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "p" => Ok(GeneratedField::P),
                            "q" => Ok(GeneratedField::Q),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Level;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.Level")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Level, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut p__ = None;
                let mut q__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::P => {
                            if p__.is_some() {
                                return Err(serde::de::Error::duplicate_field("p"));
                            }
                            p__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Q => {
                            if q__.is_some() {
                                return Err(serde::de::Error::duplicate_field("q"));
                            }
                            q__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Level {
                    p: p__.unwrap_or_default(),
                    q: q__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.Level",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MarketFeeMultiplier {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.fee_multiplier.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MarketFeeMultiplier", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.fee_multiplier.is_empty() {
            struct_ser.serialize_field("feeMultiplier", &self.fee_multiplier)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MarketFeeMultiplier {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "fee_multiplier", "feeMultiplier"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            FeeMultiplier,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "feeMultiplier" | "fee_multiplier" => Ok(GeneratedField::FeeMultiplier),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarketFeeMultiplier;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MarketFeeMultiplier")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MarketFeeMultiplier, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut fee_multiplier__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FeeMultiplier => {
                            if fee_multiplier__.is_some() {
                                return Err(serde::de::Error::duplicate_field("feeMultiplier"));
                            }
                            fee_multiplier__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MarketFeeMultiplier {
                    market_id: market_id__.unwrap_or_default(),
                    fee_multiplier: fee_multiplier__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MarketFeeMultiplier",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MarketForcedSettlementProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.settlement_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MarketForcedSettlementProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.settlement_price.is_empty() {
            struct_ser.serialize_field("settlementPrice", &self.settlement_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MarketForcedSettlementProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "market_id",
            "marketId",
            "settlement_price",
            "settlementPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            MarketId,
            SettlementPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "settlementPrice" | "settlement_price" => {
                                Ok(GeneratedField::SettlementPrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarketForcedSettlementProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MarketForcedSettlementProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MarketForcedSettlementProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut market_id__ = None;
                let mut settlement_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlementPrice => {
                            if settlement_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlementPrice"));
                            }
                            settlement_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MarketForcedSettlementProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    settlement_price: settlement_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MarketForcedSettlementProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MarketOrderIndicator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_buy {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MarketOrderIndicator", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_buy {
            struct_ser.serialize_field("isBuy", &self.is_buy)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MarketOrderIndicator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "isBuy"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsBuy,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isBuy" => Ok(GeneratedField::IsBuy),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarketOrderIndicator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MarketOrderIndicator")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MarketOrderIndicator, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_buy__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuy => {
                            if is_buy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuy"));
                            }
                            is_buy__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MarketOrderIndicator {
                    market_id: market_id__.unwrap_or_default(),
                    is_buy: is_buy__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MarketOrderIndicator",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MarketStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "Unspecified",
            Self::Active => "Active",
            Self::Paused => "Paused",
            Self::Demolished => "Demolished",
            Self::Expired => "Expired",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MarketStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["Unspecified", "Active", "Paused", "Demolished", "Expired"];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarketStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Unspecified" => Ok(MarketStatus::Unspecified),
                    "Active" => Ok(MarketStatus::Active),
                    "Paused" => Ok(MarketStatus::Paused),
                    "Demolished" => Ok(MarketStatus::Demolished),
                    "Expired" => Ok(MarketStatus::Expired),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MarketVolume {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.volume.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MarketVolume", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.volume.as_ref() {
            struct_ser.serialize_field("volume", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MarketVolume {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "volume"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Volume,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "volume" => Ok(GeneratedField::Volume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarketVolume;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MarketVolume")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MarketVolume, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut volume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MarketVolume {
                    market_id: market_id__.unwrap_or_default(),
                    volume: volume__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MarketVolume",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MidPriceAndTob {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.mid_price.is_empty() {
            len += 1;
        }
        if !self.best_buy_price.is_empty() {
            len += 1;
        }
        if !self.best_sell_price.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MidPriceAndTOB", len)?;
        if !self.mid_price.is_empty() {
            struct_ser.serialize_field("midPrice", &self.mid_price)?;
        }
        if !self.best_buy_price.is_empty() {
            struct_ser.serialize_field("bestBuyPrice", &self.best_buy_price)?;
        }
        if !self.best_sell_price.is_empty() {
            struct_ser.serialize_field("bestSellPrice", &self.best_sell_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MidPriceAndTob {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mid_price",
            "midPrice",
            "best_buy_price",
            "bestBuyPrice",
            "best_sell_price",
            "bestSellPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MidPrice,
            BestBuyPrice,
            BestSellPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "midPrice" | "mid_price" => Ok(GeneratedField::MidPrice),
                            "bestBuyPrice" | "best_buy_price" => Ok(GeneratedField::BestBuyPrice),
                            "bestSellPrice" | "best_sell_price" => {
                                Ok(GeneratedField::BestSellPrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MidPriceAndTob;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MidPriceAndTOB")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MidPriceAndTob, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut mid_price__ = None;
                let mut best_buy_price__ = None;
                let mut best_sell_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MidPrice => {
                            if mid_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("midPrice"));
                            }
                            mid_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BestBuyPrice => {
                            if best_buy_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bestBuyPrice"));
                            }
                            best_buy_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BestSellPrice => {
                            if best_sell_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bestSellPrice"));
                            }
                            best_sell_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MidPriceAndTob {
                    mid_price: mid_price__.unwrap_or_default(),
                    best_buy_price: best_buy_price__.unwrap_or_default(),
                    best_sell_price: best_sell_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MidPriceAndTOB",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MitoVaultInfosRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MitoVaultInfosRequest", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MitoVaultInfosRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MitoVaultInfosRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MitoVaultInfosRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MitoVaultInfosRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MitoVaultInfosRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MitoVaultInfosRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MitoVaultInfosResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.master_addresses.is_empty() {
            len += 1;
        }
        if !self.derivative_addresses.is_empty() {
            len += 1;
        }
        if !self.spot_addresses.is_empty() {
            len += 1;
        }
        if !self.cw20_addresses.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MitoVaultInfosResponse", len)?;
        if !self.master_addresses.is_empty() {
            struct_ser.serialize_field("masterAddresses", &self.master_addresses)?;
        }
        if !self.derivative_addresses.is_empty() {
            struct_ser.serialize_field("derivativeAddresses", &self.derivative_addresses)?;
        }
        if !self.spot_addresses.is_empty() {
            struct_ser.serialize_field("spotAddresses", &self.spot_addresses)?;
        }
        if !self.cw20_addresses.is_empty() {
            struct_ser.serialize_field("cw20Addresses", &self.cw20_addresses)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MitoVaultInfosResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "master_addresses",
            "masterAddresses",
            "derivative_addresses",
            "derivativeAddresses",
            "spot_addresses",
            "spotAddresses",
            "cw20_addresses",
            "cw20Addresses",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MasterAddresses,
            DerivativeAddresses,
            SpotAddresses,
            Cw20Addresses,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "masterAddresses" | "master_addresses" => {
                                Ok(GeneratedField::MasterAddresses)
                            }
                            "derivativeAddresses" | "derivative_addresses" => {
                                Ok(GeneratedField::DerivativeAddresses)
                            }
                            "spotAddresses" | "spot_addresses" => Ok(GeneratedField::SpotAddresses),
                            "cw20Addresses" | "cw20_addresses" => Ok(GeneratedField::Cw20Addresses),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MitoVaultInfosResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MitoVaultInfosResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MitoVaultInfosResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut master_addresses__ = None;
                let mut derivative_addresses__ = None;
                let mut spot_addresses__ = None;
                let mut cw20_addresses__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MasterAddresses => {
                            if master_addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("masterAddresses"));
                            }
                            master_addresses__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeAddresses => {
                            if derivative_addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeAddresses",
                                ));
                            }
                            derivative_addresses__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotAddresses => {
                            if spot_addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spotAddresses"));
                            }
                            spot_addresses__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cw20Addresses => {
                            if cw20_addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cw20Addresses"));
                            }
                            cw20_addresses__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MitoVaultInfosResponse {
                    master_addresses: master_addresses__.unwrap_or_default(),
                    derivative_addresses: derivative_addresses__.unwrap_or_default(),
                    spot_addresses: spot_addresses__.unwrap_or_default(),
                    cw20_addresses: cw20_addresses__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MitoVaultInfosResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgActivateStakeGrant {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.granter.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgActivateStakeGrant", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgActivateStakeGrant {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "granter"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Granter,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "granter" => Ok(GeneratedField::Granter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgActivateStakeGrant;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgActivateStakeGrant")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgActivateStakeGrant, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut granter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgActivateStakeGrant {
                    sender: sender__.unwrap_or_default(),
                    granter: granter__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgActivateStakeGrant",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgActivateStakeGrantResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgActivateStakeGrantResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgActivateStakeGrantResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgActivateStakeGrantResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgActivateStakeGrantResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgActivateStakeGrantResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgActivateStakeGrantResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgActivateStakeGrantResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgAdminUpdateBinaryOptionsMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.settlement_price.is_empty() {
            len += 1;
        }
        if self.expiration_timestamp != 0 {
            len += 1;
        }
        if self.settlement_timestamp != 0 {
            len += 1;
        }
        if self.status != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.settlement_price.is_empty() {
            struct_ser.serialize_field("settlementPrice", &self.settlement_price)?;
        }
        if self.expiration_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "expirationTimestamp",
                ToString::to_string(&self.expiration_timestamp).as_str(),
            )?;
        }
        if self.settlement_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "settlementTimestamp",
                ToString::to_string(&self.settlement_timestamp).as_str(),
            )?;
        }
        if self.status != 0 {
            let v = MarketStatus::try_from(self.status).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.status))
            })?;
            struct_ser.serialize_field("status", &v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgAdminUpdateBinaryOptionsMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "market_id",
            "marketId",
            "settlement_price",
            "settlementPrice",
            "expiration_timestamp",
            "expirationTimestamp",
            "settlement_timestamp",
            "settlementTimestamp",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            MarketId,
            SettlementPrice,
            ExpirationTimestamp,
            SettlementTimestamp,
            Status,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "settlementPrice" | "settlement_price" => {
                                Ok(GeneratedField::SettlementPrice)
                            }
                            "expirationTimestamp" | "expiration_timestamp" => {
                                Ok(GeneratedField::ExpirationTimestamp)
                            }
                            "settlementTimestamp" | "settlement_timestamp" => {
                                Ok(GeneratedField::SettlementTimestamp)
                            }
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgAdminUpdateBinaryOptionsMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgAdminUpdateBinaryOptionsMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut market_id__ = None;
                let mut settlement_price__ = None;
                let mut expiration_timestamp__ = None;
                let mut settlement_timestamp__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SettlementPrice => {
                            if settlement_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settlementPrice"));
                            }
                            settlement_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpirationTimestamp => {
                            if expiration_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expirationTimestamp",
                                ));
                            }
                            expiration_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::SettlementTimestamp => {
                            if settlement_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "settlementTimestamp",
                                ));
                            }
                            settlement_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<MarketStatus>()? as i32);
                        }
                    }
                }
                Ok(MsgAdminUpdateBinaryOptionsMarket {
                    sender: sender__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    settlement_price: settlement_price__.unwrap_or_default(),
                    expiration_timestamp: expiration_timestamp__.unwrap_or_default(),
                    settlement_timestamp: settlement_timestamp__.unwrap_or_default(),
                    status: status__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgAdminUpdateBinaryOptionsMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgAdminUpdateBinaryOptionsMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgAdminUpdateBinaryOptionsMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgAdminUpdateBinaryOptionsMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgAdminUpdateBinaryOptionsMarketResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgAuthorizeStakeGrants {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.grants.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgAuthorizeStakeGrants", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.grants.is_empty() {
            struct_ser.serialize_field("grants", &self.grants)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgAuthorizeStakeGrants {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "grants"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Grants,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "grants" => Ok(GeneratedField::Grants),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgAuthorizeStakeGrants;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgAuthorizeStakeGrants")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgAuthorizeStakeGrants, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut grants__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Grants => {
                            if grants__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grants"));
                            }
                            grants__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgAuthorizeStakeGrants {
                    sender: sender__.unwrap_or_default(),
                    grants: grants__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgAuthorizeStakeGrants",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgAuthorizeStakeGrantsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgAuthorizeStakeGrantsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgAuthorizeStakeGrantsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgAuthorizeStakeGrantsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgAuthorizeStakeGrantsResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCancelBinaryOptionsOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.data.is_empty() {
            struct_ser.serialize_field("data", &self.data)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCancelBinaryOptionsOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "data"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Data,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCancelBinaryOptionsOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCancelBinaryOptionsOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCancelBinaryOptionsOrders {
                    sender: sender__.unwrap_or_default(),
                    data: data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCancelBinaryOptionsOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.success.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse",
            len,
        )?;
        if !self.success.is_empty() {
            struct_ser.serialize_field("success", &self.success)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCancelBinaryOptionsOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["success"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Success,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "success" => Ok(GeneratedField::Success),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCancelBinaryOptionsOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCancelBinaryOptionsOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            success__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCancelBinaryOptionsOrdersResponse {
                    success: success__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCancelDerivativeOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.data.is_empty() {
            struct_ser.serialize_field("data", &self.data)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCancelDerivativeOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "data"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Data,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCancelDerivativeOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCancelDerivativeOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCancelDerivativeOrders {
                    sender: sender__.unwrap_or_default(),
                    data: data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCancelDerivativeOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.success.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse",
            len,
        )?;
        if !self.success.is_empty() {
            struct_ser.serialize_field("success", &self.success)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCancelDerivativeOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["success"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Success,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "success" => Ok(GeneratedField::Success),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCancelDerivativeOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCancelDerivativeOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            success__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCancelDerivativeOrdersResponse {
                    success: success__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCancelSpotOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgBatchCancelSpotOrders", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.data.is_empty() {
            struct_ser.serialize_field("data", &self.data)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCancelSpotOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "data"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Data,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCancelSpotOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgBatchCancelSpotOrders")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCancelSpotOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCancelSpotOrders {
                    sender: sender__.unwrap_or_default(),
                    data: data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelSpotOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCancelSpotOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.success.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse",
            len,
        )?;
        if !self.success.is_empty() {
            struct_ser.serialize_field("success", &self.success)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCancelSpotOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["success"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Success,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "success" => Ok(GeneratedField::Success),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCancelSpotOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCancelSpotOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            success__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCancelSpotOrdersResponse {
                    success: success__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCreateDerivativeLimitOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCreateDerivativeLimitOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCreateDerivativeLimitOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCreateDerivativeLimitOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCreateDerivativeLimitOrders {
                    sender: sender__.unwrap_or_default(),
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCreateDerivativeLimitOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hashes.is_empty() {
            len += 1;
        }
        if !self.created_orders_cids.is_empty() {
            len += 1;
        }
        if !self.failed_orders_cids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse",
            len,
        )?;
        if !self.order_hashes.is_empty() {
            struct_ser.serialize_field("orderHashes", &self.order_hashes)?;
        }
        if !self.created_orders_cids.is_empty() {
            struct_ser.serialize_field("createdOrdersCids", &self.created_orders_cids)?;
        }
        if !self.failed_orders_cids.is_empty() {
            struct_ser.serialize_field("failedOrdersCids", &self.failed_orders_cids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCreateDerivativeLimitOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "order_hashes",
            "orderHashes",
            "created_orders_cids",
            "createdOrdersCids",
            "failed_orders_cids",
            "failedOrdersCids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHashes,
            CreatedOrdersCids,
            FailedOrdersCids,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHashes" | "order_hashes" => Ok(GeneratedField::OrderHashes),
                            "createdOrdersCids" | "created_orders_cids" => {
                                Ok(GeneratedField::CreatedOrdersCids)
                            }
                            "failedOrdersCids" | "failed_orders_cids" => {
                                Ok(GeneratedField::FailedOrdersCids)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCreateDerivativeLimitOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCreateDerivativeLimitOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hashes__ = None;
                let mut created_orders_cids__ = None;
                let mut failed_orders_cids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHashes => {
                            if order_hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHashes"));
                            }
                            order_hashes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CreatedOrdersCids => {
                            if created_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("createdOrdersCids"));
                            }
                            created_orders_cids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FailedOrdersCids => {
                            if failed_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("failedOrdersCids"));
                            }
                            failed_orders_cids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCreateDerivativeLimitOrdersResponse {
                    order_hashes: order_hashes__.unwrap_or_default(),
                    created_orders_cids: created_orders_cids__.unwrap_or_default(),
                    failed_orders_cids: failed_orders_cids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCreateSpotLimitOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCreateSpotLimitOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCreateSpotLimitOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCreateSpotLimitOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCreateSpotLimitOrders {
                    sender: sender__.unwrap_or_default(),
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchCreateSpotLimitOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hashes.is_empty() {
            len += 1;
        }
        if !self.created_orders_cids.is_empty() {
            len += 1;
        }
        if !self.failed_orders_cids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse",
            len,
        )?;
        if !self.order_hashes.is_empty() {
            struct_ser.serialize_field("orderHashes", &self.order_hashes)?;
        }
        if !self.created_orders_cids.is_empty() {
            struct_ser.serialize_field("createdOrdersCids", &self.created_orders_cids)?;
        }
        if !self.failed_orders_cids.is_empty() {
            struct_ser.serialize_field("failedOrdersCids", &self.failed_orders_cids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchCreateSpotLimitOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "order_hashes",
            "orderHashes",
            "created_orders_cids",
            "createdOrdersCids",
            "failed_orders_cids",
            "failedOrdersCids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHashes,
            CreatedOrdersCids,
            FailedOrdersCids,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHashes" | "order_hashes" => Ok(GeneratedField::OrderHashes),
                            "createdOrdersCids" | "created_orders_cids" => {
                                Ok(GeneratedField::CreatedOrdersCids)
                            }
                            "failedOrdersCids" | "failed_orders_cids" => {
                                Ok(GeneratedField::FailedOrdersCids)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchCreateSpotLimitOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchCreateSpotLimitOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hashes__ = None;
                let mut created_orders_cids__ = None;
                let mut failed_orders_cids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHashes => {
                            if order_hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHashes"));
                            }
                            order_hashes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CreatedOrdersCids => {
                            if created_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("createdOrdersCids"));
                            }
                            created_orders_cids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FailedOrdersCids => {
                            if failed_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("failedOrdersCids"));
                            }
                            failed_orders_cids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchCreateSpotLimitOrdersResponse {
                    order_hashes: order_hashes__.unwrap_or_default(),
                    created_orders_cids: created_orders_cids__.unwrap_or_default(),
                    failed_orders_cids: failed_orders_cids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchUpdateOrders {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.spot_market_ids_to_cancel_all.is_empty() {
            len += 1;
        }
        if !self.derivative_market_ids_to_cancel_all.is_empty() {
            len += 1;
        }
        if !self.spot_orders_to_cancel.is_empty() {
            len += 1;
        }
        if !self.derivative_orders_to_cancel.is_empty() {
            len += 1;
        }
        if !self.spot_orders_to_create.is_empty() {
            len += 1;
        }
        if !self.derivative_orders_to_create.is_empty() {
            len += 1;
        }
        if !self.binary_options_orders_to_cancel.is_empty() {
            len += 1;
        }
        if !self.binary_options_market_ids_to_cancel_all.is_empty() {
            len += 1;
        }
        if !self.binary_options_orders_to_create.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgBatchUpdateOrders", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.spot_market_ids_to_cancel_all.is_empty() {
            struct_ser.serialize_field(
                "spotMarketIdsToCancelAll",
                &self.spot_market_ids_to_cancel_all,
            )?;
        }
        if !self.derivative_market_ids_to_cancel_all.is_empty() {
            struct_ser.serialize_field(
                "derivativeMarketIdsToCancelAll",
                &self.derivative_market_ids_to_cancel_all,
            )?;
        }
        if !self.spot_orders_to_cancel.is_empty() {
            struct_ser.serialize_field("spotOrdersToCancel", &self.spot_orders_to_cancel)?;
        }
        if !self.derivative_orders_to_cancel.is_empty() {
            struct_ser.serialize_field(
                "derivativeOrdersToCancel",
                &self.derivative_orders_to_cancel,
            )?;
        }
        if !self.spot_orders_to_create.is_empty() {
            struct_ser.serialize_field("spotOrdersToCreate", &self.spot_orders_to_create)?;
        }
        if !self.derivative_orders_to_create.is_empty() {
            struct_ser.serialize_field(
                "derivativeOrdersToCreate",
                &self.derivative_orders_to_create,
            )?;
        }
        if !self.binary_options_orders_to_cancel.is_empty() {
            struct_ser.serialize_field(
                "binaryOptionsOrdersToCancel",
                &self.binary_options_orders_to_cancel,
            )?;
        }
        if !self.binary_options_market_ids_to_cancel_all.is_empty() {
            struct_ser.serialize_field(
                "binaryOptionsMarketIdsToCancelAll",
                &self.binary_options_market_ids_to_cancel_all,
            )?;
        }
        if !self.binary_options_orders_to_create.is_empty() {
            struct_ser.serialize_field(
                "binaryOptionsOrdersToCreate",
                &self.binary_options_orders_to_create,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchUpdateOrders {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "subaccount_id",
            "subaccountId",
            "spot_market_ids_to_cancel_all",
            "spotMarketIdsToCancelAll",
            "derivative_market_ids_to_cancel_all",
            "derivativeMarketIdsToCancelAll",
            "spot_orders_to_cancel",
            "spotOrdersToCancel",
            "derivative_orders_to_cancel",
            "derivativeOrdersToCancel",
            "spot_orders_to_create",
            "spotOrdersToCreate",
            "derivative_orders_to_create",
            "derivativeOrdersToCreate",
            "binary_options_orders_to_cancel",
            "binaryOptionsOrdersToCancel",
            "binary_options_market_ids_to_cancel_all",
            "binaryOptionsMarketIdsToCancelAll",
            "binary_options_orders_to_create",
            "binaryOptionsOrdersToCreate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SubaccountId,
            SpotMarketIdsToCancelAll,
            DerivativeMarketIdsToCancelAll,
            SpotOrdersToCancel,
            DerivativeOrdersToCancel,
            SpotOrdersToCreate,
            DerivativeOrdersToCreate,
            BinaryOptionsOrdersToCancel,
            BinaryOptionsMarketIdsToCancelAll,
            BinaryOptionsOrdersToCreate,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "spotMarketIdsToCancelAll" | "spot_market_ids_to_cancel_all" => {
                                Ok(GeneratedField::SpotMarketIdsToCancelAll)
                            }
                            "derivativeMarketIdsToCancelAll"
                            | "derivative_market_ids_to_cancel_all" => {
                                Ok(GeneratedField::DerivativeMarketIdsToCancelAll)
                            }
                            "spotOrdersToCancel" | "spot_orders_to_cancel" => {
                                Ok(GeneratedField::SpotOrdersToCancel)
                            }
                            "derivativeOrdersToCancel" | "derivative_orders_to_cancel" => {
                                Ok(GeneratedField::DerivativeOrdersToCancel)
                            }
                            "spotOrdersToCreate" | "spot_orders_to_create" => {
                                Ok(GeneratedField::SpotOrdersToCreate)
                            }
                            "derivativeOrdersToCreate" | "derivative_orders_to_create" => {
                                Ok(GeneratedField::DerivativeOrdersToCreate)
                            }
                            "binaryOptionsOrdersToCancel" | "binary_options_orders_to_cancel" => {
                                Ok(GeneratedField::BinaryOptionsOrdersToCancel)
                            }
                            "binaryOptionsMarketIdsToCancelAll"
                            | "binary_options_market_ids_to_cancel_all" => {
                                Ok(GeneratedField::BinaryOptionsMarketIdsToCancelAll)
                            }
                            "binaryOptionsOrdersToCreate" | "binary_options_orders_to_create" => {
                                Ok(GeneratedField::BinaryOptionsOrdersToCreate)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchUpdateOrders;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgBatchUpdateOrders")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchUpdateOrders, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut subaccount_id__ = None;
                let mut spot_market_ids_to_cancel_all__ = None;
                let mut derivative_market_ids_to_cancel_all__ = None;
                let mut spot_orders_to_cancel__ = None;
                let mut derivative_orders_to_cancel__ = None;
                let mut spot_orders_to_create__ = None;
                let mut derivative_orders_to_create__ = None;
                let mut binary_options_orders_to_cancel__ = None;
                let mut binary_options_market_ids_to_cancel_all__ = None;
                let mut binary_options_orders_to_create__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotMarketIdsToCancelAll => {
                            if spot_market_ids_to_cancel_all__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotMarketIdsToCancelAll",
                                ));
                            }
                            spot_market_ids_to_cancel_all__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeMarketIdsToCancelAll => {
                            if derivative_market_ids_to_cancel_all__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeMarketIdsToCancelAll",
                                ));
                            }
                            derivative_market_ids_to_cancel_all__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotOrdersToCancel => {
                            if spot_orders_to_cancel__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotOrdersToCancel",
                                ));
                            }
                            spot_orders_to_cancel__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeOrdersToCancel => {
                            if derivative_orders_to_cancel__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeOrdersToCancel",
                                ));
                            }
                            derivative_orders_to_cancel__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotOrdersToCreate => {
                            if spot_orders_to_create__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotOrdersToCreate",
                                ));
                            }
                            spot_orders_to_create__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeOrdersToCreate => {
                            if derivative_orders_to_create__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeOrdersToCreate",
                                ));
                            }
                            derivative_orders_to_create__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsOrdersToCancel => {
                            if binary_options_orders_to_cancel__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsOrdersToCancel",
                                ));
                            }
                            binary_options_orders_to_cancel__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsMarketIdsToCancelAll => {
                            if binary_options_market_ids_to_cancel_all__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsMarketIdsToCancelAll",
                                ));
                            }
                            binary_options_market_ids_to_cancel_all__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsOrdersToCreate => {
                            if binary_options_orders_to_create__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsOrdersToCreate",
                                ));
                            }
                            binary_options_orders_to_create__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchUpdateOrders {
                    sender: sender__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    spot_market_ids_to_cancel_all: spot_market_ids_to_cancel_all__
                        .unwrap_or_default(),
                    derivative_market_ids_to_cancel_all: derivative_market_ids_to_cancel_all__
                        .unwrap_or_default(),
                    spot_orders_to_cancel: spot_orders_to_cancel__.unwrap_or_default(),
                    derivative_orders_to_cancel: derivative_orders_to_cancel__.unwrap_or_default(),
                    spot_orders_to_create: spot_orders_to_create__.unwrap_or_default(),
                    derivative_orders_to_create: derivative_orders_to_create__.unwrap_or_default(),
                    binary_options_orders_to_cancel: binary_options_orders_to_cancel__
                        .unwrap_or_default(),
                    binary_options_market_ids_to_cancel_all:
                        binary_options_market_ids_to_cancel_all__.unwrap_or_default(),
                    binary_options_orders_to_create: binary_options_orders_to_create__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchUpdateOrders",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgBatchUpdateOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.spot_cancel_success.is_empty() {
            len += 1;
        }
        if !self.derivative_cancel_success.is_empty() {
            len += 1;
        }
        if !self.spot_order_hashes.is_empty() {
            len += 1;
        }
        if !self.derivative_order_hashes.is_empty() {
            len += 1;
        }
        if !self.binary_options_cancel_success.is_empty() {
            len += 1;
        }
        if !self.binary_options_order_hashes.is_empty() {
            len += 1;
        }
        if !self.created_spot_orders_cids.is_empty() {
            len += 1;
        }
        if !self.failed_spot_orders_cids.is_empty() {
            len += 1;
        }
        if !self.created_derivative_orders_cids.is_empty() {
            len += 1;
        }
        if !self.failed_derivative_orders_cids.is_empty() {
            len += 1;
        }
        if !self.created_binary_options_orders_cids.is_empty() {
            len += 1;
        }
        if !self.failed_binary_options_orders_cids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse",
            len,
        )?;
        if !self.spot_cancel_success.is_empty() {
            struct_ser.serialize_field("spotCancelSuccess", &self.spot_cancel_success)?;
        }
        if !self.derivative_cancel_success.is_empty() {
            struct_ser
                .serialize_field("derivativeCancelSuccess", &self.derivative_cancel_success)?;
        }
        if !self.spot_order_hashes.is_empty() {
            struct_ser.serialize_field("spotOrderHashes", &self.spot_order_hashes)?;
        }
        if !self.derivative_order_hashes.is_empty() {
            struct_ser.serialize_field("derivativeOrderHashes", &self.derivative_order_hashes)?;
        }
        if !self.binary_options_cancel_success.is_empty() {
            struct_ser.serialize_field(
                "binaryOptionsCancelSuccess",
                &self.binary_options_cancel_success,
            )?;
        }
        if !self.binary_options_order_hashes.is_empty() {
            struct_ser.serialize_field(
                "binaryOptionsOrderHashes",
                &self.binary_options_order_hashes,
            )?;
        }
        if !self.created_spot_orders_cids.is_empty() {
            struct_ser.serialize_field("createdSpotOrdersCids", &self.created_spot_orders_cids)?;
        }
        if !self.failed_spot_orders_cids.is_empty() {
            struct_ser.serialize_field("failedSpotOrdersCids", &self.failed_spot_orders_cids)?;
        }
        if !self.created_derivative_orders_cids.is_empty() {
            struct_ser.serialize_field(
                "createdDerivativeOrdersCids",
                &self.created_derivative_orders_cids,
            )?;
        }
        if !self.failed_derivative_orders_cids.is_empty() {
            struct_ser.serialize_field(
                "failedDerivativeOrdersCids",
                &self.failed_derivative_orders_cids,
            )?;
        }
        if !self.created_binary_options_orders_cids.is_empty() {
            struct_ser.serialize_field(
                "createdBinaryOptionsOrdersCids",
                &self.created_binary_options_orders_cids,
            )?;
        }
        if !self.failed_binary_options_orders_cids.is_empty() {
            struct_ser.serialize_field(
                "failedBinaryOptionsOrdersCids",
                &self.failed_binary_options_orders_cids,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgBatchUpdateOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "spot_cancel_success",
            "spotCancelSuccess",
            "derivative_cancel_success",
            "derivativeCancelSuccess",
            "spot_order_hashes",
            "spotOrderHashes",
            "derivative_order_hashes",
            "derivativeOrderHashes",
            "binary_options_cancel_success",
            "binaryOptionsCancelSuccess",
            "binary_options_order_hashes",
            "binaryOptionsOrderHashes",
            "created_spot_orders_cids",
            "createdSpotOrdersCids",
            "failed_spot_orders_cids",
            "failedSpotOrdersCids",
            "created_derivative_orders_cids",
            "createdDerivativeOrdersCids",
            "failed_derivative_orders_cids",
            "failedDerivativeOrdersCids",
            "created_binary_options_orders_cids",
            "createdBinaryOptionsOrdersCids",
            "failed_binary_options_orders_cids",
            "failedBinaryOptionsOrdersCids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SpotCancelSuccess,
            DerivativeCancelSuccess,
            SpotOrderHashes,
            DerivativeOrderHashes,
            BinaryOptionsCancelSuccess,
            BinaryOptionsOrderHashes,
            CreatedSpotOrdersCids,
            FailedSpotOrdersCids,
            CreatedDerivativeOrdersCids,
            FailedDerivativeOrdersCids,
            CreatedBinaryOptionsOrdersCids,
            FailedBinaryOptionsOrdersCids,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "spotCancelSuccess" | "spot_cancel_success" => {
                                Ok(GeneratedField::SpotCancelSuccess)
                            }
                            "derivativeCancelSuccess" | "derivative_cancel_success" => {
                                Ok(GeneratedField::DerivativeCancelSuccess)
                            }
                            "spotOrderHashes" | "spot_order_hashes" => {
                                Ok(GeneratedField::SpotOrderHashes)
                            }
                            "derivativeOrderHashes" | "derivative_order_hashes" => {
                                Ok(GeneratedField::DerivativeOrderHashes)
                            }
                            "binaryOptionsCancelSuccess" | "binary_options_cancel_success" => {
                                Ok(GeneratedField::BinaryOptionsCancelSuccess)
                            }
                            "binaryOptionsOrderHashes" | "binary_options_order_hashes" => {
                                Ok(GeneratedField::BinaryOptionsOrderHashes)
                            }
                            "createdSpotOrdersCids" | "created_spot_orders_cids" => {
                                Ok(GeneratedField::CreatedSpotOrdersCids)
                            }
                            "failedSpotOrdersCids" | "failed_spot_orders_cids" => {
                                Ok(GeneratedField::FailedSpotOrdersCids)
                            }
                            "createdDerivativeOrdersCids" | "created_derivative_orders_cids" => {
                                Ok(GeneratedField::CreatedDerivativeOrdersCids)
                            }
                            "failedDerivativeOrdersCids" | "failed_derivative_orders_cids" => {
                                Ok(GeneratedField::FailedDerivativeOrdersCids)
                            }
                            "createdBinaryOptionsOrdersCids"
                            | "created_binary_options_orders_cids" => {
                                Ok(GeneratedField::CreatedBinaryOptionsOrdersCids)
                            }
                            "failedBinaryOptionsOrdersCids"
                            | "failed_binary_options_orders_cids" => {
                                Ok(GeneratedField::FailedBinaryOptionsOrdersCids)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgBatchUpdateOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgBatchUpdateOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut spot_cancel_success__ = None;
                let mut derivative_cancel_success__ = None;
                let mut spot_order_hashes__ = None;
                let mut derivative_order_hashes__ = None;
                let mut binary_options_cancel_success__ = None;
                let mut binary_options_order_hashes__ = None;
                let mut created_spot_orders_cids__ = None;
                let mut failed_spot_orders_cids__ = None;
                let mut created_derivative_orders_cids__ = None;
                let mut failed_derivative_orders_cids__ = None;
                let mut created_binary_options_orders_cids__ = None;
                let mut failed_binary_options_orders_cids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SpotCancelSuccess => {
                            if spot_cancel_success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spotCancelSuccess"));
                            }
                            spot_cancel_success__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeCancelSuccess => {
                            if derivative_cancel_success__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeCancelSuccess",
                                ));
                            }
                            derivative_cancel_success__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotOrderHashes => {
                            if spot_order_hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spotOrderHashes"));
                            }
                            spot_order_hashes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeOrderHashes => {
                            if derivative_order_hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeOrderHashes",
                                ));
                            }
                            derivative_order_hashes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsCancelSuccess => {
                            if binary_options_cancel_success__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsCancelSuccess",
                                ));
                            }
                            binary_options_cancel_success__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsOrderHashes => {
                            if binary_options_order_hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsOrderHashes",
                                ));
                            }
                            binary_options_order_hashes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CreatedSpotOrdersCids => {
                            if created_spot_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "createdSpotOrdersCids",
                                ));
                            }
                            created_spot_orders_cids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FailedSpotOrdersCids => {
                            if failed_spot_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "failedSpotOrdersCids",
                                ));
                            }
                            failed_spot_orders_cids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CreatedDerivativeOrdersCids => {
                            if created_derivative_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "createdDerivativeOrdersCids",
                                ));
                            }
                            created_derivative_orders_cids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FailedDerivativeOrdersCids => {
                            if failed_derivative_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "failedDerivativeOrdersCids",
                                ));
                            }
                            failed_derivative_orders_cids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CreatedBinaryOptionsOrdersCids => {
                            if created_binary_options_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "createdBinaryOptionsOrdersCids",
                                ));
                            }
                            created_binary_options_orders_cids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FailedBinaryOptionsOrdersCids => {
                            if failed_binary_options_orders_cids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "failedBinaryOptionsOrdersCids",
                                ));
                            }
                            failed_binary_options_orders_cids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgBatchUpdateOrdersResponse {
                    spot_cancel_success: spot_cancel_success__.unwrap_or_default(),
                    derivative_cancel_success: derivative_cancel_success__.unwrap_or_default(),
                    spot_order_hashes: spot_order_hashes__.unwrap_or_default(),
                    derivative_order_hashes: derivative_order_hashes__.unwrap_or_default(),
                    binary_options_cancel_success: binary_options_cancel_success__
                        .unwrap_or_default(),
                    binary_options_order_hashes: binary_options_order_hashes__.unwrap_or_default(),
                    created_spot_orders_cids: created_spot_orders_cids__.unwrap_or_default(),
                    failed_spot_orders_cids: failed_spot_orders_cids__.unwrap_or_default(),
                    created_derivative_orders_cids: created_derivative_orders_cids__
                        .unwrap_or_default(),
                    failed_derivative_orders_cids: failed_derivative_orders_cids__
                        .unwrap_or_default(),
                    created_binary_options_orders_cids: created_binary_options_orders_cids__
                        .unwrap_or_default(),
                    failed_binary_options_orders_cids: failed_binary_options_orders_cids__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCancelBinaryOptionsOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if self.order_mask != 0 {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if self.order_mask != 0 {
            struct_ser.serialize_field("orderMask", &self.order_mask)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCancelBinaryOptionsOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "order_hash",
            "orderHash",
            "order_mask",
            "orderMask",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            MarketId,
            SubaccountId,
            OrderHash,
            OrderMask,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "orderMask" | "order_mask" => Ok(GeneratedField::OrderMask),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCancelBinaryOptionsOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCancelBinaryOptionsOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut order_hash__ = None;
                let mut order_mask__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderMask => {
                            if order_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderMask"));
                            }
                            order_mask__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCancelBinaryOptionsOrder {
                    sender: sender__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    order_mask: order_mask__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCancelBinaryOptionsOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCancelBinaryOptionsOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCancelBinaryOptionsOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCancelBinaryOptionsOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgCancelBinaryOptionsOrderResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCancelDerivativeOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if self.order_mask != 0 {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgCancelDerivativeOrder", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if self.order_mask != 0 {
            struct_ser.serialize_field("orderMask", &self.order_mask)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCancelDerivativeOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "order_hash",
            "orderHash",
            "order_mask",
            "orderMask",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            MarketId,
            SubaccountId,
            OrderHash,
            OrderMask,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "orderMask" | "order_mask" => Ok(GeneratedField::OrderMask),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCancelDerivativeOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgCancelDerivativeOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCancelDerivativeOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut order_hash__ = None;
                let mut order_mask__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderMask => {
                            if order_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderMask"));
                            }
                            order_mask__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCancelDerivativeOrder {
                    sender: sender__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    order_mask: order_mask__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCancelDerivativeOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCancelDerivativeOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCancelDerivativeOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCancelDerivativeOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCancelDerivativeOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgCancelDerivativeOrderResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCancelSpotOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgCancelSpotOrder", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCancelSpotOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "order_hash",
            "orderHash",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            MarketId,
            SubaccountId,
            OrderHash,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCancelSpotOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgCancelSpotOrder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgCancelSpotOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut order_hash__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCancelSpotOrder {
                    sender: sender__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCancelSpotOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCancelSpotOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgCancelSpotOrderResponse", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCancelSpotOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCancelSpotOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgCancelSpotOrderResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCancelSpotOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgCancelSpotOrderResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCancelSpotOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateBinaryOptionsLimitOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateBinaryOptionsLimitOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "order"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateBinaryOptionsLimitOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateBinaryOptionsLimitOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgCreateBinaryOptionsLimitOrder {
                    sender: sender__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateBinaryOptionsLimitOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse",
            len,
        )?;
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateBinaryOptionsLimitOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["order_hash", "orderHash", "cid"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHash,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateBinaryOptionsLimitOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateBinaryOptionsLimitOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hash__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCreateBinaryOptionsLimitOrderResponse {
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateBinaryOptionsMarketOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateBinaryOptionsMarketOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "order"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateBinaryOptionsMarketOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateBinaryOptionsMarketOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgCreateBinaryOptionsMarketOrder {
                    sender: sender__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateBinaryOptionsMarketOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if self.results.is_some() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse",
            len,
        )?;
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if let Some(v) = self.results.as_ref() {
            struct_ser.serialize_field("results", v)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateBinaryOptionsMarketOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["order_hash", "orderHash", "results", "cid"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHash,
            Results,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "results" => Ok(GeneratedField::Results),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateBinaryOptionsMarketOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateBinaryOptionsMarketOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hash__ = None;
                let mut results__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Results => {
                            if results__.is_some() {
                                return Err(serde::de::Error::duplicate_field("results"));
                            }
                            results__ = map_.next_value()?;
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCreateBinaryOptionsMarketOrderResponse {
                    order_hash: order_hash__.unwrap_or_default(),
                    results: results__,
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateDerivativeLimitOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateDerivativeLimitOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "order"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateDerivativeLimitOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateDerivativeLimitOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgCreateDerivativeLimitOrder {
                    sender: sender__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateDerivativeLimitOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse",
            len,
        )?;
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateDerivativeLimitOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["order_hash", "orderHash", "cid"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHash,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateDerivativeLimitOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateDerivativeLimitOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hash__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCreateDerivativeLimitOrderResponse {
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateDerivativeMarketOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateDerivativeMarketOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "order"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateDerivativeMarketOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateDerivativeMarketOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgCreateDerivativeMarketOrder {
                    sender: sender__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateDerivativeMarketOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if self.results.is_some() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse",
            len,
        )?;
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if let Some(v) = self.results.as_ref() {
            struct_ser.serialize_field("results", v)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateDerivativeMarketOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["order_hash", "orderHash", "results", "cid"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHash,
            Results,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "results" => Ok(GeneratedField::Results),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateDerivativeMarketOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateDerivativeMarketOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hash__ = None;
                let mut results__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Results => {
                            if results__.is_some() {
                                return Err(serde::de::Error::duplicate_field("results"));
                            }
                            results__ = map_.next_value()?;
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCreateDerivativeMarketOrderResponse {
                    order_hash: order_hash__.unwrap_or_default(),
                    results: results__,
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateSpotLimitOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgCreateSpotLimitOrder", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateSpotLimitOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "order"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateSpotLimitOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgCreateSpotLimitOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateSpotLimitOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgCreateSpotLimitOrder {
                    sender: sender__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateSpotLimitOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateSpotLimitOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse",
            len,
        )?;
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateSpotLimitOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["order_hash", "orderHash", "cid"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHash,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateSpotLimitOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateSpotLimitOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hash__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCreateSpotLimitOrderResponse {
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateSpotMarketOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgCreateSpotMarketOrder", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateSpotMarketOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "order"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateSpotMarketOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgCreateSpotMarketOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateSpotMarketOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgCreateSpotMarketOrder {
                    sender: sender__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateSpotMarketOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgCreateSpotMarketOrderResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if self.results.is_some() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse",
            len,
        )?;
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if let Some(v) = self.results.as_ref() {
            struct_ser.serialize_field("results", v)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgCreateSpotMarketOrderResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["order_hash", "orderHash", "results", "cid"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderHash,
            Results,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "results" => Ok(GeneratedField::Results),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgCreateSpotMarketOrderResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgCreateSpotMarketOrderResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_hash__ = None;
                let mut results__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Results => {
                            if results__.is_some() {
                                return Err(serde::de::Error::duplicate_field("results"));
                            }
                            results__ = map_.next_value()?;
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgCreateSpotMarketOrderResponse {
                    order_hash: order_hash__.unwrap_or_default(),
                    results: results__,
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgDecreasePositionMargin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.source_subaccount_id.is_empty() {
            len += 1;
        }
        if !self.destination_subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.amount.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgDecreasePositionMargin", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.source_subaccount_id.is_empty() {
            struct_ser.serialize_field("sourceSubaccountId", &self.source_subaccount_id)?;
        }
        if !self.destination_subaccount_id.is_empty() {
            struct_ser
                .serialize_field("destinationSubaccountId", &self.destination_subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.amount.is_empty() {
            struct_ser.serialize_field("amount", &self.amount)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgDecreasePositionMargin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "source_subaccount_id",
            "sourceSubaccountId",
            "destination_subaccount_id",
            "destinationSubaccountId",
            "market_id",
            "marketId",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SourceSubaccountId,
            DestinationSubaccountId,
            MarketId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "sourceSubaccountId" | "source_subaccount_id" => {
                                Ok(GeneratedField::SourceSubaccountId)
                            }
                            "destinationSubaccountId" | "destination_subaccount_id" => {
                                Ok(GeneratedField::DestinationSubaccountId)
                            }
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgDecreasePositionMargin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgDecreasePositionMargin")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgDecreasePositionMargin, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut source_subaccount_id__ = None;
                let mut destination_subaccount_id__ = None;
                let mut market_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SourceSubaccountId => {
                            if source_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "sourceSubaccountId",
                                ));
                            }
                            source_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DestinationSubaccountId => {
                            if destination_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "destinationSubaccountId",
                                ));
                            }
                            destination_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgDecreasePositionMargin {
                    sender: sender__.unwrap_or_default(),
                    source_subaccount_id: source_subaccount_id__.unwrap_or_default(),
                    destination_subaccount_id: destination_subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    amount: amount__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgDecreasePositionMargin",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgDecreasePositionMarginResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgDecreasePositionMarginResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgDecreasePositionMarginResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgDecreasePositionMarginResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgDecreasePositionMarginResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgDecreasePositionMarginResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgDecreasePositionMarginResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgDecreasePositionMarginResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgDeposit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgDeposit", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgDeposit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "subaccount_id", "subaccountId", "amount"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SubaccountId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgDeposit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgDeposit")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgDeposit, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut subaccount_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgDeposit {
                    sender: sender__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgDeposit",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgDepositResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgDepositResponse", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgDepositResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgDepositResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgDepositResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgDepositResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgDepositResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgDepositResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgEmergencySettleMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgEmergencySettleMarket", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgEmergencySettleMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "subaccount_id",
            "subaccountId",
            "market_id",
            "marketId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SubaccountId,
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgEmergencySettleMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgEmergencySettleMarket")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgEmergencySettleMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut subaccount_id__ = None;
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgEmergencySettleMarket {
                    sender: sender__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgEmergencySettleMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgEmergencySettleMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgEmergencySettleMarketResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgEmergencySettleMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgEmergencySettleMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgEmergencySettleMarketResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgEmergencySettleMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgEmergencySettleMarketResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgEmergencySettleMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgExternalTransfer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.source_subaccount_id.is_empty() {
            len += 1;
        }
        if !self.destination_subaccount_id.is_empty() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgExternalTransfer", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.source_subaccount_id.is_empty() {
            struct_ser.serialize_field("sourceSubaccountId", &self.source_subaccount_id)?;
        }
        if !self.destination_subaccount_id.is_empty() {
            struct_ser
                .serialize_field("destinationSubaccountId", &self.destination_subaccount_id)?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgExternalTransfer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "source_subaccount_id",
            "sourceSubaccountId",
            "destination_subaccount_id",
            "destinationSubaccountId",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SourceSubaccountId,
            DestinationSubaccountId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "sourceSubaccountId" | "source_subaccount_id" => {
                                Ok(GeneratedField::SourceSubaccountId)
                            }
                            "destinationSubaccountId" | "destination_subaccount_id" => {
                                Ok(GeneratedField::DestinationSubaccountId)
                            }
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgExternalTransfer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgExternalTransfer")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgExternalTransfer, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut source_subaccount_id__ = None;
                let mut destination_subaccount_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SourceSubaccountId => {
                            if source_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "sourceSubaccountId",
                                ));
                            }
                            source_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DestinationSubaccountId => {
                            if destination_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "destinationSubaccountId",
                                ));
                            }
                            destination_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgExternalTransfer {
                    sender: sender__.unwrap_or_default(),
                    source_subaccount_id: source_subaccount_id__.unwrap_or_default(),
                    destination_subaccount_id: destination_subaccount_id__.unwrap_or_default(),
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgExternalTransfer",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgExternalTransferResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgExternalTransferResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgExternalTransferResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgExternalTransferResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgExternalTransferResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgExternalTransferResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgExternalTransferResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgExternalTransferResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgIncreasePositionMargin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.source_subaccount_id.is_empty() {
            len += 1;
        }
        if !self.destination_subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.amount.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgIncreasePositionMargin", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.source_subaccount_id.is_empty() {
            struct_ser.serialize_field("sourceSubaccountId", &self.source_subaccount_id)?;
        }
        if !self.destination_subaccount_id.is_empty() {
            struct_ser
                .serialize_field("destinationSubaccountId", &self.destination_subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.amount.is_empty() {
            struct_ser.serialize_field("amount", &self.amount)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgIncreasePositionMargin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "source_subaccount_id",
            "sourceSubaccountId",
            "destination_subaccount_id",
            "destinationSubaccountId",
            "market_id",
            "marketId",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SourceSubaccountId,
            DestinationSubaccountId,
            MarketId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "sourceSubaccountId" | "source_subaccount_id" => {
                                Ok(GeneratedField::SourceSubaccountId)
                            }
                            "destinationSubaccountId" | "destination_subaccount_id" => {
                                Ok(GeneratedField::DestinationSubaccountId)
                            }
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgIncreasePositionMargin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgIncreasePositionMargin")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgIncreasePositionMargin, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut source_subaccount_id__ = None;
                let mut destination_subaccount_id__ = None;
                let mut market_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SourceSubaccountId => {
                            if source_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "sourceSubaccountId",
                                ));
                            }
                            source_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DestinationSubaccountId => {
                            if destination_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "destinationSubaccountId",
                                ));
                            }
                            destination_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgIncreasePositionMargin {
                    sender: sender__.unwrap_or_default(),
                    source_subaccount_id: source_subaccount_id__.unwrap_or_default(),
                    destination_subaccount_id: destination_subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    amount: amount__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgIncreasePositionMargin",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgIncreasePositionMarginResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgIncreasePositionMarginResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgIncreasePositionMarginResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgIncreasePositionMarginResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgIncreasePositionMarginResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgIncreasePositionMarginResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgIncreasePositionMarginResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgIncreasePositionMarginResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantBinaryOptionsMarketLaunch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.oracle_symbol.is_empty() {
            len += 1;
        }
        if !self.oracle_provider.is_empty() {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if self.expiration_timestamp != 0 {
            len += 1;
        }
        if self.settlement_timestamp != 0 {
            len += 1;
        }
        if !self.admin.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.oracle_symbol.is_empty() {
            struct_ser.serialize_field("oracleSymbol", &self.oracle_symbol)?;
        }
        if !self.oracle_provider.is_empty() {
            struct_ser.serialize_field("oracleProvider", &self.oracle_provider)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if self.expiration_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "expirationTimestamp",
                ToString::to_string(&self.expiration_timestamp).as_str(),
            )?;
        }
        if self.settlement_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "settlementTimestamp",
                ToString::to_string(&self.settlement_timestamp).as_str(),
            )?;
        }
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantBinaryOptionsMarketLaunch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "ticker",
            "oracle_symbol",
            "oracleSymbol",
            "oracle_provider",
            "oracleProvider",
            "oracle_type",
            "oracleType",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "expiration_timestamp",
            "expirationTimestamp",
            "settlement_timestamp",
            "settlementTimestamp",
            "admin",
            "quote_denom",
            "quoteDenom",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Ticker,
            OracleSymbol,
            OracleProvider,
            OracleType,
            OracleScaleFactor,
            MakerFeeRate,
            TakerFeeRate,
            ExpirationTimestamp,
            SettlementTimestamp,
            Admin,
            QuoteDenom,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "oracleSymbol" | "oracle_symbol" => Ok(GeneratedField::OracleSymbol),
                            "oracleProvider" | "oracle_provider" => {
                                Ok(GeneratedField::OracleProvider)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "expirationTimestamp" | "expiration_timestamp" => {
                                Ok(GeneratedField::ExpirationTimestamp)
                            }
                            "settlementTimestamp" | "settlement_timestamp" => {
                                Ok(GeneratedField::SettlementTimestamp)
                            }
                            "admin" => Ok(GeneratedField::Admin),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantBinaryOptionsMarketLaunch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantBinaryOptionsMarketLaunch, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut ticker__ = None;
                let mut oracle_symbol__ = None;
                let mut oracle_provider__ = None;
                let mut oracle_type__ = None;
                let mut oracle_scale_factor__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut expiration_timestamp__ = None;
                let mut settlement_timestamp__ = None;
                let mut admin__ = None;
                let mut quote_denom__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleSymbol => {
                            if oracle_symbol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleSymbol"));
                            }
                            oracle_symbol__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleProvider => {
                            if oracle_provider__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleProvider"));
                            }
                            oracle_provider__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpirationTimestamp => {
                            if expiration_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "expirationTimestamp",
                                ));
                            }
                            expiration_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::SettlementTimestamp => {
                            if settlement_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "settlementTimestamp",
                                ));
                            }
                            settlement_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgInstantBinaryOptionsMarketLaunch {
                    sender: sender__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    oracle_symbol: oracle_symbol__.unwrap_or_default(),
                    oracle_provider: oracle_provider__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    expiration_timestamp: expiration_timestamp__.unwrap_or_default(),
                    settlement_timestamp: settlement_timestamp__.unwrap_or_default(),
                    admin: admin__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantBinaryOptionsMarketLaunchResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantBinaryOptionsMarketLaunchResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantBinaryOptionsMarketLaunchResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantBinaryOptionsMarketLaunchResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgInstantBinaryOptionsMarketLaunchResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantExpiryFuturesMarketLaunch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.oracle_base.is_empty() {
            len += 1;
        }
        if !self.oracle_quote.is_empty() {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.expiry != 0 {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            struct_ser.serialize_field("oracleBase", &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            struct_ser.serialize_field("oracleQuote", &self.oracle_quote)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.expiry != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("expiry", ToString::to_string(&self.expiry).as_str())?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            struct_ser.serialize_field("initialMarginRatio", &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field("maintenanceMarginRatio", &self.maintenance_margin_ratio)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantExpiryFuturesMarketLaunch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "ticker",
            "quote_denom",
            "quoteDenom",
            "oracle_base",
            "oracleBase",
            "oracle_quote",
            "oracleQuote",
            "oracle_type",
            "oracleType",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "expiry",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "initial_margin_ratio",
            "initialMarginRatio",
            "maintenance_margin_ratio",
            "maintenanceMarginRatio",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Ticker,
            QuoteDenom,
            OracleBase,
            OracleQuote,
            OracleType,
            OracleScaleFactor,
            Expiry,
            MakerFeeRate,
            TakerFeeRate,
            InitialMarginRatio,
            MaintenanceMarginRatio,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "oracleBase" | "oracle_base" => Ok(GeneratedField::OracleBase),
                            "oracleQuote" | "oracle_quote" => Ok(GeneratedField::OracleQuote),
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "expiry" => Ok(GeneratedField::Expiry),
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "initialMarginRatio" | "initial_margin_ratio" => {
                                Ok(GeneratedField::InitialMarginRatio)
                            }
                            "maintenanceMarginRatio" | "maintenance_margin_ratio" => {
                                Ok(GeneratedField::MaintenanceMarginRatio)
                            }
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantExpiryFuturesMarketLaunch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantExpiryFuturesMarketLaunch, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut ticker__ = None;
                let mut quote_denom__ = None;
                let mut oracle_base__ = None;
                let mut oracle_quote__ = None;
                let mut oracle_type__ = None;
                let mut oracle_scale_factor__ = None;
                let mut expiry__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut initial_margin_ratio__ = None;
                let mut maintenance_margin_ratio__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleBase => {
                            if oracle_base__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleBase"));
                            }
                            oracle_base__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleQuote => {
                            if oracle_quote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleQuote"));
                            }
                            oracle_quote__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Expiry => {
                            if expiry__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expiry"));
                            }
                            expiry__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InitialMarginRatio => {
                            if initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "initialMarginRatio",
                                ));
                            }
                            initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaintenanceMarginRatio => {
                            if maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maintenanceMarginRatio",
                                ));
                            }
                            maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgInstantExpiryFuturesMarketLaunch {
                    sender: sender__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    oracle_base: oracle_base__.unwrap_or_default(),
                    oracle_quote: oracle_quote__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    expiry: expiry__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    initial_margin_ratio: initial_margin_ratio__.unwrap_or_default(),
                    maintenance_margin_ratio: maintenance_margin_ratio__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantExpiryFuturesMarketLaunchResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantExpiryFuturesMarketLaunchResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantExpiryFuturesMarketLaunchResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantExpiryFuturesMarketLaunchResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgInstantExpiryFuturesMarketLaunchResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantPerpetualMarketLaunch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.oracle_base.is_empty() {
            len += 1;
        }
        if !self.oracle_quote.is_empty() {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            struct_ser.serialize_field("oracleBase", &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            struct_ser.serialize_field("oracleQuote", &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            struct_ser.serialize_field("initialMarginRatio", &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field("maintenanceMarginRatio", &self.maintenance_margin_ratio)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantPerpetualMarketLaunch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "ticker",
            "quote_denom",
            "quoteDenom",
            "oracle_base",
            "oracleBase",
            "oracle_quote",
            "oracleQuote",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "oracle_type",
            "oracleType",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "initial_margin_ratio",
            "initialMarginRatio",
            "maintenance_margin_ratio",
            "maintenanceMarginRatio",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Ticker,
            QuoteDenom,
            OracleBase,
            OracleQuote,
            OracleScaleFactor,
            OracleType,
            MakerFeeRate,
            TakerFeeRate,
            InitialMarginRatio,
            MaintenanceMarginRatio,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "oracleBase" | "oracle_base" => Ok(GeneratedField::OracleBase),
                            "oracleQuote" | "oracle_quote" => Ok(GeneratedField::OracleQuote),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "initialMarginRatio" | "initial_margin_ratio" => {
                                Ok(GeneratedField::InitialMarginRatio)
                            }
                            "maintenanceMarginRatio" | "maintenance_margin_ratio" => {
                                Ok(GeneratedField::MaintenanceMarginRatio)
                            }
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantPerpetualMarketLaunch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantPerpetualMarketLaunch, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut ticker__ = None;
                let mut quote_denom__ = None;
                let mut oracle_base__ = None;
                let mut oracle_quote__ = None;
                let mut oracle_scale_factor__ = None;
                let mut oracle_type__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut initial_margin_ratio__ = None;
                let mut maintenance_margin_ratio__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleBase => {
                            if oracle_base__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleBase"));
                            }
                            oracle_base__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleQuote => {
                            if oracle_quote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleQuote"));
                            }
                            oracle_quote__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InitialMarginRatio => {
                            if initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "initialMarginRatio",
                                ));
                            }
                            initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaintenanceMarginRatio => {
                            if maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maintenanceMarginRatio",
                                ));
                            }
                            maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgInstantPerpetualMarketLaunch {
                    sender: sender__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    oracle_base: oracle_base__.unwrap_or_default(),
                    oracle_quote: oracle_quote__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    initial_margin_ratio: initial_margin_ratio__.unwrap_or_default(),
                    maintenance_margin_ratio: maintenance_margin_ratio__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantPerpetualMarketLaunchResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantPerpetualMarketLaunchResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantPerpetualMarketLaunchResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantPerpetualMarketLaunchResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgInstantPerpetualMarketLaunchResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantSpotMarketLaunch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.base_denom.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgInstantSpotMarketLaunch", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.base_denom.is_empty() {
            struct_ser.serialize_field("baseDenom", &self.base_denom)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantSpotMarketLaunch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "ticker",
            "base_denom",
            "baseDenom",
            "quote_denom",
            "quoteDenom",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Ticker,
            BaseDenom,
            QuoteDenom,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "baseDenom" | "base_denom" => Ok(GeneratedField::BaseDenom),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantSpotMarketLaunch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgInstantSpotMarketLaunch")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantSpotMarketLaunch, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut ticker__ = None;
                let mut base_denom__ = None;
                let mut quote_denom__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BaseDenom => {
                            if base_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("baseDenom"));
                            }
                            base_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgInstantSpotMarketLaunch {
                    sender: sender__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    base_denom: base_denom__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantSpotMarketLaunch",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgInstantSpotMarketLaunchResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgInstantSpotMarketLaunchResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgInstantSpotMarketLaunchResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgInstantSpotMarketLaunchResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgInstantSpotMarketLaunchResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgLiquidatePosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgLiquidatePosition", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgLiquidatePosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "subaccount_id",
            "subaccountId",
            "market_id",
            "marketId",
            "order",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SubaccountId,
            MarketId,
            Order,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgLiquidatePosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgLiquidatePosition")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgLiquidatePosition, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut subaccount_id__ = None;
                let mut market_id__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgLiquidatePosition {
                    sender: sender__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgLiquidatePosition",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgLiquidatePositionResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgLiquidatePositionResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgLiquidatePositionResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgLiquidatePositionResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgLiquidatePositionResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgLiquidatePositionResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgLiquidatePositionResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgLiquidatePositionResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgPrivilegedExecuteContract {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.funds.is_empty() {
            len += 1;
        }
        if !self.contract_address.is_empty() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgPrivilegedExecuteContract",
            len,
        )?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.funds.is_empty() {
            struct_ser.serialize_field("funds", &self.funds)?;
        }
        if !self.contract_address.is_empty() {
            struct_ser.serialize_field("contractAddress", &self.contract_address)?;
        }
        if !self.data.is_empty() {
            struct_ser.serialize_field("data", &self.data)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgPrivilegedExecuteContract {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "funds",
            "contract_address",
            "contractAddress",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            Funds,
            ContractAddress,
            Data,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "funds" => Ok(GeneratedField::Funds),
                            "contractAddress" | "contract_address" => {
                                Ok(GeneratedField::ContractAddress)
                            }
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgPrivilegedExecuteContract;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgPrivilegedExecuteContract")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgPrivilegedExecuteContract, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut funds__ = None;
                let mut contract_address__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funds => {
                            if funds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funds"));
                            }
                            funds__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ContractAddress => {
                            if contract_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contractAddress"));
                            }
                            contract_address__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgPrivilegedExecuteContract {
                    sender: sender__.unwrap_or_default(),
                    funds: funds__.unwrap_or_default(),
                    contract_address: contract_address__.unwrap_or_default(),
                    data: data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgPrivilegedExecuteContract",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgPrivilegedExecuteContractResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.funds_diff.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse",
            len,
        )?;
        if !self.funds_diff.is_empty() {
            struct_ser.serialize_field("fundsDiff", &self.funds_diff)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgPrivilegedExecuteContractResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["funds_diff", "fundsDiff"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FundsDiff,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fundsDiff" | "funds_diff" => Ok(GeneratedField::FundsDiff),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgPrivilegedExecuteContractResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgPrivilegedExecuteContractResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut funds_diff__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FundsDiff => {
                            if funds_diff__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fundsDiff"));
                            }
                            funds_diff__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgPrivilegedExecuteContractResponse {
                    funds_diff: funds_diff__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgReclaimLockedFunds {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.locked_account_pub_key.is_empty() {
            len += 1;
        }
        if !self.signature.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgReclaimLockedFunds", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.locked_account_pub_key.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "lockedAccountPubKey",
                pbjson::private::base64::encode(&self.locked_account_pub_key).as_str(),
            )?;
        }
        if !self.signature.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "signature",
                pbjson::private::base64::encode(&self.signature).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgReclaimLockedFunds {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "lockedAccountPubKey", "signature"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            LockedAccountPubKey,
            Signature,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "lockedAccountPubKey" => Ok(GeneratedField::LockedAccountPubKey),
                            "signature" => Ok(GeneratedField::Signature),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgReclaimLockedFunds;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgReclaimLockedFunds")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgReclaimLockedFunds, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut locked_account_pub_key__ = None;
                let mut signature__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LockedAccountPubKey => {
                            if locked_account_pub_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "lockedAccountPubKey",
                                ));
                            }
                            locked_account_pub_key__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(MsgReclaimLockedFunds {
                    sender: sender__.unwrap_or_default(),
                    locked_account_pub_key: locked_account_pub_key__.unwrap_or_default(),
                    signature: signature__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgReclaimLockedFunds",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgReclaimLockedFundsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgReclaimLockedFundsResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgReclaimLockedFundsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgReclaimLockedFundsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgReclaimLockedFundsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgReclaimLockedFundsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgReclaimLockedFundsResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgReclaimLockedFundsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgRewardsOptOut {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgRewardsOptOut", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgRewardsOptOut {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgRewardsOptOut;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgRewardsOptOut")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgRewardsOptOut, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgRewardsOptOut {
                    sender: sender__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgRewardsOptOut",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgRewardsOptOutResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgRewardsOptOutResponse", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgRewardsOptOutResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgRewardsOptOutResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgRewardsOptOutResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgRewardsOptOutResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgRewardsOptOutResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgRewardsOptOutResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgSignData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.signer.is_empty() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgSignData", len)?;
        if !self.signer.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "Signer",
                pbjson::private::base64::encode(&self.signer).as_str(),
            )?;
        }
        if !self.data.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser
                .serialize_field("Data", pbjson::private::base64::encode(&self.data).as_str())?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgSignData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["Signer", "Data"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Signer,
            Data,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Signer" => Ok(GeneratedField::Signer),
                            "Data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgSignData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgSignData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgSignData, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut signer__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Signer => {
                            if signer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Signer"));
                            }
                            signer__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Data"));
                            }
                            data__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(MsgSignData {
                    signer: signer__.unwrap_or_default(),
                    data: data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgSignData",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgSignDoc {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sign_type.is_empty() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgSignDoc", len)?;
        if !self.sign_type.is_empty() {
            struct_ser.serialize_field("signType", &self.sign_type)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgSignDoc {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sign_type", "signType", "value"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SignType,
            Value,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "signType" | "sign_type" => Ok(GeneratedField::SignType),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgSignDoc;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgSignDoc")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgSignDoc, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sign_type__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SignType => {
                            if sign_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signType"));
                            }
                            sign_type__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgSignDoc {
                    sign_type: sign_type__.unwrap_or_default(),
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgSignDoc",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgSubaccountTransfer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.source_subaccount_id.is_empty() {
            len += 1;
        }
        if !self.destination_subaccount_id.is_empty() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgSubaccountTransfer", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.source_subaccount_id.is_empty() {
            struct_ser.serialize_field("sourceSubaccountId", &self.source_subaccount_id)?;
        }
        if !self.destination_subaccount_id.is_empty() {
            struct_ser
                .serialize_field("destinationSubaccountId", &self.destination_subaccount_id)?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgSubaccountTransfer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sender",
            "source_subaccount_id",
            "sourceSubaccountId",
            "destination_subaccount_id",
            "destinationSubaccountId",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SourceSubaccountId,
            DestinationSubaccountId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "sourceSubaccountId" | "source_subaccount_id" => {
                                Ok(GeneratedField::SourceSubaccountId)
                            }
                            "destinationSubaccountId" | "destination_subaccount_id" => {
                                Ok(GeneratedField::DestinationSubaccountId)
                            }
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgSubaccountTransfer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgSubaccountTransfer")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgSubaccountTransfer, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut source_subaccount_id__ = None;
                let mut destination_subaccount_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SourceSubaccountId => {
                            if source_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "sourceSubaccountId",
                                ));
                            }
                            source_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DestinationSubaccountId => {
                            if destination_subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "destinationSubaccountId",
                                ));
                            }
                            destination_subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgSubaccountTransfer {
                    sender: sender__.unwrap_or_default(),
                    source_subaccount_id: source_subaccount_id__.unwrap_or_default(),
                    destination_subaccount_id: destination_subaccount_id__.unwrap_or_default(),
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgSubaccountTransfer",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgSubaccountTransferResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgSubaccountTransferResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgSubaccountTransferResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgSubaccountTransferResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.MsgSubaccountTransferResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgSubaccountTransferResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgSubaccountTransferResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgSubaccountTransferResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgUpdateDerivativeMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.admin.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.new_ticker.is_empty() {
            len += 1;
        }
        if !self.new_min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.new_min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.new_min_notional.is_empty() {
            len += 1;
        }
        if !self.new_initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.new_maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgUpdateDerivativeMarket", len)?;
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.new_ticker.is_empty() {
            struct_ser.serialize_field("newTicker", &self.new_ticker)?;
        }
        if !self.new_min_price_tick_size.is_empty() {
            struct_ser.serialize_field("newMinPriceTickSize", &self.new_min_price_tick_size)?;
        }
        if !self.new_min_quantity_tick_size.is_empty() {
            struct_ser
                .serialize_field("newMinQuantityTickSize", &self.new_min_quantity_tick_size)?;
        }
        if !self.new_min_notional.is_empty() {
            struct_ser.serialize_field("newMinNotional", &self.new_min_notional)?;
        }
        if !self.new_initial_margin_ratio.is_empty() {
            struct_ser.serialize_field("newInitialMarginRatio", &self.new_initial_margin_ratio)?;
        }
        if !self.new_maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field(
                "newMaintenanceMarginRatio",
                &self.new_maintenance_margin_ratio,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgUpdateDerivativeMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "admin",
            "market_id",
            "marketId",
            "new_ticker",
            "newTicker",
            "new_min_price_tick_size",
            "newMinPriceTickSize",
            "new_min_quantity_tick_size",
            "newMinQuantityTickSize",
            "new_min_notional",
            "newMinNotional",
            "new_initial_margin_ratio",
            "newInitialMarginRatio",
            "new_maintenance_margin_ratio",
            "newMaintenanceMarginRatio",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Admin,
            MarketId,
            NewTicker,
            NewMinPriceTickSize,
            NewMinQuantityTickSize,
            NewMinNotional,
            NewInitialMarginRatio,
            NewMaintenanceMarginRatio,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "admin" => Ok(GeneratedField::Admin),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "newTicker" | "new_ticker" => Ok(GeneratedField::NewTicker),
                            "newMinPriceTickSize" | "new_min_price_tick_size" => {
                                Ok(GeneratedField::NewMinPriceTickSize)
                            }
                            "newMinQuantityTickSize" | "new_min_quantity_tick_size" => {
                                Ok(GeneratedField::NewMinQuantityTickSize)
                            }
                            "newMinNotional" | "new_min_notional" => {
                                Ok(GeneratedField::NewMinNotional)
                            }
                            "newInitialMarginRatio" | "new_initial_margin_ratio" => {
                                Ok(GeneratedField::NewInitialMarginRatio)
                            }
                            "newMaintenanceMarginRatio" | "new_maintenance_margin_ratio" => {
                                Ok(GeneratedField::NewMaintenanceMarginRatio)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgUpdateDerivativeMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgUpdateDerivativeMarket")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgUpdateDerivativeMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut admin__ = None;
                let mut market_id__ = None;
                let mut new_ticker__ = None;
                let mut new_min_price_tick_size__ = None;
                let mut new_min_quantity_tick_size__ = None;
                let mut new_min_notional__ = None;
                let mut new_initial_margin_ratio__ = None;
                let mut new_maintenance_margin_ratio__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewTicker => {
                            if new_ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newTicker"));
                            }
                            new_ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewMinPriceTickSize => {
                            if new_min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "newMinPriceTickSize",
                                ));
                            }
                            new_min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewMinQuantityTickSize => {
                            if new_min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "newMinQuantityTickSize",
                                ));
                            }
                            new_min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewMinNotional => {
                            if new_min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newMinNotional"));
                            }
                            new_min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewInitialMarginRatio => {
                            if new_initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "newInitialMarginRatio",
                                ));
                            }
                            new_initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewMaintenanceMarginRatio => {
                            if new_maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "newMaintenanceMarginRatio",
                                ));
                            }
                            new_maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgUpdateDerivativeMarket {
                    admin: admin__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    new_ticker: new_ticker__.unwrap_or_default(),
                    new_min_price_tick_size: new_min_price_tick_size__.unwrap_or_default(),
                    new_min_quantity_tick_size: new_min_quantity_tick_size__.unwrap_or_default(),
                    new_min_notional: new_min_notional__.unwrap_or_default(),
                    new_initial_margin_ratio: new_initial_margin_ratio__.unwrap_or_default(),
                    new_maintenance_margin_ratio: new_maintenance_margin_ratio__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgUpdateDerivativeMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgUpdateDerivativeMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgUpdateDerivativeMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgUpdateDerivativeMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgUpdateDerivativeMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgUpdateDerivativeMarketResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgUpdateParams {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.authority.is_empty() {
            len += 1;
        }
        if self.params.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgUpdateParams", len)?;
        if !self.authority.is_empty() {
            struct_ser.serialize_field("authority", &self.authority)?;
        }
        if let Some(v) = self.params.as_ref() {
            struct_ser.serialize_field("params", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgUpdateParams {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["authority", "params"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Authority,
            Params,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "authority" => Ok(GeneratedField::Authority),
                            "params" => Ok(GeneratedField::Params),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgUpdateParams;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgUpdateParams")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgUpdateParams, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut authority__ = None;
                let mut params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Authority => {
                            if authority__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authority"));
                            }
                            authority__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Params => {
                            if params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("params"));
                            }
                            params__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgUpdateParams {
                    authority: authority__.unwrap_or_default(),
                    params: params__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgUpdateParams",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgUpdateParamsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.MsgUpdateParamsResponse", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgUpdateParamsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgUpdateParamsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgUpdateParamsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgUpdateParamsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgUpdateParamsResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgUpdateParamsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgUpdateSpotMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.admin.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.new_ticker.is_empty() {
            len += 1;
        }
        if !self.new_min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.new_min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.new_min_notional.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgUpdateSpotMarket", len)?;
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.new_ticker.is_empty() {
            struct_ser.serialize_field("newTicker", &self.new_ticker)?;
        }
        if !self.new_min_price_tick_size.is_empty() {
            struct_ser.serialize_field("newMinPriceTickSize", &self.new_min_price_tick_size)?;
        }
        if !self.new_min_quantity_tick_size.is_empty() {
            struct_ser
                .serialize_field("newMinQuantityTickSize", &self.new_min_quantity_tick_size)?;
        }
        if !self.new_min_notional.is_empty() {
            struct_ser.serialize_field("newMinNotional", &self.new_min_notional)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgUpdateSpotMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "admin",
            "market_id",
            "marketId",
            "new_ticker",
            "newTicker",
            "new_min_price_tick_size",
            "newMinPriceTickSize",
            "new_min_quantity_tick_size",
            "newMinQuantityTickSize",
            "new_min_notional",
            "newMinNotional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Admin,
            MarketId,
            NewTicker,
            NewMinPriceTickSize,
            NewMinQuantityTickSize,
            NewMinNotional,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "admin" => Ok(GeneratedField::Admin),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "newTicker" | "new_ticker" => Ok(GeneratedField::NewTicker),
                            "newMinPriceTickSize" | "new_min_price_tick_size" => {
                                Ok(GeneratedField::NewMinPriceTickSize)
                            }
                            "newMinQuantityTickSize" | "new_min_quantity_tick_size" => {
                                Ok(GeneratedField::NewMinQuantityTickSize)
                            }
                            "newMinNotional" | "new_min_notional" => {
                                Ok(GeneratedField::NewMinNotional)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgUpdateSpotMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgUpdateSpotMarket")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgUpdateSpotMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut admin__ = None;
                let mut market_id__ = None;
                let mut new_ticker__ = None;
                let mut new_min_price_tick_size__ = None;
                let mut new_min_quantity_tick_size__ = None;
                let mut new_min_notional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewTicker => {
                            if new_ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newTicker"));
                            }
                            new_ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewMinPriceTickSize => {
                            if new_min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "newMinPriceTickSize",
                                ));
                            }
                            new_min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewMinQuantityTickSize => {
                            if new_min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "newMinQuantityTickSize",
                                ));
                            }
                            new_min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewMinNotional => {
                            if new_min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newMinNotional"));
                            }
                            new_min_notional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MsgUpdateSpotMarket {
                    admin: admin__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    new_ticker: new_ticker__.unwrap_or_default(),
                    new_min_price_tick_size: new_min_price_tick_size__.unwrap_or_default(),
                    new_min_quantity_tick_size: new_min_quantity_tick_size__.unwrap_or_default(),
                    new_min_notional: new_min_notional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgUpdateSpotMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgUpdateSpotMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.MsgUpdateSpotMarketResponse",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgUpdateSpotMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgUpdateSpotMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgUpdateSpotMarketResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<MsgUpdateSpotMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgUpdateSpotMarketResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgUpdateSpotMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgWithdraw {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sender.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgWithdraw", len)?;
        if !self.sender.is_empty() {
            struct_ser.serialize_field("sender", &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgWithdraw {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sender", "subaccount_id", "subaccountId", "amount"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sender,
            SubaccountId,
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sender" => Ok(GeneratedField::Sender),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgWithdraw;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgWithdraw")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgWithdraw, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sender__ = None;
                let mut subaccount_id__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MsgWithdraw {
                    sender: sender__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgWithdraw",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for MsgWithdrawResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.MsgWithdrawResponse", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for MsgWithdrawResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MsgWithdrawResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.MsgWithdrawResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MsgWithdrawResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MsgWithdrawResponse {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.MsgWithdrawResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for NextFundingTimestamp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.next_timestamp != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.NextFundingTimestamp", len)?;
        if self.next_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "nextTimestamp",
                ToString::to_string(&self.next_timestamp).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for NextFundingTimestamp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["next_timestamp", "nextTimestamp"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NextTimestamp,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nextTimestamp" | "next_timestamp" => Ok(GeneratedField::NextTimestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NextFundingTimestamp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.NextFundingTimestamp")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<NextFundingTimestamp, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut next_timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NextTimestamp => {
                            if next_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextTimestamp"));
                            }
                            next_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(NextFundingTimestamp {
                    next_timestamp: next_timestamp__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.NextFundingTimestamp",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OracleParams {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.oracle_base.is_empty() {
            len += 1;
        }
        if !self.oracle_quote.is_empty() {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.OracleParams", len)?;
        if !self.oracle_base.is_empty() {
            struct_ser.serialize_field("oracleBase", &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            struct_ser.serialize_field("oracleQuote", &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OracleParams {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "oracle_base",
            "oracleBase",
            "oracle_quote",
            "oracleQuote",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "oracle_type",
            "oracleType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OracleBase,
            OracleQuote,
            OracleScaleFactor,
            OracleType,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "oracleBase" | "oracle_base" => Ok(GeneratedField::OracleBase),
                            "oracleQuote" | "oracle_quote" => Ok(GeneratedField::OracleQuote),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OracleParams;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.OracleParams")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OracleParams, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut oracle_base__ = None;
                let mut oracle_quote__ = None;
                let mut oracle_scale_factor__ = None;
                let mut oracle_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OracleBase => {
                            if oracle_base__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleBase"));
                            }
                            oracle_base__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleQuote => {
                            if oracle_quote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleQuote"));
                            }
                            oracle_quote__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                    }
                }
                Ok(OracleParams {
                    oracle_base: oracle_base__.unwrap_or_default(),
                    oracle_quote: oracle_quote__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.OracleParams",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OrderData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if self.order_mask != 0 {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.OrderData", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if self.order_mask != 0 {
            struct_ser.serialize_field("orderMask", &self.order_mask)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OrderData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "order_hash",
            "orderHash",
            "order_mask",
            "orderMask",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
            OrderHash,
            OrderMask,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "orderMask" | "order_mask" => Ok(GeneratedField::OrderMask),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OrderData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.OrderData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OrderData, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut order_hash__ = None;
                let mut order_mask__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderMask => {
                            if order_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderMask"));
                            }
                            order_mask__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(OrderData {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    order_mask: order_mask__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.OrderData",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OrderInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.fee_recipient.is_empty() {
            len += 1;
        }
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.OrderInfo", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.fee_recipient.is_empty() {
            struct_ser.serialize_field("feeRecipient", &self.fee_recipient)?;
        }
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OrderInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccount_id",
            "subaccountId",
            "fee_recipient",
            "feeRecipient",
            "price",
            "quantity",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            FeeRecipient,
            Price,
            Quantity,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "feeRecipient" | "fee_recipient" => Ok(GeneratedField::FeeRecipient),
                            "price" => Ok(GeneratedField::Price),
                            "quantity" => Ok(GeneratedField::Quantity),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OrderInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.OrderInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OrderInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut fee_recipient__ = None;
                let mut price__ = None;
                let mut quantity__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FeeRecipient => {
                            if fee_recipient__.is_some() {
                                return Err(serde::de::Error::duplicate_field("feeRecipient"));
                            }
                            fee_recipient__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(OrderInfo {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    fee_recipient: fee_recipient__.unwrap_or_default(),
                    price: price__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.OrderInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OrderMask {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unused => "UNUSED",
            Self::Any => "ANY",
            Self::Regular => "REGULAR",
            Self::Conditional => "CONDITIONAL",
            Self::DirectionBuyOrHigher => "DIRECTION_BUY_OR_HIGHER",
            Self::DirectionSellOrLower => "DIRECTION_SELL_OR_LOWER",
            Self::TypeMarket => "TYPE_MARKET",
            Self::TypeLimit => "TYPE_LIMIT",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OrderMask {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UNUSED",
            "ANY",
            "REGULAR",
            "CONDITIONAL",
            "DIRECTION_BUY_OR_HIGHER",
            "DIRECTION_SELL_OR_LOWER",
            "TYPE_MARKET",
            "TYPE_LIMIT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OrderMask;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UNUSED" => Ok(OrderMask::Unused),
                    "ANY" => Ok(OrderMask::Any),
                    "REGULAR" => Ok(OrderMask::Regular),
                    "CONDITIONAL" => Ok(OrderMask::Conditional),
                    "DIRECTION_BUY_OR_HIGHER" => Ok(OrderMask::DirectionBuyOrHigher),
                    "DIRECTION_SELL_OR_LOWER" => Ok(OrderMask::DirectionSellOrLower),
                    "TYPE_MARKET" => Ok(OrderMask::TypeMarket),
                    "TYPE_LIMIT" => Ok(OrderMask::TypeLimit),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OrderSide {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SideUnspecified => "Side_Unspecified",
            Self::Buy => "Buy",
            Self::Sell => "Sell",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OrderSide {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["Side_Unspecified", "Buy", "Sell"];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OrderSide;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Side_Unspecified" => Ok(OrderSide::SideUnspecified),
                    "Buy" => Ok(OrderSide::Buy),
                    "Sell" => Ok(OrderSide::Sell),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OrderType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::Buy => "BUY",
            Self::Sell => "SELL",
            Self::StopBuy => "STOP_BUY",
            Self::StopSell => "STOP_SELL",
            Self::TakeBuy => "TAKE_BUY",
            Self::TakeSell => "TAKE_SELL",
            Self::BuyPo => "BUY_PO",
            Self::SellPo => "SELL_PO",
            Self::BuyAtomic => "BUY_ATOMIC",
            Self::SellAtomic => "SELL_ATOMIC",
        };
        serializer.serialize_str(variant)
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OrderType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UNSPECIFIED",
            "BUY",
            "SELL",
            "STOP_BUY",
            "STOP_SELL",
            "TAKE_BUY",
            "TAKE_SELL",
            "BUY_PO",
            "SELL_PO",
            "BUY_ATOMIC",
            "SELL_ATOMIC",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OrderType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UNSPECIFIED" => Ok(OrderType::Unspecified),
                    "BUY" => Ok(OrderType::Buy),
                    "SELL" => Ok(OrderType::Sell),
                    "STOP_BUY" => Ok(OrderType::StopBuy),
                    "STOP_SELL" => Ok(OrderType::StopSell),
                    "TAKE_BUY" => Ok(OrderType::TakeBuy),
                    "TAKE_SELL" => Ok(OrderType::TakeSell),
                    "BUY_PO" => Ok(OrderType::BuyPo),
                    "SELL_PO" => Ok(OrderType::SellPo),
                    "BUY_ATOMIC" => Ok(OrderType::BuyAtomic),
                    "SELL_ATOMIC" => Ok(OrderType::SellAtomic),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Orderbook {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.buy_levels.is_empty() {
            len += 1;
        }
        if !self.sell_levels.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.Orderbook", len)?;
        if !self.market_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "marketId",
                pbjson::private::base64::encode(&self.market_id).as_str(),
            )?;
        }
        if !self.buy_levels.is_empty() {
            struct_ser.serialize_field("buyLevels", &self.buy_levels)?;
        }
        if !self.sell_levels.is_empty() {
            struct_ser.serialize_field("sellLevels", &self.sell_levels)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for Orderbook {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "buy_levels",
            "buyLevels",
            "sell_levels",
            "sellLevels",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            BuyLevels,
            SellLevels,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "buyLevels" | "buy_levels" => Ok(GeneratedField::BuyLevels),
                            "sellLevels" | "sell_levels" => Ok(GeneratedField::SellLevels),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Orderbook;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.Orderbook")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Orderbook, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut buy_levels__ = None;
                let mut sell_levels__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::BuyLevels => {
                            if buy_levels__.is_some() {
                                return Err(serde::de::Error::duplicate_field("buyLevels"));
                            }
                            buy_levels__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SellLevels => {
                            if sell_levels__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sellLevels"));
                            }
                            sell_levels__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Orderbook {
                    market_id: market_id__.unwrap_or_default(),
                    buy_levels: buy_levels__.unwrap_or_default(),
                    sell_levels: sell_levels__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.Orderbook",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OrderbookSequence {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.sequence != 0 {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.OrderbookSequence", len)?;
        if self.sequence != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("sequence", ToString::to_string(&self.sequence).as_str())?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OrderbookSequence {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["sequence", "market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sequence,
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sequence" => Ok(GeneratedField::Sequence),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OrderbookSequence;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.OrderbookSequence")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OrderbookSequence, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut sequence__ = None;
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sequence => {
                            if sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequence"));
                            }
                            sequence__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(OrderbookSequence {
                    sequence: sequence__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.OrderbookSequence",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for OrderbookUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.seq != 0 {
            len += 1;
        }
        if self.orderbook.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.OrderbookUpdate", len)?;
        if self.seq != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("seq", ToString::to_string(&self.seq).as_str())?;
        }
        if let Some(v) = self.orderbook.as_ref() {
            struct_ser.serialize_field("orderbook", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for OrderbookUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["seq", "orderbook"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Seq,
            Orderbook,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "seq" => Ok(GeneratedField::Seq),
                            "orderbook" => Ok(GeneratedField::Orderbook),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OrderbookUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.OrderbookUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OrderbookUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut seq__ = None;
                let mut orderbook__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Seq => {
                            if seq__.is_some() {
                                return Err(serde::de::Error::duplicate_field("seq"));
                            }
                            seq__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Orderbook => {
                            if orderbook__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderbook"));
                            }
                            orderbook__ = map_.next_value()?;
                        }
                    }
                }
                Ok(OrderbookUpdate {
                    seq: seq__.unwrap_or_default(),
                    orderbook: orderbook__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.OrderbookUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Params {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.spot_market_instant_listing_fee.is_some() {
            len += 1;
        }
        if self.derivative_market_instant_listing_fee.is_some() {
            len += 1;
        }
        if !self.default_spot_maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.default_spot_taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.default_derivative_maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.default_derivative_taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.default_initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.default_maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        if self.default_funding_interval != 0 {
            len += 1;
        }
        if self.funding_multiple != 0 {
            len += 1;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            len += 1;
        }
        if !self.default_hourly_funding_rate_cap.is_empty() {
            len += 1;
        }
        if !self.default_hourly_interest_rate.is_empty() {
            len += 1;
        }
        if self.max_derivative_order_side_count != 0 {
            len += 1;
        }
        if !self.inj_reward_staked_requirement_threshold.is_empty() {
            len += 1;
        }
        if self.trading_rewards_vesting_duration != 0 {
            len += 1;
        }
        if !self.liquidator_reward_share_rate.is_empty() {
            len += 1;
        }
        if self.binary_options_market_instant_listing_fee.is_some() {
            len += 1;
        }
        if self.atomic_market_order_access_level != 0 {
            len += 1;
        }
        if !self.spot_atomic_market_order_fee_multiplier.is_empty() {
            len += 1;
        }
        if !self
            .derivative_atomic_market_order_fee_multiplier
            .is_empty()
        {
            len += 1;
        }
        if !self
            .binary_options_atomic_market_order_fee_multiplier
            .is_empty()
        {
            len += 1;
        }
        if !self.minimal_protocol_fee_rate.is_empty() {
            len += 1;
        }
        if self.is_instant_derivative_market_launch_enabled {
            len += 1;
        }
        if self.post_only_mode_height_threshold != 0 {
            len += 1;
        }
        if self.margin_decrease_price_timestamp_threshold_seconds != 0 {
            len += 1;
        }
        if !self.exchange_admins.is_empty() {
            len += 1;
        }
        if !self.inj_auction_max_cap.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.Params", len)?;
        if let Some(v) = self.spot_market_instant_listing_fee.as_ref() {
            struct_ser.serialize_field("spotMarketInstantListingFee", v)?;
        }
        if let Some(v) = self.derivative_market_instant_listing_fee.as_ref() {
            struct_ser.serialize_field("derivativeMarketInstantListingFee", v)?;
        }
        if !self.default_spot_maker_fee_rate.is_empty() {
            struct_ser
                .serialize_field("defaultSpotMakerFeeRate", &self.default_spot_maker_fee_rate)?;
        }
        if !self.default_spot_taker_fee_rate.is_empty() {
            struct_ser
                .serialize_field("defaultSpotTakerFeeRate", &self.default_spot_taker_fee_rate)?;
        }
        if !self.default_derivative_maker_fee_rate.is_empty() {
            struct_ser.serialize_field(
                "defaultDerivativeMakerFeeRate",
                &self.default_derivative_maker_fee_rate,
            )?;
        }
        if !self.default_derivative_taker_fee_rate.is_empty() {
            struct_ser.serialize_field(
                "defaultDerivativeTakerFeeRate",
                &self.default_derivative_taker_fee_rate,
            )?;
        }
        if !self.default_initial_margin_ratio.is_empty() {
            struct_ser.serialize_field(
                "defaultInitialMarginRatio",
                &self.default_initial_margin_ratio,
            )?;
        }
        if !self.default_maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field(
                "defaultMaintenanceMarginRatio",
                &self.default_maintenance_margin_ratio,
            )?;
        }
        if self.default_funding_interval != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "defaultFundingInterval",
                ToString::to_string(&self.default_funding_interval).as_str(),
            )?;
        }
        if self.funding_multiple != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "fundingMultiple",
                ToString::to_string(&self.funding_multiple).as_str(),
            )?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            struct_ser.serialize_field("relayerFeeShareRate", &self.relayer_fee_share_rate)?;
        }
        if !self.default_hourly_funding_rate_cap.is_empty() {
            struct_ser.serialize_field(
                "defaultHourlyFundingRateCap",
                &self.default_hourly_funding_rate_cap,
            )?;
        }
        if !self.default_hourly_interest_rate.is_empty() {
            struct_ser.serialize_field(
                "defaultHourlyInterestRate",
                &self.default_hourly_interest_rate,
            )?;
        }
        if self.max_derivative_order_side_count != 0 {
            struct_ser.serialize_field(
                "maxDerivativeOrderSideCount",
                &self.max_derivative_order_side_count,
            )?;
        }
        if !self.inj_reward_staked_requirement_threshold.is_empty() {
            struct_ser.serialize_field(
                "injRewardStakedRequirementThreshold",
                &self.inj_reward_staked_requirement_threshold,
            )?;
        }
        if self.trading_rewards_vesting_duration != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "tradingRewardsVestingDuration",
                ToString::to_string(&self.trading_rewards_vesting_duration).as_str(),
            )?;
        }
        if !self.liquidator_reward_share_rate.is_empty() {
            struct_ser.serialize_field(
                "liquidatorRewardShareRate",
                &self.liquidator_reward_share_rate,
            )?;
        }
        if let Some(v) = self.binary_options_market_instant_listing_fee.as_ref() {
            struct_ser.serialize_field("binaryOptionsMarketInstantListingFee", v)?;
        }
        if self.atomic_market_order_access_level != 0 {
            let v = AtomicMarketOrderAccessLevel::try_from(self.atomic_market_order_access_level)
                .map_err(|_| {
                serde::ser::Error::custom(format!(
                    "Invalid variant {}",
                    self.atomic_market_order_access_level
                ))
            })?;
            struct_ser.serialize_field("atomicMarketOrderAccessLevel", &v)?;
        }
        if !self.spot_atomic_market_order_fee_multiplier.is_empty() {
            struct_ser.serialize_field(
                "spotAtomicMarketOrderFeeMultiplier",
                &self.spot_atomic_market_order_fee_multiplier,
            )?;
        }
        if !self
            .derivative_atomic_market_order_fee_multiplier
            .is_empty()
        {
            struct_ser.serialize_field(
                "derivativeAtomicMarketOrderFeeMultiplier",
                &self.derivative_atomic_market_order_fee_multiplier,
            )?;
        }
        if !self
            .binary_options_atomic_market_order_fee_multiplier
            .is_empty()
        {
            struct_ser.serialize_field(
                "binaryOptionsAtomicMarketOrderFeeMultiplier",
                &self.binary_options_atomic_market_order_fee_multiplier,
            )?;
        }
        if !self.minimal_protocol_fee_rate.is_empty() {
            struct_ser
                .serialize_field("minimalProtocolFeeRate", &self.minimal_protocol_fee_rate)?;
        }
        if self.is_instant_derivative_market_launch_enabled {
            struct_ser.serialize_field(
                "isInstantDerivativeMarketLaunchEnabled",
                &self.is_instant_derivative_market_launch_enabled,
            )?;
        }
        if self.post_only_mode_height_threshold != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "postOnlyModeHeightThreshold",
                ToString::to_string(&self.post_only_mode_height_threshold).as_str(),
            )?;
        }
        if self.margin_decrease_price_timestamp_threshold_seconds != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "marginDecreasePriceTimestampThresholdSeconds",
                ToString::to_string(&self.margin_decrease_price_timestamp_threshold_seconds)
                    .as_str(),
            )?;
        }
        if !self.exchange_admins.is_empty() {
            struct_ser.serialize_field("exchangeAdmins", &self.exchange_admins)?;
        }
        if !self.inj_auction_max_cap.is_empty() {
            struct_ser.serialize_field("injAuctionMaxCap", &self.inj_auction_max_cap)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for Params {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "spot_market_instant_listing_fee",
            "spotMarketInstantListingFee",
            "derivative_market_instant_listing_fee",
            "derivativeMarketInstantListingFee",
            "default_spot_maker_fee_rate",
            "defaultSpotMakerFeeRate",
            "default_spot_taker_fee_rate",
            "defaultSpotTakerFeeRate",
            "default_derivative_maker_fee_rate",
            "defaultDerivativeMakerFeeRate",
            "default_derivative_taker_fee_rate",
            "defaultDerivativeTakerFeeRate",
            "default_initial_margin_ratio",
            "defaultInitialMarginRatio",
            "default_maintenance_margin_ratio",
            "defaultMaintenanceMarginRatio",
            "default_funding_interval",
            "defaultFundingInterval",
            "funding_multiple",
            "fundingMultiple",
            "relayer_fee_share_rate",
            "relayerFeeShareRate",
            "default_hourly_funding_rate_cap",
            "defaultHourlyFundingRateCap",
            "default_hourly_interest_rate",
            "defaultHourlyInterestRate",
            "max_derivative_order_side_count",
            "maxDerivativeOrderSideCount",
            "inj_reward_staked_requirement_threshold",
            "injRewardStakedRequirementThreshold",
            "trading_rewards_vesting_duration",
            "tradingRewardsVestingDuration",
            "liquidator_reward_share_rate",
            "liquidatorRewardShareRate",
            "binary_options_market_instant_listing_fee",
            "binaryOptionsMarketInstantListingFee",
            "atomic_market_order_access_level",
            "atomicMarketOrderAccessLevel",
            "spot_atomic_market_order_fee_multiplier",
            "spotAtomicMarketOrderFeeMultiplier",
            "derivative_atomic_market_order_fee_multiplier",
            "derivativeAtomicMarketOrderFeeMultiplier",
            "binary_options_atomic_market_order_fee_multiplier",
            "binaryOptionsAtomicMarketOrderFeeMultiplier",
            "minimal_protocol_fee_rate",
            "minimalProtocolFeeRate",
            "is_instant_derivative_market_launch_enabled",
            "isInstantDerivativeMarketLaunchEnabled",
            "post_only_mode_height_threshold",
            "postOnlyModeHeightThreshold",
            "margin_decrease_price_timestamp_threshold_seconds",
            "marginDecreasePriceTimestampThresholdSeconds",
            "exchange_admins",
            "exchangeAdmins",
            "inj_auction_max_cap",
            "injAuctionMaxCap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SpotMarketInstantListingFee,
            DerivativeMarketInstantListingFee,
            DefaultSpotMakerFeeRate,
            DefaultSpotTakerFeeRate,
            DefaultDerivativeMakerFeeRate,
            DefaultDerivativeTakerFeeRate,
            DefaultInitialMarginRatio,
            DefaultMaintenanceMarginRatio,
            DefaultFundingInterval,
            FundingMultiple,
            RelayerFeeShareRate,
            DefaultHourlyFundingRateCap,
            DefaultHourlyInterestRate,
            MaxDerivativeOrderSideCount,
            InjRewardStakedRequirementThreshold,
            TradingRewardsVestingDuration,
            LiquidatorRewardShareRate,
            BinaryOptionsMarketInstantListingFee,
            AtomicMarketOrderAccessLevel,
            SpotAtomicMarketOrderFeeMultiplier,
            DerivativeAtomicMarketOrderFeeMultiplier,
            BinaryOptionsAtomicMarketOrderFeeMultiplier,
            MinimalProtocolFeeRate,
            IsInstantDerivativeMarketLaunchEnabled,
            PostOnlyModeHeightThreshold,
            MarginDecreasePriceTimestampThresholdSeconds,
            ExchangeAdmins,
            InjAuctionMaxCap,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "spotMarketInstantListingFee" | "spot_market_instant_listing_fee" => {
                                Ok(GeneratedField::SpotMarketInstantListingFee)
                            }
                            "derivativeMarketInstantListingFee"
                            | "derivative_market_instant_listing_fee" => {
                                Ok(GeneratedField::DerivativeMarketInstantListingFee)
                            }
                            "defaultSpotMakerFeeRate" | "default_spot_maker_fee_rate" => {
                                Ok(GeneratedField::DefaultSpotMakerFeeRate)
                            }
                            "defaultSpotTakerFeeRate" | "default_spot_taker_fee_rate" => {
                                Ok(GeneratedField::DefaultSpotTakerFeeRate)
                            }
                            "defaultDerivativeMakerFeeRate"
                            | "default_derivative_maker_fee_rate" => {
                                Ok(GeneratedField::DefaultDerivativeMakerFeeRate)
                            }
                            "defaultDerivativeTakerFeeRate"
                            | "default_derivative_taker_fee_rate" => {
                                Ok(GeneratedField::DefaultDerivativeTakerFeeRate)
                            }
                            "defaultInitialMarginRatio" | "default_initial_margin_ratio" => {
                                Ok(GeneratedField::DefaultInitialMarginRatio)
                            }
                            "defaultMaintenanceMarginRatio"
                            | "default_maintenance_margin_ratio" => {
                                Ok(GeneratedField::DefaultMaintenanceMarginRatio)
                            }
                            "defaultFundingInterval" | "default_funding_interval" => {
                                Ok(GeneratedField::DefaultFundingInterval)
                            }
                            "fundingMultiple" | "funding_multiple" => {
                                Ok(GeneratedField::FundingMultiple)
                            }
                            "relayerFeeShareRate" | "relayer_fee_share_rate" => {
                                Ok(GeneratedField::RelayerFeeShareRate)
                            }
                            "defaultHourlyFundingRateCap" | "default_hourly_funding_rate_cap" => {
                                Ok(GeneratedField::DefaultHourlyFundingRateCap)
                            }
                            "defaultHourlyInterestRate" | "default_hourly_interest_rate" => {
                                Ok(GeneratedField::DefaultHourlyInterestRate)
                            }
                            "maxDerivativeOrderSideCount" | "max_derivative_order_side_count" => {
                                Ok(GeneratedField::MaxDerivativeOrderSideCount)
                            }
                            "injRewardStakedRequirementThreshold"
                            | "inj_reward_staked_requirement_threshold" => {
                                Ok(GeneratedField::InjRewardStakedRequirementThreshold)
                            }
                            "tradingRewardsVestingDuration"
                            | "trading_rewards_vesting_duration" => {
                                Ok(GeneratedField::TradingRewardsVestingDuration)
                            }
                            "liquidatorRewardShareRate" | "liquidator_reward_share_rate" => {
                                Ok(GeneratedField::LiquidatorRewardShareRate)
                            }
                            "binaryOptionsMarketInstantListingFee"
                            | "binary_options_market_instant_listing_fee" => {
                                Ok(GeneratedField::BinaryOptionsMarketInstantListingFee)
                            }
                            "atomicMarketOrderAccessLevel" | "atomic_market_order_access_level" => {
                                Ok(GeneratedField::AtomicMarketOrderAccessLevel)
                            }
                            "spotAtomicMarketOrderFeeMultiplier"
                            | "spot_atomic_market_order_fee_multiplier" => {
                                Ok(GeneratedField::SpotAtomicMarketOrderFeeMultiplier)
                            }
                            "derivativeAtomicMarketOrderFeeMultiplier"
                            | "derivative_atomic_market_order_fee_multiplier" => {
                                Ok(GeneratedField::DerivativeAtomicMarketOrderFeeMultiplier)
                            }
                            "binaryOptionsAtomicMarketOrderFeeMultiplier"
                            | "binary_options_atomic_market_order_fee_multiplier" => {
                                Ok(GeneratedField::BinaryOptionsAtomicMarketOrderFeeMultiplier)
                            }
                            "minimalProtocolFeeRate" | "minimal_protocol_fee_rate" => {
                                Ok(GeneratedField::MinimalProtocolFeeRate)
                            }
                            "isInstantDerivativeMarketLaunchEnabled"
                            | "is_instant_derivative_market_launch_enabled" => {
                                Ok(GeneratedField::IsInstantDerivativeMarketLaunchEnabled)
                            }
                            "postOnlyModeHeightThreshold" | "post_only_mode_height_threshold" => {
                                Ok(GeneratedField::PostOnlyModeHeightThreshold)
                            }
                            "marginDecreasePriceTimestampThresholdSeconds"
                            | "margin_decrease_price_timestamp_threshold_seconds" => {
                                Ok(GeneratedField::MarginDecreasePriceTimestampThresholdSeconds)
                            }
                            "exchangeAdmins" | "exchange_admins" => {
                                Ok(GeneratedField::ExchangeAdmins)
                            }
                            "injAuctionMaxCap" | "inj_auction_max_cap" => {
                                Ok(GeneratedField::InjAuctionMaxCap)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Params;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.Params")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Params, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut spot_market_instant_listing_fee__ = None;
                let mut derivative_market_instant_listing_fee__ = None;
                let mut default_spot_maker_fee_rate__ = None;
                let mut default_spot_taker_fee_rate__ = None;
                let mut default_derivative_maker_fee_rate__ = None;
                let mut default_derivative_taker_fee_rate__ = None;
                let mut default_initial_margin_ratio__ = None;
                let mut default_maintenance_margin_ratio__ = None;
                let mut default_funding_interval__ = None;
                let mut funding_multiple__ = None;
                let mut relayer_fee_share_rate__ = None;
                let mut default_hourly_funding_rate_cap__ = None;
                let mut default_hourly_interest_rate__ = None;
                let mut max_derivative_order_side_count__ = None;
                let mut inj_reward_staked_requirement_threshold__ = None;
                let mut trading_rewards_vesting_duration__ = None;
                let mut liquidator_reward_share_rate__ = None;
                let mut binary_options_market_instant_listing_fee__ = None;
                let mut atomic_market_order_access_level__ = None;
                let mut spot_atomic_market_order_fee_multiplier__ = None;
                let mut derivative_atomic_market_order_fee_multiplier__ = None;
                let mut binary_options_atomic_market_order_fee_multiplier__ = None;
                let mut minimal_protocol_fee_rate__ = None;
                let mut is_instant_derivative_market_launch_enabled__ = None;
                let mut post_only_mode_height_threshold__ = None;
                let mut margin_decrease_price_timestamp_threshold_seconds__ = None;
                let mut exchange_admins__ = None;
                let mut inj_auction_max_cap__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SpotMarketInstantListingFee => {
                            if spot_market_instant_listing_fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotMarketInstantListingFee",
                                ));
                            }
                            spot_market_instant_listing_fee__ = map_.next_value()?;
                        }
                        GeneratedField::DerivativeMarketInstantListingFee => {
                            if derivative_market_instant_listing_fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeMarketInstantListingFee",
                                ));
                            }
                            derivative_market_instant_listing_fee__ = map_.next_value()?;
                        }
                        GeneratedField::DefaultSpotMakerFeeRate => {
                            if default_spot_maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultSpotMakerFeeRate",
                                ));
                            }
                            default_spot_maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultSpotTakerFeeRate => {
                            if default_spot_taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultSpotTakerFeeRate",
                                ));
                            }
                            default_spot_taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultDerivativeMakerFeeRate => {
                            if default_derivative_maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultDerivativeMakerFeeRate",
                                ));
                            }
                            default_derivative_maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultDerivativeTakerFeeRate => {
                            if default_derivative_taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultDerivativeTakerFeeRate",
                                ));
                            }
                            default_derivative_taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultInitialMarginRatio => {
                            if default_initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultInitialMarginRatio",
                                ));
                            }
                            default_initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultMaintenanceMarginRatio => {
                            if default_maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultMaintenanceMarginRatio",
                                ));
                            }
                            default_maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultFundingInterval => {
                            if default_funding_interval__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultFundingInterval",
                                ));
                            }
                            default_funding_interval__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::FundingMultiple => {
                            if funding_multiple__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fundingMultiple"));
                            }
                            funding_multiple__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::RelayerFeeShareRate => {
                            if relayer_fee_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "relayerFeeShareRate",
                                ));
                            }
                            relayer_fee_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultHourlyFundingRateCap => {
                            if default_hourly_funding_rate_cap__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultHourlyFundingRateCap",
                                ));
                            }
                            default_hourly_funding_rate_cap__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DefaultHourlyInterestRate => {
                            if default_hourly_interest_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "defaultHourlyInterestRate",
                                ));
                            }
                            default_hourly_interest_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaxDerivativeOrderSideCount => {
                            if max_derivative_order_side_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maxDerivativeOrderSideCount",
                                ));
                            }
                            max_derivative_order_side_count__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::InjRewardStakedRequirementThreshold => {
                            if inj_reward_staked_requirement_threshold__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "injRewardStakedRequirementThreshold",
                                ));
                            }
                            inj_reward_staked_requirement_threshold__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradingRewardsVestingDuration => {
                            if trading_rewards_vesting_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardsVestingDuration",
                                ));
                            }
                            trading_rewards_vesting_duration__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::LiquidatorRewardShareRate => {
                            if liquidator_reward_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "liquidatorRewardShareRate",
                                ));
                            }
                            liquidator_reward_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsMarketInstantListingFee => {
                            if binary_options_market_instant_listing_fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsMarketInstantListingFee",
                                ));
                            }
                            binary_options_market_instant_listing_fee__ = map_.next_value()?;
                        }
                        GeneratedField::AtomicMarketOrderAccessLevel => {
                            if atomic_market_order_access_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "atomicMarketOrderAccessLevel",
                                ));
                            }
                            atomic_market_order_access_level__ =
                                Some(map_.next_value::<AtomicMarketOrderAccessLevel>()? as i32);
                        }
                        GeneratedField::SpotAtomicMarketOrderFeeMultiplier => {
                            if spot_atomic_market_order_fee_multiplier__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotAtomicMarketOrderFeeMultiplier",
                                ));
                            }
                            spot_atomic_market_order_fee_multiplier__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeAtomicMarketOrderFeeMultiplier => {
                            if derivative_atomic_market_order_fee_multiplier__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeAtomicMarketOrderFeeMultiplier",
                                ));
                            }
                            derivative_atomic_market_order_fee_multiplier__ =
                                Some(map_.next_value()?);
                        }
                        GeneratedField::BinaryOptionsAtomicMarketOrderFeeMultiplier => {
                            if binary_options_atomic_market_order_fee_multiplier__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "binaryOptionsAtomicMarketOrderFeeMultiplier",
                                ));
                            }
                            binary_options_atomic_market_order_fee_multiplier__ =
                                Some(map_.next_value()?);
                        }
                        GeneratedField::MinimalProtocolFeeRate => {
                            if minimal_protocol_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minimalProtocolFeeRate",
                                ));
                            }
                            minimal_protocol_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsInstantDerivativeMarketLaunchEnabled => {
                            if is_instant_derivative_market_launch_enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "isInstantDerivativeMarketLaunchEnabled",
                                ));
                            }
                            is_instant_derivative_market_launch_enabled__ =
                                Some(map_.next_value()?);
                        }
                        GeneratedField::PostOnlyModeHeightThreshold => {
                            if post_only_mode_height_threshold__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "postOnlyModeHeightThreshold",
                                ));
                            }
                            post_only_mode_height_threshold__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::MarginDecreasePriceTimestampThresholdSeconds => {
                            if margin_decrease_price_timestamp_threshold_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "marginDecreasePriceTimestampThresholdSeconds",
                                ));
                            }
                            margin_decrease_price_timestamp_threshold_seconds__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::ExchangeAdmins => {
                            if exchange_admins__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exchangeAdmins"));
                            }
                            exchange_admins__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InjAuctionMaxCap => {
                            if inj_auction_max_cap__.is_some() {
                                return Err(serde::de::Error::duplicate_field("injAuctionMaxCap"));
                            }
                            inj_auction_max_cap__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Params {
                    spot_market_instant_listing_fee: spot_market_instant_listing_fee__,
                    derivative_market_instant_listing_fee: derivative_market_instant_listing_fee__,
                    default_spot_maker_fee_rate: default_spot_maker_fee_rate__.unwrap_or_default(),
                    default_spot_taker_fee_rate: default_spot_taker_fee_rate__.unwrap_or_default(),
                    default_derivative_maker_fee_rate: default_derivative_maker_fee_rate__
                        .unwrap_or_default(),
                    default_derivative_taker_fee_rate: default_derivative_taker_fee_rate__
                        .unwrap_or_default(),
                    default_initial_margin_ratio: default_initial_margin_ratio__
                        .unwrap_or_default(),
                    default_maintenance_margin_ratio: default_maintenance_margin_ratio__
                        .unwrap_or_default(),
                    default_funding_interval: default_funding_interval__.unwrap_or_default(),
                    funding_multiple: funding_multiple__.unwrap_or_default(),
                    relayer_fee_share_rate: relayer_fee_share_rate__.unwrap_or_default(),
                    default_hourly_funding_rate_cap: default_hourly_funding_rate_cap__
                        .unwrap_or_default(),
                    default_hourly_interest_rate: default_hourly_interest_rate__
                        .unwrap_or_default(),
                    max_derivative_order_side_count: max_derivative_order_side_count__
                        .unwrap_or_default(),
                    inj_reward_staked_requirement_threshold:
                        inj_reward_staked_requirement_threshold__.unwrap_or_default(),
                    trading_rewards_vesting_duration: trading_rewards_vesting_duration__
                        .unwrap_or_default(),
                    liquidator_reward_share_rate: liquidator_reward_share_rate__
                        .unwrap_or_default(),
                    binary_options_market_instant_listing_fee:
                        binary_options_market_instant_listing_fee__,
                    atomic_market_order_access_level: atomic_market_order_access_level__
                        .unwrap_or_default(),
                    spot_atomic_market_order_fee_multiplier:
                        spot_atomic_market_order_fee_multiplier__.unwrap_or_default(),
                    derivative_atomic_market_order_fee_multiplier:
                        derivative_atomic_market_order_fee_multiplier__.unwrap_or_default(),
                    binary_options_atomic_market_order_fee_multiplier:
                        binary_options_atomic_market_order_fee_multiplier__.unwrap_or_default(),
                    minimal_protocol_fee_rate: minimal_protocol_fee_rate__.unwrap_or_default(),
                    is_instant_derivative_market_launch_enabled:
                        is_instant_derivative_market_launch_enabled__.unwrap_or_default(),
                    post_only_mode_height_threshold: post_only_mode_height_threshold__
                        .unwrap_or_default(),
                    margin_decrease_price_timestamp_threshold_seconds:
                        margin_decrease_price_timestamp_threshold_seconds__.unwrap_or_default(),
                    exchange_admins: exchange_admins__.unwrap_or_default(),
                    inj_auction_max_cap: inj_auction_max_cap__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.Params",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PerpetualMarketFunding {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.cumulative_funding.is_empty() {
            len += 1;
        }
        if !self.cumulative_price.is_empty() {
            len += 1;
        }
        if self.last_timestamp != 0 {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.PerpetualMarketFunding", len)?;
        if !self.cumulative_funding.is_empty() {
            struct_ser.serialize_field("cumulativeFunding", &self.cumulative_funding)?;
        }
        if !self.cumulative_price.is_empty() {
            struct_ser.serialize_field("cumulativePrice", &self.cumulative_price)?;
        }
        if self.last_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "lastTimestamp",
                ToString::to_string(&self.last_timestamp).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PerpetualMarketFunding {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "cumulative_funding",
            "cumulativeFunding",
            "cumulative_price",
            "cumulativePrice",
            "last_timestamp",
            "lastTimestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CumulativeFunding,
            CumulativePrice,
            LastTimestamp,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "cumulativeFunding" | "cumulative_funding" => {
                                Ok(GeneratedField::CumulativeFunding)
                            }
                            "cumulativePrice" | "cumulative_price" => {
                                Ok(GeneratedField::CumulativePrice)
                            }
                            "lastTimestamp" | "last_timestamp" => Ok(GeneratedField::LastTimestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PerpetualMarketFunding;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.PerpetualMarketFunding")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<PerpetualMarketFunding, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut cumulative_funding__ = None;
                let mut cumulative_price__ = None;
                let mut last_timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CumulativeFunding => {
                            if cumulative_funding__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cumulativeFunding"));
                            }
                            cumulative_funding__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CumulativePrice => {
                            if cumulative_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cumulativePrice"));
                            }
                            cumulative_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LastTimestamp => {
                            if last_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTimestamp"));
                            }
                            last_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(PerpetualMarketFunding {
                    cumulative_funding: cumulative_funding__.unwrap_or_default(),
                    cumulative_price: cumulative_price__.unwrap_or_default(),
                    last_timestamp: last_timestamp__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PerpetualMarketFunding",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PerpetualMarketFundingState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.funding.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.PerpetualMarketFundingState",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.funding.as_ref() {
            struct_ser.serialize_field("funding", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PerpetualMarketFundingState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "funding"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Funding,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "funding" => Ok(GeneratedField::Funding),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PerpetualMarketFundingState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.PerpetualMarketFundingState")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<PerpetualMarketFundingState, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut funding__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Funding => {
                            if funding__.is_some() {
                                return Err(serde::de::Error::duplicate_field("funding"));
                            }
                            funding__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PerpetualMarketFundingState {
                    market_id: market_id__.unwrap_or_default(),
                    funding: funding__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PerpetualMarketFundingState",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PerpetualMarketInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.hourly_funding_rate_cap.is_empty() {
            len += 1;
        }
        if !self.hourly_interest_rate.is_empty() {
            len += 1;
        }
        if self.next_funding_timestamp != 0 {
            len += 1;
        }
        if self.funding_interval != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.PerpetualMarketInfo", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.hourly_funding_rate_cap.is_empty() {
            struct_ser.serialize_field("hourlyFundingRateCap", &self.hourly_funding_rate_cap)?;
        }
        if !self.hourly_interest_rate.is_empty() {
            struct_ser.serialize_field("hourlyInterestRate", &self.hourly_interest_rate)?;
        }
        if self.next_funding_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "nextFundingTimestamp",
                ToString::to_string(&self.next_funding_timestamp).as_str(),
            )?;
        }
        if self.funding_interval != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "fundingInterval",
                ToString::to_string(&self.funding_interval).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PerpetualMarketInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "hourly_funding_rate_cap",
            "hourlyFundingRateCap",
            "hourly_interest_rate",
            "hourlyInterestRate",
            "next_funding_timestamp",
            "nextFundingTimestamp",
            "funding_interval",
            "fundingInterval",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            HourlyFundingRateCap,
            HourlyInterestRate,
            NextFundingTimestamp,
            FundingInterval,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "hourlyFundingRateCap" | "hourly_funding_rate_cap" => {
                                Ok(GeneratedField::HourlyFundingRateCap)
                            }
                            "hourlyInterestRate" | "hourly_interest_rate" => {
                                Ok(GeneratedField::HourlyInterestRate)
                            }
                            "nextFundingTimestamp" | "next_funding_timestamp" => {
                                Ok(GeneratedField::NextFundingTimestamp)
                            }
                            "fundingInterval" | "funding_interval" => {
                                Ok(GeneratedField::FundingInterval)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PerpetualMarketInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.PerpetualMarketInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PerpetualMarketInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut hourly_funding_rate_cap__ = None;
                let mut hourly_interest_rate__ = None;
                let mut next_funding_timestamp__ = None;
                let mut funding_interval__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HourlyFundingRateCap => {
                            if hourly_funding_rate_cap__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "hourlyFundingRateCap",
                                ));
                            }
                            hourly_funding_rate_cap__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HourlyInterestRate => {
                            if hourly_interest_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "hourlyInterestRate",
                                ));
                            }
                            hourly_interest_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextFundingTimestamp => {
                            if next_funding_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "nextFundingTimestamp",
                                ));
                            }
                            next_funding_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::FundingInterval => {
                            if funding_interval__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fundingInterval"));
                            }
                            funding_interval__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(PerpetualMarketInfo {
                    market_id: market_id__.unwrap_or_default(),
                    hourly_funding_rate_cap: hourly_funding_rate_cap__.unwrap_or_default(),
                    hourly_interest_rate: hourly_interest_rate__.unwrap_or_default(),
                    next_funding_timestamp: next_funding_timestamp__.unwrap_or_default(),
                    funding_interval: funding_interval__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PerpetualMarketInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PerpetualMarketLaunchProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.oracle_base.is_empty() {
            len += 1;
        }
        if !self.oracle_quote.is_empty() {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        if !self.initial_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if self.admin_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.PerpetualMarketLaunchProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            struct_ser.serialize_field("oracleBase", &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            struct_ser.serialize_field("oracleQuote", &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            struct_ser.serialize_field("initialMarginRatio", &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            struct_ser.serialize_field("maintenanceMarginRatio", &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if let Some(v) = self.admin_info.as_ref() {
            struct_ser.serialize_field("adminInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PerpetualMarketLaunchProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "ticker",
            "quote_denom",
            "quoteDenom",
            "oracle_base",
            "oracleBase",
            "oracle_quote",
            "oracleQuote",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "oracle_type",
            "oracleType",
            "initial_margin_ratio",
            "initialMarginRatio",
            "maintenance_margin_ratio",
            "maintenanceMarginRatio",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
            "admin_info",
            "adminInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            Ticker,
            QuoteDenom,
            OracleBase,
            OracleQuote,
            OracleScaleFactor,
            OracleType,
            InitialMarginRatio,
            MaintenanceMarginRatio,
            MakerFeeRate,
            TakerFeeRate,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
            AdminInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "oracleBase" | "oracle_base" => Ok(GeneratedField::OracleBase),
                            "oracleQuote" | "oracle_quote" => Ok(GeneratedField::OracleQuote),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            "initialMarginRatio" | "initial_margin_ratio" => {
                                Ok(GeneratedField::InitialMarginRatio)
                            }
                            "maintenanceMarginRatio" | "maintenance_margin_ratio" => {
                                Ok(GeneratedField::MaintenanceMarginRatio)
                            }
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "adminInfo" | "admin_info" => Ok(GeneratedField::AdminInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PerpetualMarketLaunchProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.PerpetualMarketLaunchProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<PerpetualMarketLaunchProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut ticker__ = None;
                let mut quote_denom__ = None;
                let mut oracle_base__ = None;
                let mut oracle_quote__ = None;
                let mut oracle_scale_factor__ = None;
                let mut oracle_type__ = None;
                let mut initial_margin_ratio__ = None;
                let mut maintenance_margin_ratio__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                let mut admin_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleBase => {
                            if oracle_base__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleBase"));
                            }
                            oracle_base__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleQuote => {
                            if oracle_quote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleQuote"));
                            }
                            oracle_quote__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                        GeneratedField::InitialMarginRatio => {
                            if initial_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "initialMarginRatio",
                                ));
                            }
                            initial_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaintenanceMarginRatio => {
                            if maintenance_margin_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "maintenanceMarginRatio",
                                ));
                            }
                            maintenance_margin_ratio__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminInfo => {
                            if admin_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminInfo"));
                            }
                            admin_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PerpetualMarketLaunchProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    oracle_base: oracle_base__.unwrap_or_default(),
                    oracle_quote: oracle_quote__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                    initial_margin_ratio: initial_margin_ratio__.unwrap_or_default(),
                    maintenance_margin_ratio: maintenance_margin_ratio__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin_info: admin_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PerpetualMarketLaunchProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PerpetualMarketState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market_info.is_some() {
            len += 1;
        }
        if self.funding_info.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.PerpetualMarketState", len)?;
        if let Some(v) = self.market_info.as_ref() {
            struct_ser.serialize_field("marketInfo", v)?;
        }
        if let Some(v) = self.funding_info.as_ref() {
            struct_ser.serialize_field("fundingInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PerpetualMarketState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_info", "marketInfo", "funding_info", "fundingInfo"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketInfo,
            FundingInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketInfo" | "market_info" => Ok(GeneratedField::MarketInfo),
                            "fundingInfo" | "funding_info" => Ok(GeneratedField::FundingInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PerpetualMarketState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.PerpetualMarketState")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<PerpetualMarketState, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_info__ = None;
                let mut funding_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketInfo => {
                            if market_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketInfo"));
                            }
                            market_info__ = map_.next_value()?;
                        }
                        GeneratedField::FundingInfo => {
                            if funding_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fundingInfo"));
                            }
                            funding_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PerpetualMarketState {
                    market_info: market_info__,
                    funding_info: funding_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PerpetualMarketState",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PointsMultiplier {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.maker_points_multiplier.is_empty() {
            len += 1;
        }
        if !self.taker_points_multiplier.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.PointsMultiplier", len)?;
        if !self.maker_points_multiplier.is_empty() {
            struct_ser.serialize_field("makerPointsMultiplier", &self.maker_points_multiplier)?;
        }
        if !self.taker_points_multiplier.is_empty() {
            struct_ser.serialize_field("takerPointsMultiplier", &self.taker_points_multiplier)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PointsMultiplier {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "maker_points_multiplier",
            "makerPointsMultiplier",
            "taker_points_multiplier",
            "takerPointsMultiplier",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MakerPointsMultiplier,
            TakerPointsMultiplier,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "makerPointsMultiplier" | "maker_points_multiplier" => {
                                Ok(GeneratedField::MakerPointsMultiplier)
                            }
                            "takerPointsMultiplier" | "taker_points_multiplier" => {
                                Ok(GeneratedField::TakerPointsMultiplier)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PointsMultiplier;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.PointsMultiplier")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PointsMultiplier, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut maker_points_multiplier__ = None;
                let mut taker_points_multiplier__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MakerPointsMultiplier => {
                            if maker_points_multiplier__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "makerPointsMultiplier",
                                ));
                            }
                            maker_points_multiplier__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerPointsMultiplier => {
                            if taker_points_multiplier__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "takerPointsMultiplier",
                                ));
                            }
                            taker_points_multiplier__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PointsMultiplier {
                    maker_points_multiplier: maker_points_multiplier__.unwrap_or_default(),
                    taker_points_multiplier: taker_points_multiplier__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PointsMultiplier",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Position {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_long {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.entry_price.is_empty() {
            len += 1;
        }
        if !self.margin.is_empty() {
            len += 1;
        }
        if !self.cumulative_funding_entry.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.Position", len)?;
        if self.is_long {
            struct_ser.serialize_field("isLong", &self.is_long)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.entry_price.is_empty() {
            struct_ser.serialize_field("entryPrice", &self.entry_price)?;
        }
        if !self.margin.is_empty() {
            struct_ser.serialize_field("margin", &self.margin)?;
        }
        if !self.cumulative_funding_entry.is_empty() {
            struct_ser.serialize_field("cumulativeFundingEntry", &self.cumulative_funding_entry)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for Position {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "isLong",
            "quantity",
            "entry_price",
            "entryPrice",
            "margin",
            "cumulative_funding_entry",
            "cumulativeFundingEntry",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsLong,
            Quantity,
            EntryPrice,
            Margin,
            CumulativeFundingEntry,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isLong" => Ok(GeneratedField::IsLong),
                            "quantity" => Ok(GeneratedField::Quantity),
                            "entryPrice" | "entry_price" => Ok(GeneratedField::EntryPrice),
                            "margin" => Ok(GeneratedField::Margin),
                            "cumulativeFundingEntry" | "cumulative_funding_entry" => {
                                Ok(GeneratedField::CumulativeFundingEntry)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Position;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.Position")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Position, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut is_long__ = None;
                let mut quantity__ = None;
                let mut entry_price__ = None;
                let mut margin__ = None;
                let mut cumulative_funding_entry__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsLong => {
                            if is_long__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLong"));
                            }
                            is_long__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::EntryPrice => {
                            if entry_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("entryPrice"));
                            }
                            entry_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Margin => {
                            if margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("margin"));
                            }
                            margin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CumulativeFundingEntry => {
                            if cumulative_funding_entry__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "cumulativeFundingEntry",
                                ));
                            }
                            cumulative_funding_entry__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Position {
                    is_long: is_long__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                    entry_price: entry_price__.unwrap_or_default(),
                    margin: margin__.unwrap_or_default(),
                    cumulative_funding_entry: cumulative_funding_entry__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.Position",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PositionDelta {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_long {
            len += 1;
        }
        if !self.execution_quantity.is_empty() {
            len += 1;
        }
        if !self.execution_margin.is_empty() {
            len += 1;
        }
        if !self.execution_price.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.PositionDelta", len)?;
        if self.is_long {
            struct_ser.serialize_field("isLong", &self.is_long)?;
        }
        if !self.execution_quantity.is_empty() {
            struct_ser.serialize_field("executionQuantity", &self.execution_quantity)?;
        }
        if !self.execution_margin.is_empty() {
            struct_ser.serialize_field("executionMargin", &self.execution_margin)?;
        }
        if !self.execution_price.is_empty() {
            struct_ser.serialize_field("executionPrice", &self.execution_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PositionDelta {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_long",
            "isLong",
            "execution_quantity",
            "executionQuantity",
            "execution_margin",
            "executionMargin",
            "execution_price",
            "executionPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsLong,
            ExecutionQuantity,
            ExecutionMargin,
            ExecutionPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isLong" | "is_long" => Ok(GeneratedField::IsLong),
                            "executionQuantity" | "execution_quantity" => {
                                Ok(GeneratedField::ExecutionQuantity)
                            }
                            "executionMargin" | "execution_margin" => {
                                Ok(GeneratedField::ExecutionMargin)
                            }
                            "executionPrice" | "execution_price" => {
                                Ok(GeneratedField::ExecutionPrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PositionDelta;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.PositionDelta")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PositionDelta, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut is_long__ = None;
                let mut execution_quantity__ = None;
                let mut execution_margin__ = None;
                let mut execution_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsLong => {
                            if is_long__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLong"));
                            }
                            is_long__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExecutionQuantity => {
                            if execution_quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("executionQuantity"));
                            }
                            execution_quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExecutionMargin => {
                            if execution_margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("executionMargin"));
                            }
                            execution_margin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExecutionPrice => {
                            if execution_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("executionPrice"));
                            }
                            execution_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PositionDelta {
                    is_long: is_long__.unwrap_or_default(),
                    execution_quantity: execution_quantity__.unwrap_or_default(),
                    execution_margin: execution_margin__.unwrap_or_default(),
                    execution_price: execution_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PositionDelta",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PriceLevel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.PriceLevel", len)?;
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for PriceLevel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["price", "quantity"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Price,
            Quantity,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "price" => Ok(GeneratedField::Price),
                            "quantity" => Ok(GeneratedField::Quantity),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PriceLevel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.PriceLevel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PriceLevel, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut price__ = None;
                let mut quantity__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PriceLevel {
                    price: price__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.PriceLevel",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ProviderOracleParams {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.symbol.is_empty() {
            len += 1;
        }
        if !self.provider.is_empty() {
            len += 1;
        }
        if self.oracle_scale_factor != 0 {
            len += 1;
        }
        if self.oracle_type != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.ProviderOracleParams", len)?;
        if !self.symbol.is_empty() {
            struct_ser.serialize_field("symbol", &self.symbol)?;
        }
        if !self.provider.is_empty() {
            struct_ser.serialize_field("provider", &self.provider)?;
        }
        if self.oracle_scale_factor != 0 {
            struct_ser.serialize_field("oracleScaleFactor", &self.oracle_scale_factor)?;
        }
        if self.oracle_type != 0 {
            let v = super::super::oracle::v1beta1::OracleType::try_from(self.oracle_type).map_err(
                |_| serde::ser::Error::custom(format!("Invalid variant {}", self.oracle_type)),
            )?;
            struct_ser.serialize_field("oracleType", &v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for ProviderOracleParams {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "symbol",
            "provider",
            "oracle_scale_factor",
            "oracleScaleFactor",
            "oracle_type",
            "oracleType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Symbol,
            Provider,
            OracleScaleFactor,
            OracleType,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "symbol" => Ok(GeneratedField::Symbol),
                            "provider" => Ok(GeneratedField::Provider),
                            "oracleScaleFactor" | "oracle_scale_factor" => {
                                Ok(GeneratedField::OracleScaleFactor)
                            }
                            "oracleType" | "oracle_type" => Ok(GeneratedField::OracleType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProviderOracleParams;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.ProviderOracleParams")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<ProviderOracleParams, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut symbol__ = None;
                let mut provider__ = None;
                let mut oracle_scale_factor__ = None;
                let mut oracle_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Symbol => {
                            if symbol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("symbol"));
                            }
                            symbol__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Provider => {
                            if provider__.is_some() {
                                return Err(serde::de::Error::duplicate_field("provider"));
                            }
                            provider__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OracleScaleFactor => {
                            if oracle_scale_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleScaleFactor"));
                            }
                            oracle_scale_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::OracleType => {
                            if oracle_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oracleType"));
                            }
                            oracle_type__ = Some(
                                map_.next_value::<super::super::oracle::v1beta1::OracleType>()?
                                    as i32,
                            );
                        }
                    }
                }
                Ok(ProviderOracleParams {
                    symbol: symbol__.unwrap_or_default(),
                    provider: provider__.unwrap_or_default(),
                    oracle_scale_factor: oracle_scale_factor__.unwrap_or_default(),
                    oracle_type: oracle_type__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.ProviderOracleParams",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAccountAddressDerivativeOrdersRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.account_address.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.account_address.is_empty() {
            struct_ser.serialize_field("accountAddress", &self.account_address)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAccountAddressDerivativeOrdersRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "account_address", "accountAddress"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            AccountAddress,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "accountAddress" | "account_address" => {
                                Ok(GeneratedField::AccountAddress)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAccountAddressDerivativeOrdersRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAccountAddressDerivativeOrdersRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut account_address__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AccountAddress => {
                            if account_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountAddress"));
                            }
                            account_address__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAccountAddressDerivativeOrdersRequest {
                    market_id: market_id__.unwrap_or_default(),
                    account_address: account_address__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAccountAddressDerivativeOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse",
            len,
        )?;
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAccountAddressDerivativeOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAccountAddressDerivativeOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAccountAddressDerivativeOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAccountAddressDerivativeOrdersResponse {
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAccountAddressSpotOrdersRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.account_address.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.account_address.is_empty() {
            struct_ser.serialize_field("accountAddress", &self.account_address)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAccountAddressSpotOrdersRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "account_address", "accountAddress"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            AccountAddress,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "accountAddress" | "account_address" => {
                                Ok(GeneratedField::AccountAddress)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAccountAddressSpotOrdersRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAccountAddressSpotOrdersRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut account_address__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AccountAddress => {
                            if account_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountAddress"));
                            }
                            account_address__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAccountAddressSpotOrdersRequest {
                    market_id: market_id__.unwrap_or_default(),
                    account_address: account_address__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAccountAddressSpotOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse",
            len,
        )?;
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAccountAddressSpotOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAccountAddressSpotOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAccountAddressSpotOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAccountAddressSpotOrdersResponse {
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryActiveStakeGrantRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.grantee.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryActiveStakeGrantRequest",
            len,
        )?;
        if !self.grantee.is_empty() {
            struct_ser.serialize_field("grantee", &self.grantee)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryActiveStakeGrantRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["grantee"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Grantee,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "grantee" => Ok(GeneratedField::Grantee),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryActiveStakeGrantRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryActiveStakeGrantRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryActiveStakeGrantRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut grantee__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Grantee => {
                            if grantee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantee"));
                            }
                            grantee__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryActiveStakeGrantRequest {
                    grantee: grantee__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryActiveStakeGrantRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryActiveStakeGrantResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.grant.is_some() {
            len += 1;
        }
        if self.effective_grant.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryActiveStakeGrantResponse",
            len,
        )?;
        if let Some(v) = self.grant.as_ref() {
            struct_ser.serialize_field("grant", v)?;
        }
        if let Some(v) = self.effective_grant.as_ref() {
            struct_ser.serialize_field("effectiveGrant", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryActiveStakeGrantResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["grant", "effective_grant", "effectiveGrant"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Grant,
            EffectiveGrant,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "grant" => Ok(GeneratedField::Grant),
                            "effectiveGrant" | "effective_grant" => {
                                Ok(GeneratedField::EffectiveGrant)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryActiveStakeGrantResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryActiveStakeGrantResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryActiveStakeGrantResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut grant__ = None;
                let mut effective_grant__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Grant => {
                            if grant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grant"));
                            }
                            grant__ = map_.next_value()?;
                        }
                        GeneratedField::EffectiveGrant => {
                            if effective_grant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("effectiveGrant"));
                            }
                            effective_grant__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryActiveStakeGrantResponse {
                    grant: grant__,
                    effective_grant: effective_grant__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryActiveStakeGrantResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateMarketVolumeRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateMarketVolumeRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateMarketVolumeRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateMarketVolumeRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAggregateMarketVolumeRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateMarketVolumeResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse",
            len,
        )?;
        if let Some(v) = self.volume.as_ref() {
            struct_ser.serialize_field("volume", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateMarketVolumeResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["volume"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Volume,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volume" => Ok(GeneratedField::Volume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateMarketVolumeResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateMarketVolumeResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut volume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryAggregateMarketVolumeResponse { volume: volume__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateMarketVolumesRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest",
            len,
        )?;
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateMarketVolumesRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateMarketVolumesRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateMarketVolumesRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAggregateMarketVolumesRequest {
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateMarketVolumesResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.volumes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse",
            len,
        )?;
        if !self.volumes.is_empty() {
            struct_ser.serialize_field("volumes", &self.volumes)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateMarketVolumesResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["volumes"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Volumes,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumes" => Ok(GeneratedField::Volumes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateMarketVolumesResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateMarketVolumesResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut volumes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Volumes => {
                            if volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumes"));
                            }
                            volumes__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAggregateMarketVolumesResponse {
                    volumes: volumes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateVolumeRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumeRequest",
            len,
        )?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateVolumeRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateVolumeRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryAggregateVolumeRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateVolumeRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAggregateVolumeRequest {
                    account: account__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumeRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateVolumeResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.aggregate_volumes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumeResponse",
            len,
        )?;
        if !self.aggregate_volumes.is_empty() {
            struct_ser.serialize_field("aggregateVolumes", &self.aggregate_volumes)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateVolumeResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["aggregate_volumes", "aggregateVolumes"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AggregateVolumes,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "aggregateVolumes" | "aggregate_volumes" => {
                                Ok(GeneratedField::AggregateVolumes)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateVolumeResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryAggregateVolumeResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateVolumeResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut aggregate_volumes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AggregateVolumes => {
                            if aggregate_volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggregateVolumes"));
                            }
                            aggregate_volumes__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAggregateVolumeResponse {
                    aggregate_volumes: aggregate_volumes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumeResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateVolumesRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.accounts.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumesRequest",
            len,
        )?;
        if !self.accounts.is_empty() {
            struct_ser.serialize_field("accounts", &self.accounts)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateVolumesRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["accounts", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Accounts,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accounts" => Ok(GeneratedField::Accounts),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateVolumesRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryAggregateVolumesRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateVolumesRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut accounts__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Accounts => {
                            if accounts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accounts"));
                            }
                            accounts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAggregateVolumesRequest {
                    accounts: accounts__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumesRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryAggregateVolumesResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.aggregate_account_volumes.is_empty() {
            len += 1;
        }
        if !self.aggregate_market_volumes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumesResponse",
            len,
        )?;
        if !self.aggregate_account_volumes.is_empty() {
            struct_ser
                .serialize_field("aggregateAccountVolumes", &self.aggregate_account_volumes)?;
        }
        if !self.aggregate_market_volumes.is_empty() {
            struct_ser.serialize_field("aggregateMarketVolumes", &self.aggregate_market_volumes)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryAggregateVolumesResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "aggregate_account_volumes",
            "aggregateAccountVolumes",
            "aggregate_market_volumes",
            "aggregateMarketVolumes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AggregateAccountVolumes,
            AggregateMarketVolumes,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "aggregateAccountVolumes" | "aggregate_account_volumes" => {
                                Ok(GeneratedField::AggregateAccountVolumes)
                            }
                            "aggregateMarketVolumes" | "aggregate_market_volumes" => {
                                Ok(GeneratedField::AggregateMarketVolumes)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryAggregateVolumesResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryAggregateVolumesResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryAggregateVolumesResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut aggregate_account_volumes__ = None;
                let mut aggregate_market_volumes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AggregateAccountVolumes => {
                            if aggregate_account_volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "aggregateAccountVolumes",
                                ));
                            }
                            aggregate_account_volumes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AggregateMarketVolumes => {
                            if aggregate_market_volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "aggregateMarketVolumes",
                                ));
                            }
                            aggregate_market_volumes__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryAggregateVolumesResponse {
                    aggregate_account_volumes: aggregate_account_volumes__.unwrap_or_default(),
                    aggregate_market_volumes: aggregate_market_volumes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryAggregateVolumesResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryBalanceMismatchesRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.dust_factor != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryBalanceMismatchesRequest",
            len,
        )?;
        if self.dust_factor != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "dustFactor",
                ToString::to_string(&self.dust_factor).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryBalanceMismatchesRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["dust_factor", "dustFactor"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DustFactor,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dustFactor" | "dust_factor" => Ok(GeneratedField::DustFactor),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryBalanceMismatchesRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryBalanceMismatchesRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryBalanceMismatchesRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut dust_factor__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DustFactor => {
                            if dust_factor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dustFactor"));
                            }
                            dust_factor__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(QueryBalanceMismatchesRequest {
                    dust_factor: dust_factor__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryBalanceMismatchesRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryBalanceMismatchesResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.balance_mismatches.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryBalanceMismatchesResponse",
            len,
        )?;
        if !self.balance_mismatches.is_empty() {
            struct_ser.serialize_field("balanceMismatches", &self.balance_mismatches)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryBalanceMismatchesResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["balance_mismatches", "balanceMismatches"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BalanceMismatches,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "balanceMismatches" | "balance_mismatches" => {
                                Ok(GeneratedField::BalanceMismatches)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryBalanceMismatchesResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryBalanceMismatchesResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryBalanceMismatchesResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut balance_mismatches__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BalanceMismatches => {
                            if balance_mismatches__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceMismatches"));
                            }
                            balance_mismatches__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryBalanceMismatchesResponse {
                    balance_mismatches: balance_mismatches__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryBalanceMismatchesResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryBalanceWithBalanceHoldsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryBalanceWithBalanceHoldsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryBalanceWithBalanceHoldsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryBalanceWithBalanceHoldsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryBalanceWithBalanceHoldsRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryBalanceWithBalanceHoldsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.balance_with_balance_holds.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse",
            len,
        )?;
        if !self.balance_with_balance_holds.is_empty() {
            struct_ser
                .serialize_field("balanceWithBalanceHolds", &self.balance_with_balance_holds)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryBalanceWithBalanceHoldsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["balance_with_balance_holds", "balanceWithBalanceHolds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BalanceWithBalanceHolds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "balanceWithBalanceHolds" | "balance_with_balance_holds" => {
                                Ok(GeneratedField::BalanceWithBalanceHolds)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryBalanceWithBalanceHoldsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryBalanceWithBalanceHoldsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut balance_with_balance_holds__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BalanceWithBalanceHolds => {
                            if balance_with_balance_holds__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "balanceWithBalanceHolds",
                                ));
                            }
                            balance_with_balance_holds__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryBalanceWithBalanceHoldsResponse {
                    balance_with_balance_holds: balance_with_balance_holds__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryBinaryMarketsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.status.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryBinaryMarketsRequest", len)?;
        if !self.status.is_empty() {
            struct_ser.serialize_field("status", &self.status)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryBinaryMarketsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["status"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryBinaryMarketsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryBinaryMarketsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryBinaryMarketsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryBinaryMarketsRequest {
                    status: status__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryBinaryMarketsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryBinaryMarketsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.markets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryBinaryMarketsResponse", len)?;
        if !self.markets.is_empty() {
            struct_ser.serialize_field("markets", &self.markets)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryBinaryMarketsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["markets"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Markets,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "markets" => Ok(GeneratedField::Markets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryBinaryMarketsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryBinaryMarketsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryBinaryMarketsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut markets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Markets => {
                            if markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("markets"));
                            }
                            markets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryBinaryMarketsResponse {
                    markets: markets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryBinaryMarketsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDenomDecimalRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.denom.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryDenomDecimalRequest", len)?;
        if !self.denom.is_empty() {
            struct_ser.serialize_field("denom", &self.denom)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDenomDecimalRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["denom"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Denom,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "denom" => Ok(GeneratedField::Denom),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDenomDecimalRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryDenomDecimalRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDenomDecimalRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut denom__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Denom => {
                            if denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denom"));
                            }
                            denom__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDenomDecimalRequest {
                    denom: denom__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDenomDecimalRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDenomDecimalResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.decimal != 0 {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryDenomDecimalResponse", len)?;
        if self.decimal != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("decimal", ToString::to_string(&self.decimal).as_str())?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDenomDecimalResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["decimal"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Decimal,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "decimal" => Ok(GeneratedField::Decimal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDenomDecimalResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryDenomDecimalResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDenomDecimalResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut decimal__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Decimal => {
                            if decimal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decimal"));
                            }
                            decimal__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(QueryDenomDecimalResponse {
                    decimal: decimal__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDenomDecimalResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDenomDecimalsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.denoms.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryDenomDecimalsRequest", len)?;
        if !self.denoms.is_empty() {
            struct_ser.serialize_field("denoms", &self.denoms)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDenomDecimalsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["denoms"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Denoms,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "denoms" => Ok(GeneratedField::Denoms),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDenomDecimalsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryDenomDecimalsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDenomDecimalsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut denoms__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Denoms => {
                            if denoms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denoms"));
                            }
                            denoms__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDenomDecimalsRequest {
                    denoms: denoms__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDenomDecimalsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDenomDecimalsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.denom_decimals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryDenomDecimalsResponse", len)?;
        if !self.denom_decimals.is_empty() {
            struct_ser.serialize_field("denomDecimals", &self.denom_decimals)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDenomDecimalsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["denom_decimals", "denomDecimals"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DenomDecimals,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "denomDecimals" | "denom_decimals" => Ok(GeneratedField::DenomDecimals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDenomDecimalsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryDenomDecimalsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDenomDecimalsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut denom_decimals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DenomDecimals => {
                            if denom_decimals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denomDecimals"));
                            }
                            denom_decimals__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDenomDecimalsResponse {
                    denom_decimals: denom_decimals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDenomDecimalsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMarketAddressRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMarketAddressRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMarketAddressRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMarketAddressRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeMarketAddressRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMarketAddressResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.address.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse",
            len,
        )?;
        if !self.address.is_empty() {
            struct_ser.serialize_field("address", &self.address)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMarketAddressResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["address", "subaccount_id", "subaccountId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Address,
            SubaccountId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "address" => Ok(GeneratedField::Address),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMarketAddressResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMarketAddressResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut address__ = None;
                let mut subaccount_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeMarketAddressResponse {
                    address: address__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMarketRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMarketRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMarketRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryDerivativeMarketRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMarketRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeMarketRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketResponse",
            len,
        )?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryDerivativeMarketResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryDerivativeMarketResponse { market: market__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMarketsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.status.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        if self.with_mid_price_and_tob {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketsRequest",
            len,
        )?;
        if !self.status.is_empty() {
            struct_ser.serialize_field("status", &self.status)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        if self.with_mid_price_and_tob {
            struct_ser.serialize_field("withMidPriceAndTob", &self.with_mid_price_and_tob)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMarketsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
            "market_ids",
            "marketIds",
            "with_mid_price_and_tob",
            "withMidPriceAndTob",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
            MarketIds,
            WithMidPriceAndTob,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            "withMidPriceAndTob" | "with_mid_price_and_tob" => {
                                Ok(GeneratedField::WithMidPriceAndTob)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMarketsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryDerivativeMarketsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMarketsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                let mut market_ids__ = None;
                let mut with_mid_price_and_tob__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithMidPriceAndTob => {
                            if with_mid_price_and_tob__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "withMidPriceAndTob",
                                ));
                            }
                            with_mid_price_and_tob__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeMarketsRequest {
                    status: status__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                    with_mid_price_and_tob: with_mid_price_and_tob__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMarketsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.markets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketsResponse",
            len,
        )?;
        if !self.markets.is_empty() {
            struct_ser.serialize_field("markets", &self.markets)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMarketsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["markets"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Markets,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "markets" => Ok(GeneratedField::Markets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMarketsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryDerivativeMarketsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMarketsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut markets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Markets => {
                            if markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("markets"));
                            }
                            markets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeMarketsResponse {
                    markets: markets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMarketsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMidPriceAndTobRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMidPriceAndTobRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMidPriceAndTobRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMidPriceAndTobRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeMidPriceAndTobRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeMidPriceAndTobResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.mid_price.is_empty() {
            len += 1;
        }
        if !self.best_buy_price.is_empty() {
            len += 1;
        }
        if !self.best_sell_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse",
            len,
        )?;
        if !self.mid_price.is_empty() {
            struct_ser.serialize_field("midPrice", &self.mid_price)?;
        }
        if !self.best_buy_price.is_empty() {
            struct_ser.serialize_field("bestBuyPrice", &self.best_buy_price)?;
        }
        if !self.best_sell_price.is_empty() {
            struct_ser.serialize_field("bestSellPrice", &self.best_sell_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeMidPriceAndTobResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mid_price",
            "midPrice",
            "best_buy_price",
            "bestBuyPrice",
            "best_sell_price",
            "bestSellPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MidPrice,
            BestBuyPrice,
            BestSellPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "midPrice" | "mid_price" => Ok(GeneratedField::MidPrice),
                            "bestBuyPrice" | "best_buy_price" => Ok(GeneratedField::BestBuyPrice),
                            "bestSellPrice" | "best_sell_price" => {
                                Ok(GeneratedField::BestSellPrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeMidPriceAndTobResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeMidPriceAndTobResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut mid_price__ = None;
                let mut best_buy_price__ = None;
                let mut best_sell_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MidPrice => {
                            if mid_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("midPrice"));
                            }
                            mid_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BestBuyPrice => {
                            if best_buy_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bestBuyPrice"));
                            }
                            best_buy_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BestSellPrice => {
                            if best_sell_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bestSellPrice"));
                            }
                            best_sell_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeMidPriceAndTobResponse {
                    mid_price: mid_price__.unwrap_or_default(),
                    best_buy_price: best_buy_price__.unwrap_or_default(),
                    best_sell_price: best_sell_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeOrderbookRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.limit != 0 {
            len += 1;
        }
        if !self.limit_cumulative_notional.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrderbookRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.limit != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("limit", ToString::to_string(&self.limit).as_str())?;
        }
        if !self.limit_cumulative_notional.is_empty() {
            struct_ser
                .serialize_field("limitCumulativeNotional", &self.limit_cumulative_notional)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeOrderbookRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "limit",
            "limit_cumulative_notional",
            "limitCumulativeNotional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Limit,
            LimitCumulativeNotional,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "limit" => Ok(GeneratedField::Limit),
                            "limitCumulativeNotional" | "limit_cumulative_notional" => {
                                Ok(GeneratedField::LimitCumulativeNotional)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeOrderbookRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryDerivativeOrderbookRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeOrderbookRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut limit__ = None;
                let mut limit_cumulative_notional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Limit => {
                            if limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limit"));
                            }
                            limit__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::LimitCumulativeNotional => {
                            if limit_cumulative_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "limitCumulativeNotional",
                                ));
                            }
                            limit_cumulative_notional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeOrderbookRequest {
                    market_id: market_id__.unwrap_or_default(),
                    limit: limit__.unwrap_or_default(),
                    limit_cumulative_notional: limit_cumulative_notional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrderbookRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeOrderbookResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.buys_price_level.is_empty() {
            len += 1;
        }
        if !self.sells_price_level.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrderbookResponse",
            len,
        )?;
        if !self.buys_price_level.is_empty() {
            struct_ser.serialize_field("buysPriceLevel", &self.buys_price_level)?;
        }
        if !self.sells_price_level.is_empty() {
            struct_ser.serialize_field("sellsPriceLevel", &self.sells_price_level)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeOrderbookResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "buys_price_level",
            "buysPriceLevel",
            "sells_price_level",
            "sellsPriceLevel",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuysPriceLevel,
            SellsPriceLevel,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "buysPriceLevel" | "buys_price_level" => {
                                Ok(GeneratedField::BuysPriceLevel)
                            }
                            "sellsPriceLevel" | "sells_price_level" => {
                                Ok(GeneratedField::SellsPriceLevel)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeOrderbookResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryDerivativeOrderbookResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeOrderbookResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut buys_price_level__ = None;
                let mut sells_price_level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuysPriceLevel => {
                            if buys_price_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("buysPriceLevel"));
                            }
                            buys_price_level__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SellsPriceLevel => {
                            if sells_price_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sellsPriceLevel"));
                            }
                            sells_price_level__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeOrderbookResponse {
                    buys_price_level: buys_price_level__.unwrap_or_default(),
                    sells_price_level: sells_price_level__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrderbookResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeOrdersByHashesRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.order_hashes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.order_hashes.is_empty() {
            struct_ser.serialize_field("orderHashes", &self.order_hashes)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeOrdersByHashesRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "order_hashes",
            "orderHashes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
            OrderHashes,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "orderHashes" | "order_hashes" => Ok(GeneratedField::OrderHashes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeOrdersByHashesRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeOrdersByHashesRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut order_hashes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHashes => {
                            if order_hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHashes"));
                            }
                            order_hashes__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeOrdersByHashesRequest {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    order_hashes: order_hashes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryDerivativeOrdersByHashesResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse",
            len,
        )?;
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryDerivativeOrdersByHashesResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryDerivativeOrdersByHashesResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryDerivativeOrdersByHashesResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryDerivativeOrdersByHashesResponse {
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryExchangeBalancesRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryExchangeBalancesRequest",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryExchangeBalancesRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryExchangeBalancesRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryExchangeBalancesRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryExchangeBalancesRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryExchangeBalancesRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryExchangeBalancesRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryExchangeBalancesResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.balances.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryExchangeBalancesResponse",
            len,
        )?;
        if !self.balances.is_empty() {
            struct_ser.serialize_field("balances", &self.balances)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryExchangeBalancesResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["balances"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Balances,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "balances" => Ok(GeneratedField::Balances),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryExchangeBalancesResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryExchangeBalancesResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryExchangeBalancesResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut balances__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Balances => {
                            if balances__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balances"));
                            }
                            balances__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryExchangeBalancesResponse {
                    balances: balances__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryExchangeBalancesResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryExchangeParamsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryExchangeParamsRequest", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryExchangeParamsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryExchangeParamsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryExchangeParamsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryExchangeParamsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryExchangeParamsRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryExchangeParamsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryExchangeParamsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.params.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryExchangeParamsResponse",
            len,
        )?;
        if let Some(v) = self.params.as_ref() {
            struct_ser.serialize_field("params", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryExchangeParamsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["params"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Params,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "params" => Ok(GeneratedField::Params),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryExchangeParamsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryExchangeParamsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryExchangeParamsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Params => {
                            if params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("params"));
                            }
                            params__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryExchangeParamsResponse { params: params__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryExchangeParamsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryExpiryFuturesMarketInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryExpiryFuturesMarketInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryExpiryFuturesMarketInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryExpiryFuturesMarketInfoRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryExpiryFuturesMarketInfoRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryExpiryFuturesMarketInfoResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse",
            len,
        )?;
        if let Some(v) = self.info.as_ref() {
            struct_ser.serialize_field("info", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryExpiryFuturesMarketInfoResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["info"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Info,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "info" => Ok(GeneratedField::Info),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryExpiryFuturesMarketInfoResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryExpiryFuturesMarketInfoResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Info => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("info"));
                            }
                            info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryExpiryFuturesMarketInfoResponse { info: info__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFeeDiscountAccountInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest",
            len,
        )?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFeeDiscountAccountInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFeeDiscountAccountInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFeeDiscountAccountInfoRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryFeeDiscountAccountInfoRequest {
                    account: account__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFeeDiscountAccountInfoResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tier_level != 0 {
            len += 1;
        }
        if self.account_info.is_some() {
            len += 1;
        }
        if self.account_ttl.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse",
            len,
        )?;
        if self.tier_level != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser
                .serialize_field("tierLevel", ToString::to_string(&self.tier_level).as_str())?;
        }
        if let Some(v) = self.account_info.as_ref() {
            struct_ser.serialize_field("accountInfo", v)?;
        }
        if let Some(v) = self.account_ttl.as_ref() {
            struct_ser.serialize_field("accountTtl", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFeeDiscountAccountInfoResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "tier_level",
            "tierLevel",
            "account_info",
            "accountInfo",
            "account_ttl",
            "accountTtl",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TierLevel,
            AccountInfo,
            AccountTtl,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tierLevel" | "tier_level" => Ok(GeneratedField::TierLevel),
                            "accountInfo" | "account_info" => Ok(GeneratedField::AccountInfo),
                            "accountTtl" | "account_ttl" => Ok(GeneratedField::AccountTtl),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFeeDiscountAccountInfoResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFeeDiscountAccountInfoResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut tier_level__ = None;
                let mut account_info__ = None;
                let mut account_ttl__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TierLevel => {
                            if tier_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tierLevel"));
                            }
                            tier_level__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::AccountInfo => {
                            if account_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountInfo"));
                            }
                            account_info__ = map_.next_value()?;
                        }
                        GeneratedField::AccountTtl => {
                            if account_ttl__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountTtl"));
                            }
                            account_ttl__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryFeeDiscountAccountInfoResponse {
                    tier_level: tier_level__.unwrap_or_default(),
                    account_info: account_info__,
                    account_ttl: account_ttl__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFeeDiscountScheduleRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFeeDiscountScheduleRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFeeDiscountScheduleRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFeeDiscountScheduleRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryFeeDiscountScheduleRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFeeDiscountScheduleResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.fee_discount_schedule.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse",
            len,
        )?;
        if let Some(v) = self.fee_discount_schedule.as_ref() {
            struct_ser.serialize_field("feeDiscountSchedule", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFeeDiscountScheduleResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["fee_discount_schedule", "feeDiscountSchedule"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FeeDiscountSchedule,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "feeDiscountSchedule" | "fee_discount_schedule" => {
                                Ok(GeneratedField::FeeDiscountSchedule)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFeeDiscountScheduleResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFeeDiscountScheduleResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut fee_discount_schedule__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FeeDiscountSchedule => {
                            if fee_discount_schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "feeDiscountSchedule",
                                ));
                            }
                            fee_discount_schedule__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryFeeDiscountScheduleResponse {
                    fee_discount_schedule: fee_discount_schedule__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFeeDiscountTierStatisticsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFeeDiscountTierStatisticsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFeeDiscountTierStatisticsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFeeDiscountTierStatisticsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryFeeDiscountTierStatisticsRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFeeDiscountTierStatisticsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.statistics.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse",
            len,
        )?;
        if !self.statistics.is_empty() {
            struct_ser.serialize_field("statistics", &self.statistics)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFeeDiscountTierStatisticsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["statistics"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Statistics,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "statistics" => Ok(GeneratedField::Statistics),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFeeDiscountTierStatisticsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFeeDiscountTierStatisticsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut statistics__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Statistics => {
                            if statistics__.is_some() {
                                return Err(serde::de::Error::duplicate_field("statistics"));
                            }
                            statistics__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryFeeDiscountTierStatisticsResponse {
                    statistics: statistics__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFullSpotMarketRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.with_mid_price_and_tob {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryFullSpotMarketRequest", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.with_mid_price_and_tob {
            struct_ser.serialize_field("withMidPriceAndTob", &self.with_mid_price_and_tob)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFullSpotMarketRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "with_mid_price_and_tob",
            "withMidPriceAndTob",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            WithMidPriceAndTob,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "withMidPriceAndTob" | "with_mid_price_and_tob" => {
                                Ok(GeneratedField::WithMidPriceAndTob)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFullSpotMarketRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryFullSpotMarketRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFullSpotMarketRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut with_mid_price_and_tob__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithMidPriceAndTob => {
                            if with_mid_price_and_tob__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "withMidPriceAndTob",
                                ));
                            }
                            with_mid_price_and_tob__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryFullSpotMarketRequest {
                    market_id: market_id__.unwrap_or_default(),
                    with_mid_price_and_tob: with_mid_price_and_tob__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFullSpotMarketRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFullSpotMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFullSpotMarketResponse",
            len,
        )?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFullSpotMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFullSpotMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryFullSpotMarketResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFullSpotMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryFullSpotMarketResponse { market: market__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFullSpotMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFullSpotMarketsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.status.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        if self.with_mid_price_and_tob {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFullSpotMarketsRequest",
            len,
        )?;
        if !self.status.is_empty() {
            struct_ser.serialize_field("status", &self.status)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        if self.with_mid_price_and_tob {
            struct_ser.serialize_field("withMidPriceAndTob", &self.with_mid_price_and_tob)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFullSpotMarketsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
            "market_ids",
            "marketIds",
            "with_mid_price_and_tob",
            "withMidPriceAndTob",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
            MarketIds,
            WithMidPriceAndTob,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            "withMidPriceAndTob" | "with_mid_price_and_tob" => {
                                Ok(GeneratedField::WithMidPriceAndTob)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFullSpotMarketsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryFullSpotMarketsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFullSpotMarketsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                let mut market_ids__ = None;
                let mut with_mid_price_and_tob__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WithMidPriceAndTob => {
                            if with_mid_price_and_tob__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "withMidPriceAndTob",
                                ));
                            }
                            with_mid_price_and_tob__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryFullSpotMarketsRequest {
                    status: status__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                    with_mid_price_and_tob: with_mid_price_and_tob__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFullSpotMarketsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryFullSpotMarketsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.markets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryFullSpotMarketsResponse",
            len,
        )?;
        if !self.markets.is_empty() {
            struct_ser.serialize_field("markets", &self.markets)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryFullSpotMarketsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["markets"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Markets,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "markets" => Ok(GeneratedField::Markets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryFullSpotMarketsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryFullSpotMarketsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryFullSpotMarketsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut markets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Markets => {
                            if markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("markets"));
                            }
                            markets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryFullSpotMarketsResponse {
                    markets: markets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryFullSpotMarketsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryGrantAuthorizationRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.granter.is_empty() {
            len += 1;
        }
        if !self.grantee.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationRequest",
            len,
        )?;
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        if !self.grantee.is_empty() {
            struct_ser.serialize_field("grantee", &self.grantee)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryGrantAuthorizationRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["granter", "grantee"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Granter,
            Grantee,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "granter" => Ok(GeneratedField::Granter),
                            "grantee" => Ok(GeneratedField::Grantee),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryGrantAuthorizationRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryGrantAuthorizationRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryGrantAuthorizationRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut granter__ = None;
                let mut grantee__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Grantee => {
                            if grantee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantee"));
                            }
                            grantee__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryGrantAuthorizationRequest {
                    granter: granter__.unwrap_or_default(),
                    grantee: grantee__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryGrantAuthorizationResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.amount.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationResponse",
            len,
        )?;
        if !self.amount.is_empty() {
            struct_ser.serialize_field("amount", &self.amount)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryGrantAuthorizationResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["amount"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Amount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryGrantAuthorizationResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryGrantAuthorizationResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryGrantAuthorizationResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryGrantAuthorizationResponse {
                    amount: amount__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryGrantAuthorizationsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.granter.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationsRequest",
            len,
        )?;
        if !self.granter.is_empty() {
            struct_ser.serialize_field("granter", &self.granter)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryGrantAuthorizationsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["granter"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Granter,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "granter" => Ok(GeneratedField::Granter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryGrantAuthorizationsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryGrantAuthorizationsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryGrantAuthorizationsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut granter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Granter => {
                            if granter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("granter"));
                            }
                            granter__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryGrantAuthorizationsRequest {
                    granter: granter__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryGrantAuthorizationsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.total_grant_amount.is_empty() {
            len += 1;
        }
        if !self.grants.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationsResponse",
            len,
        )?;
        if !self.total_grant_amount.is_empty() {
            struct_ser.serialize_field("totalGrantAmount", &self.total_grant_amount)?;
        }
        if !self.grants.is_empty() {
            struct_ser.serialize_field("grants", &self.grants)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryGrantAuthorizationsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["total_grant_amount", "totalGrantAmount", "grants"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TotalGrantAmount,
            Grants,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "totalGrantAmount" | "total_grant_amount" => {
                                Ok(GeneratedField::TotalGrantAmount)
                            }
                            "grants" => Ok(GeneratedField::Grants),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryGrantAuthorizationsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryGrantAuthorizationsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryGrantAuthorizationsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut total_grant_amount__ = None;
                let mut grants__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TotalGrantAmount => {
                            if total_grant_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalGrantAmount"));
                            }
                            total_grant_amount__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Grants => {
                            if grants__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grants"));
                            }
                            grants__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryGrantAuthorizationsResponse {
                    total_grant_amount: total_grant_amount__.unwrap_or_default(),
                    grants: grants__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryGrantAuthorizationsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryHistoricalTradeRecordsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryHistoricalTradeRecordsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryHistoricalTradeRecordsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryHistoricalTradeRecordsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryHistoricalTradeRecordsRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryHistoricalTradeRecordsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.trade_records.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse",
            len,
        )?;
        if !self.trade_records.is_empty() {
            struct_ser.serialize_field("tradeRecords", &self.trade_records)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryHistoricalTradeRecordsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["trade_records", "tradeRecords"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TradeRecords,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tradeRecords" | "trade_records" => Ok(GeneratedField::TradeRecords),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryHistoricalTradeRecordsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryHistoricalTradeRecordsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut trade_records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TradeRecords => {
                            if trade_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tradeRecords"));
                            }
                            trade_records__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryHistoricalTradeRecordsResponse {
                    trade_records: trade_records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryIsOptedOutOfRewardsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest",
            len,
        )?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryIsOptedOutOfRewardsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryIsOptedOutOfRewardsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryIsOptedOutOfRewardsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryIsOptedOutOfRewardsRequest {
                    account: account__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryIsOptedOutOfRewardsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_opted_out {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse",
            len,
        )?;
        if self.is_opted_out {
            struct_ser.serialize_field("isOptedOut", &self.is_opted_out)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryIsOptedOutOfRewardsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["is_opted_out", "isOptedOut"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsOptedOut,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isOptedOut" | "is_opted_out" => Ok(GeneratedField::IsOptedOut),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryIsOptedOutOfRewardsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryIsOptedOutOfRewardsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut is_opted_out__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsOptedOut => {
                            if is_opted_out__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isOptedOut"));
                            }
                            is_opted_out__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryIsOptedOutOfRewardsResponse {
                    is_opted_out: is_opted_out__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryMarketAtomicExecutionFeeMultiplierRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryMarketAtomicExecutionFeeMultiplierRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryMarketAtomicExecutionFeeMultiplierRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryMarketAtomicExecutionFeeMultiplierRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryMarketAtomicExecutionFeeMultiplierRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryMarketAtomicExecutionFeeMultiplierResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.multiplier.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse",
            len,
        )?;
        if !self.multiplier.is_empty() {
            struct_ser.serialize_field("multiplier", &self.multiplier)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryMarketAtomicExecutionFeeMultiplierResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["multiplier"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Multiplier,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "multiplier" => Ok(GeneratedField::Multiplier),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryMarketAtomicExecutionFeeMultiplierResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryMarketAtomicExecutionFeeMultiplierResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut multiplier__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Multiplier => {
                            if multiplier__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multiplier"));
                            }
                            multiplier__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryMarketAtomicExecutionFeeMultiplierResponse {
                    multiplier: multiplier__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryMarketIdFromVaultRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.vault_address.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryMarketIDFromVaultRequest",
            len,
        )?;
        if !self.vault_address.is_empty() {
            struct_ser.serialize_field("vaultAddress", &self.vault_address)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryMarketIdFromVaultRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["vault_address", "vaultAddress"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VaultAddress,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "vaultAddress" | "vault_address" => Ok(GeneratedField::VaultAddress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryMarketIdFromVaultRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryMarketIDFromVaultRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryMarketIdFromVaultRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut vault_address__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VaultAddress => {
                            if vault_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vaultAddress"));
                            }
                            vault_address__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryMarketIdFromVaultRequest {
                    vault_address: vault_address__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryMarketIDFromVaultRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryMarketIdFromVaultResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryMarketIDFromVaultResponse",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryMarketIdFromVaultResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryMarketIdFromVaultResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryMarketIDFromVaultResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryMarketIdFromVaultResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryMarketIdFromVaultResponse {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryMarketIDFromVaultResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryMarketVolatilityRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.trade_history_options.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryMarketVolatilityRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.trade_history_options.as_ref() {
            struct_ser.serialize_field("tradeHistoryOptions", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryMarketVolatilityRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "trade_history_options",
            "tradeHistoryOptions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            TradeHistoryOptions,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "tradeHistoryOptions" | "trade_history_options" => {
                                Ok(GeneratedField::TradeHistoryOptions)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryMarketVolatilityRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryMarketVolatilityRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryMarketVolatilityRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut trade_history_options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradeHistoryOptions => {
                            if trade_history_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradeHistoryOptions",
                                ));
                            }
                            trade_history_options__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryMarketVolatilityRequest {
                    market_id: market_id__.unwrap_or_default(),
                    trade_history_options: trade_history_options__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryMarketVolatilityRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryMarketVolatilityResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.volatility.is_empty() {
            len += 1;
        }
        if self.history_metadata.is_some() {
            len += 1;
        }
        if !self.raw_history.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryMarketVolatilityResponse",
            len,
        )?;
        if !self.volatility.is_empty() {
            struct_ser.serialize_field("volatility", &self.volatility)?;
        }
        if let Some(v) = self.history_metadata.as_ref() {
            struct_ser.serialize_field("historyMetadata", v)?;
        }
        if !self.raw_history.is_empty() {
            struct_ser.serialize_field("rawHistory", &self.raw_history)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryMarketVolatilityResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volatility",
            "history_metadata",
            "historyMetadata",
            "raw_history",
            "rawHistory",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Volatility,
            HistoryMetadata,
            RawHistory,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volatility" => Ok(GeneratedField::Volatility),
                            "historyMetadata" | "history_metadata" => {
                                Ok(GeneratedField::HistoryMetadata)
                            }
                            "rawHistory" | "raw_history" => Ok(GeneratedField::RawHistory),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryMarketVolatilityResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryMarketVolatilityResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryMarketVolatilityResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut volatility__ = None;
                let mut history_metadata__ = None;
                let mut raw_history__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Volatility => {
                            if volatility__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volatility"));
                            }
                            volatility__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HistoryMetadata => {
                            if history_metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("historyMetadata"));
                            }
                            history_metadata__ = map_.next_value()?;
                        }
                        GeneratedField::RawHistory => {
                            if raw_history__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rawHistory"));
                            }
                            raw_history__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryMarketVolatilityResponse {
                    volatility: volatility__.unwrap_or_default(),
                    history_metadata: history_metadata__,
                    raw_history: raw_history__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryMarketVolatilityResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryModuleStateRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryModuleStateRequest", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryModuleStateRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryModuleStateRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryModuleStateRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryModuleStateRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryModuleStateRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryModuleStateRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryModuleStateResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryModuleStateResponse", len)?;
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("state", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryModuleStateResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["state"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryModuleStateResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryModuleStateResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryModuleStateResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryModuleStateResponse { state: state__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryModuleStateResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryOptedOutOfRewardsAccountsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryOptedOutOfRewardsAccountsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryOptedOutOfRewardsAccountsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryOptedOutOfRewardsAccountsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryOptedOutOfRewardsAccountsRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryOptedOutOfRewardsAccountsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.accounts.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse",
            len,
        )?;
        if !self.accounts.is_empty() {
            struct_ser.serialize_field("accounts", &self.accounts)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryOptedOutOfRewardsAccountsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["accounts"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Accounts,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accounts" => Ok(GeneratedField::Accounts),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryOptedOutOfRewardsAccountsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryOptedOutOfRewardsAccountsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut accounts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Accounts => {
                            if accounts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accounts"));
                            }
                            accounts__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryOptedOutOfRewardsAccountsResponse {
                    accounts: accounts__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryPerpetualMarketFundingRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryPerpetualMarketFundingRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryPerpetualMarketFundingRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryPerpetualMarketFundingRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryPerpetualMarketFundingRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryPerpetualMarketFundingResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse",
            len,
        )?;
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("state", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryPerpetualMarketFundingResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["state"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryPerpetualMarketFundingResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryPerpetualMarketFundingResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryPerpetualMarketFundingResponse { state: state__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryPerpetualMarketInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryPerpetualMarketInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryPerpetualMarketInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryPerpetualMarketInfoRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryPerpetualMarketInfoRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryPerpetualMarketInfoResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse",
            len,
        )?;
        if let Some(v) = self.info.as_ref() {
            struct_ser.serialize_field("info", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryPerpetualMarketInfoResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["info"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Info,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "info" => Ok(GeneratedField::Info),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryPerpetualMarketInfoResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryPerpetualMarketInfoResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Info => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("info"));
                            }
                            info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QueryPerpetualMarketInfoResponse { info: info__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryPositionsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.QueryPositionsRequest", len)?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryPositionsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryPositionsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryPositionsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryPositionsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryPositionsRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryPositionsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryPositionsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.state.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QueryPositionsResponse", len)?;
        if !self.state.is_empty() {
            struct_ser.serialize_field("state", &self.state)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryPositionsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["state"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryPositionsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryPositionsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryPositionsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryPositionsResponse {
                    state: state__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryPositionsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotMarketRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QuerySpotMarketRequest", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotMarketRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotMarketRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySpotMarketRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotMarketRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotMarketRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotMarketRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.market.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QuerySpotMarketResponse", len)?;
        if let Some(v) = self.market.as_ref() {
            struct_ser.serialize_field("market", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Market,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "market" => Ok(GeneratedField::Market),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySpotMarketResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QuerySpotMarketResponse { market: market__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotMarketsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.status.is_empty() {
            len += 1;
        }
        if !self.market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QuerySpotMarketsRequest", len)?;
        if !self.status.is_empty() {
            struct_ser.serialize_field("status", &self.status)?;
        }
        if !self.market_ids.is_empty() {
            struct_ser.serialize_field("marketIds", &self.market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotMarketsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["status", "market_ids", "marketIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
            MarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            "marketIds" | "market_ids" => Ok(GeneratedField::MarketIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotMarketsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySpotMarketsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotMarketsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                let mut market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketIds => {
                            if market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketIds"));
                            }
                            market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotMarketsRequest {
                    status: status__.unwrap_or_default(),
                    market_ids: market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotMarketsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotMarketsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.markets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QuerySpotMarketsResponse", len)?;
        if !self.markets.is_empty() {
            struct_ser.serialize_field("markets", &self.markets)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotMarketsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["markets"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Markets,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "markets" => Ok(GeneratedField::Markets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotMarketsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySpotMarketsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotMarketsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut markets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Markets => {
                            if markets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("markets"));
                            }
                            markets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotMarketsResponse {
                    markets: markets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotMarketsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotMidPriceAndTobRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotMidPriceAndTobRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotMidPriceAndTobRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotMidPriceAndTobRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotMidPriceAndTobRequest {
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotMidPriceAndTobResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.mid_price.is_empty() {
            len += 1;
        }
        if !self.best_buy_price.is_empty() {
            len += 1;
        }
        if !self.best_sell_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse",
            len,
        )?;
        if !self.mid_price.is_empty() {
            struct_ser.serialize_field("midPrice", &self.mid_price)?;
        }
        if !self.best_buy_price.is_empty() {
            struct_ser.serialize_field("bestBuyPrice", &self.best_buy_price)?;
        }
        if !self.best_sell_price.is_empty() {
            struct_ser.serialize_field("bestSellPrice", &self.best_sell_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotMidPriceAndTobResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mid_price",
            "midPrice",
            "best_buy_price",
            "bestBuyPrice",
            "best_sell_price",
            "bestSellPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MidPrice,
            BestBuyPrice,
            BestSellPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "midPrice" | "mid_price" => Ok(GeneratedField::MidPrice),
                            "bestBuyPrice" | "best_buy_price" => Ok(GeneratedField::BestBuyPrice),
                            "bestSellPrice" | "best_sell_price" => {
                                Ok(GeneratedField::BestSellPrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotMidPriceAndTobResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotMidPriceAndTobResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut mid_price__ = None;
                let mut best_buy_price__ = None;
                let mut best_sell_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MidPrice => {
                            if mid_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("midPrice"));
                            }
                            mid_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BestBuyPrice => {
                            if best_buy_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bestBuyPrice"));
                            }
                            best_buy_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BestSellPrice => {
                            if best_sell_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bestSellPrice"));
                            }
                            best_sell_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotMidPriceAndTobResponse {
                    mid_price: mid_price__.unwrap_or_default(),
                    best_buy_price: best_buy_price__.unwrap_or_default(),
                    best_sell_price: best_sell_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotOrderbookRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.limit != 0 {
            len += 1;
        }
        if self.order_side != 0 {
            len += 1;
        }
        if !self.limit_cumulative_notional.is_empty() {
            len += 1;
        }
        if !self.limit_cumulative_quantity.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QuerySpotOrderbookRequest", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.limit != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("limit", ToString::to_string(&self.limit).as_str())?;
        }
        if self.order_side != 0 {
            let v = OrderSide::try_from(self.order_side).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.order_side))
            })?;
            struct_ser.serialize_field("orderSide", &v)?;
        }
        if !self.limit_cumulative_notional.is_empty() {
            struct_ser
                .serialize_field("limitCumulativeNotional", &self.limit_cumulative_notional)?;
        }
        if !self.limit_cumulative_quantity.is_empty() {
            struct_ser
                .serialize_field("limitCumulativeQuantity", &self.limit_cumulative_quantity)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotOrderbookRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "limit",
            "order_side",
            "orderSide",
            "limit_cumulative_notional",
            "limitCumulativeNotional",
            "limit_cumulative_quantity",
            "limitCumulativeQuantity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            Limit,
            OrderSide,
            LimitCumulativeNotional,
            LimitCumulativeQuantity,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "limit" => Ok(GeneratedField::Limit),
                            "orderSide" | "order_side" => Ok(GeneratedField::OrderSide),
                            "limitCumulativeNotional" | "limit_cumulative_notional" => {
                                Ok(GeneratedField::LimitCumulativeNotional)
                            }
                            "limitCumulativeQuantity" | "limit_cumulative_quantity" => {
                                Ok(GeneratedField::LimitCumulativeQuantity)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotOrderbookRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySpotOrderbookRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotOrderbookRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut limit__ = None;
                let mut order_side__ = None;
                let mut limit_cumulative_notional__ = None;
                let mut limit_cumulative_quantity__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Limit => {
                            if limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limit"));
                            }
                            limit__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::OrderSide => {
                            if order_side__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderSide"));
                            }
                            order_side__ = Some(map_.next_value::<OrderSide>()? as i32);
                        }
                        GeneratedField::LimitCumulativeNotional => {
                            if limit_cumulative_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "limitCumulativeNotional",
                                ));
                            }
                            limit_cumulative_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LimitCumulativeQuantity => {
                            if limit_cumulative_quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "limitCumulativeQuantity",
                                ));
                            }
                            limit_cumulative_quantity__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotOrderbookRequest {
                    market_id: market_id__.unwrap_or_default(),
                    limit: limit__.unwrap_or_default(),
                    order_side: order_side__.unwrap_or_default(),
                    limit_cumulative_notional: limit_cumulative_notional__.unwrap_or_default(),
                    limit_cumulative_quantity: limit_cumulative_quantity__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotOrderbookRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotOrderbookResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.buys_price_level.is_empty() {
            len += 1;
        }
        if !self.sells_price_level.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.QuerySpotOrderbookResponse", len)?;
        if !self.buys_price_level.is_empty() {
            struct_ser.serialize_field("buysPriceLevel", &self.buys_price_level)?;
        }
        if !self.sells_price_level.is_empty() {
            struct_ser.serialize_field("sellsPriceLevel", &self.sells_price_level)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotOrderbookResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "buys_price_level",
            "buysPriceLevel",
            "sells_price_level",
            "sellsPriceLevel",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuysPriceLevel,
            SellsPriceLevel,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "buysPriceLevel" | "buys_price_level" => {
                                Ok(GeneratedField::BuysPriceLevel)
                            }
                            "sellsPriceLevel" | "sells_price_level" => {
                                Ok(GeneratedField::SellsPriceLevel)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotOrderbookResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySpotOrderbookResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotOrderbookResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut buys_price_level__ = None;
                let mut sells_price_level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuysPriceLevel => {
                            if buys_price_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("buysPriceLevel"));
                            }
                            buys_price_level__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SellsPriceLevel => {
                            if sells_price_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sellsPriceLevel"));
                            }
                            sells_price_level__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotOrderbookResponse {
                    buys_price_level: buys_price_level__.unwrap_or_default(),
                    sells_price_level: sells_price_level__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotOrderbookResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotOrdersByHashesRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.order_hashes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.order_hashes.is_empty() {
            struct_ser.serialize_field("orderHashes", &self.order_hashes)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotOrdersByHashesRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "order_hashes",
            "orderHashes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
            OrderHashes,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "orderHashes" | "order_hashes" => Ok(GeneratedField::OrderHashes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotOrdersByHashesRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotOrdersByHashesRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut order_hashes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHashes => {
                            if order_hashes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHashes"));
                            }
                            order_hashes__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotOrdersByHashesRequest {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    order_hashes: order_hashes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySpotOrdersByHashesResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse",
            len,
        )?;
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySpotOrdersByHashesResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySpotOrdersByHashesResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySpotOrdersByHashesResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySpotOrdersByHashesResponse {
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountDepositRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.denom.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            struct_ser.serialize_field("denom", &self.denom)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountDepositRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "denom"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            Denom,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "denom" => Ok(GeneratedField::Denom),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountDepositRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountDepositRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountDepositRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut denom__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Denom => {
                            if denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denom"));
                            }
                            denom__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountDepositRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    denom: denom__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountDepositResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.deposits.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositResponse",
            len,
        )?;
        if let Some(v) = self.deposits.as_ref() {
            struct_ser.serialize_field("deposits", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountDepositResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["deposits"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Deposits,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deposits" => Ok(GeneratedField::Deposits),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountDepositResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountDepositResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountDepositResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut deposits__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Deposits => {
                            if deposits__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deposits"));
                            }
                            deposits__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QuerySubaccountDepositResponse {
                    deposits: deposits__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountDepositsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if self.subaccount.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositsRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if let Some(v) = self.subaccount.as_ref() {
            struct_ser.serialize_field("subaccount", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountDepositsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "subaccount"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            Subaccount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "subaccount" => Ok(GeneratedField::Subaccount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountDepositsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountDepositsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountDepositsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut subaccount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Subaccount => {
                            if subaccount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccount"));
                            }
                            subaccount__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QuerySubaccountDepositsRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    subaccount: subaccount__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountDepositsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.deposits.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositsResponse",
            len,
        )?;
        if !self.deposits.is_empty() {
            struct_ser.serialize_field("deposits", &self.deposits)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountDepositsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["deposits"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Deposits,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deposits" => Ok(GeneratedField::Deposits),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountDepositsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountDepositsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountDepositsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut deposits__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Deposits => {
                            if deposits__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deposits"));
                            }
                            deposits__ =
                                Some(map_.next_value::<std::collections::HashMap<_, _>>()?);
                        }
                    }
                }
                Ok(QuerySubaccountDepositsResponse {
                    deposits: deposits__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountDepositsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountEffectivePositionInMarketRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountEffectivePositionInMarketRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountEffectivePositionInMarketRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountEffectivePositionInMarketRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountEffectivePositionInMarketRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountEffectivePositionInMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse",
            len,
        )?;
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("state", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountEffectivePositionInMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["state"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountEffectivePositionInMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountEffectivePositionInMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QuerySubaccountEffectivePositionInMarketResponse { state: state__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountOrderMetadataRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountOrderMetadataRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountOrderMetadataRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountOrderMetadataRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountOrderMetadataRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountOrderMetadataResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.metadata.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse",
            len,
        )?;
        if !self.metadata.is_empty() {
            struct_ser.serialize_field("metadata", &self.metadata)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountOrderMetadataResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["metadata"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountOrderMetadataResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountOrderMetadataResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountOrderMetadataResponse {
                    metadata: metadata__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountOrdersRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrdersRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountOrdersRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountOrdersRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountOrdersRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountOrdersRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountOrdersRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrdersRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.buy_orders.is_empty() {
            len += 1;
        }
        if !self.sell_orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrdersResponse",
            len,
        )?;
        if !self.buy_orders.is_empty() {
            struct_ser.serialize_field("buyOrders", &self.buy_orders)?;
        }
        if !self.sell_orders.is_empty() {
            struct_ser.serialize_field("sellOrders", &self.sell_orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["buy_orders", "buyOrders", "sell_orders", "sellOrders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuyOrders,
            SellOrders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "buyOrders" | "buy_orders" => Ok(GeneratedField::BuyOrders),
                            "sellOrders" | "sell_orders" => Ok(GeneratedField::SellOrders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountOrdersResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut buy_orders__ = None;
                let mut sell_orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuyOrders => {
                            if buy_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("buyOrders"));
                            }
                            buy_orders__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SellOrders => {
                            if sell_orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sellOrders"));
                            }
                            sell_orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountOrdersResponse {
                    buy_orders: buy_orders__.unwrap_or_default(),
                    sell_orders: sell_orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountPositionInMarketRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountPositionInMarketRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountPositionInMarketRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountPositionInMarketRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountPositionInMarketRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountPositionInMarketResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse",
            len,
        )?;
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("state", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountPositionInMarketResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["state"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountPositionInMarketResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountPositionInMarketResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = map_.next_value()?;
                        }
                    }
                }
                Ok(QuerySubaccountPositionInMarketResponse { state: state__ })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountPositionsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionsRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountPositionsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountPositionsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountPositionsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountPositionsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountPositionsRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountPositionsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.state.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionsResponse",
            len,
        )?;
        if !self.state.is_empty() {
            struct_ser.serialize_field("state", &self.state)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountPositionsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["state"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountPositionsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountPositionsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountPositionsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountPositionsResponse {
                    state: state__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountPositionsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountTradeNonceRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountTradeNonceRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountTradeNonceRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountTradeNonceRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QuerySubaccountTradeNonceRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QuerySubaccountTradeNonceResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.nonce != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse",
            len,
        )?;
        if self.nonce != 0 {
            struct_ser.serialize_field("nonce", &self.nonce)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QuerySubaccountTradeNonceResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["nonce"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Nonce,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nonce" => Ok(GeneratedField::Nonce),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuerySubaccountTradeNonceResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QuerySubaccountTradeNonceResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut nonce__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Nonce => {
                            if nonce__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonce"));
                            }
                            nonce__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(QuerySubaccountTradeNonceResponse {
                    nonce: nonce__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTradeRewardCampaignRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardCampaignRequest",
            len,
        )?;
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTradeRewardCampaignRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {}
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTradeRewardCampaignRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryTradeRewardCampaignRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTradeRewardCampaignRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(QueryTradeRewardCampaignRequest {})
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardCampaignRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTradeRewardCampaignResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.trading_reward_campaign_info.is_some() {
            len += 1;
        }
        if !self.trading_reward_pool_campaign_schedule.is_empty() {
            len += 1;
        }
        if !self.total_trade_reward_points.is_empty() {
            len += 1;
        }
        if !self
            .pending_trading_reward_pool_campaign_schedule
            .is_empty()
        {
            len += 1;
        }
        if !self.pending_total_trade_reward_points.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardCampaignResponse",
            len,
        )?;
        if let Some(v) = self.trading_reward_campaign_info.as_ref() {
            struct_ser.serialize_field("tradingRewardCampaignInfo", v)?;
        }
        if !self.trading_reward_pool_campaign_schedule.is_empty() {
            struct_ser.serialize_field(
                "tradingRewardPoolCampaignSchedule",
                &self.trading_reward_pool_campaign_schedule,
            )?;
        }
        if !self.total_trade_reward_points.is_empty() {
            struct_ser
                .serialize_field("totalTradeRewardPoints", &self.total_trade_reward_points)?;
        }
        if !self
            .pending_trading_reward_pool_campaign_schedule
            .is_empty()
        {
            struct_ser.serialize_field(
                "pendingTradingRewardPoolCampaignSchedule",
                &self.pending_trading_reward_pool_campaign_schedule,
            )?;
        }
        if !self.pending_total_trade_reward_points.is_empty() {
            struct_ser.serialize_field(
                "pendingTotalTradeRewardPoints",
                &self.pending_total_trade_reward_points,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTradeRewardCampaignResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "trading_reward_campaign_info",
            "tradingRewardCampaignInfo",
            "trading_reward_pool_campaign_schedule",
            "tradingRewardPoolCampaignSchedule",
            "total_trade_reward_points",
            "totalTradeRewardPoints",
            "pending_trading_reward_pool_campaign_schedule",
            "pendingTradingRewardPoolCampaignSchedule",
            "pending_total_trade_reward_points",
            "pendingTotalTradeRewardPoints",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TradingRewardCampaignInfo,
            TradingRewardPoolCampaignSchedule,
            TotalTradeRewardPoints,
            PendingTradingRewardPoolCampaignSchedule,
            PendingTotalTradeRewardPoints,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tradingRewardCampaignInfo" | "trading_reward_campaign_info" => {
                                Ok(GeneratedField::TradingRewardCampaignInfo)
                            }
                            "tradingRewardPoolCampaignSchedule"
                            | "trading_reward_pool_campaign_schedule" => {
                                Ok(GeneratedField::TradingRewardPoolCampaignSchedule)
                            }
                            "totalTradeRewardPoints" | "total_trade_reward_points" => {
                                Ok(GeneratedField::TotalTradeRewardPoints)
                            }
                            "pendingTradingRewardPoolCampaignSchedule"
                            | "pending_trading_reward_pool_campaign_schedule" => {
                                Ok(GeneratedField::PendingTradingRewardPoolCampaignSchedule)
                            }
                            "pendingTotalTradeRewardPoints"
                            | "pending_total_trade_reward_points" => {
                                Ok(GeneratedField::PendingTotalTradeRewardPoints)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTradeRewardCampaignResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryTradeRewardCampaignResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTradeRewardCampaignResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut trading_reward_campaign_info__ = None;
                let mut trading_reward_pool_campaign_schedule__ = None;
                let mut total_trade_reward_points__ = None;
                let mut pending_trading_reward_pool_campaign_schedule__ = None;
                let mut pending_total_trade_reward_points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TradingRewardCampaignInfo => {
                            if trading_reward_campaign_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardCampaignInfo",
                                ));
                            }
                            trading_reward_campaign_info__ = map_.next_value()?;
                        }
                        GeneratedField::TradingRewardPoolCampaignSchedule => {
                            if trading_reward_pool_campaign_schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardPoolCampaignSchedule",
                                ));
                            }
                            trading_reward_pool_campaign_schedule__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TotalTradeRewardPoints => {
                            if total_trade_reward_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "totalTradeRewardPoints",
                                ));
                            }
                            total_trade_reward_points__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PendingTradingRewardPoolCampaignSchedule => {
                            if pending_trading_reward_pool_campaign_schedule__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "pendingTradingRewardPoolCampaignSchedule",
                                ));
                            }
                            pending_trading_reward_pool_campaign_schedule__ =
                                Some(map_.next_value()?);
                        }
                        GeneratedField::PendingTotalTradeRewardPoints => {
                            if pending_total_trade_reward_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "pendingTotalTradeRewardPoints",
                                ));
                            }
                            pending_total_trade_reward_points__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTradeRewardCampaignResponse {
                    trading_reward_campaign_info: trading_reward_campaign_info__,
                    trading_reward_pool_campaign_schedule: trading_reward_pool_campaign_schedule__
                        .unwrap_or_default(),
                    total_trade_reward_points: total_trade_reward_points__.unwrap_or_default(),
                    pending_trading_reward_pool_campaign_schedule:
                        pending_trading_reward_pool_campaign_schedule__.unwrap_or_default(),
                    pending_total_trade_reward_points: pending_total_trade_reward_points__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardCampaignResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTradeRewardPointsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.accounts.is_empty() {
            len += 1;
        }
        if self.pending_pool_timestamp != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardPointsRequest",
            len,
        )?;
        if !self.accounts.is_empty() {
            struct_ser.serialize_field("accounts", &self.accounts)?;
        }
        if self.pending_pool_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "pendingPoolTimestamp",
                ToString::to_string(&self.pending_pool_timestamp).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTradeRewardPointsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["accounts", "pending_pool_timestamp", "pendingPoolTimestamp"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Accounts,
            PendingPoolTimestamp,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accounts" => Ok(GeneratedField::Accounts),
                            "pendingPoolTimestamp" | "pending_pool_timestamp" => {
                                Ok(GeneratedField::PendingPoolTimestamp)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTradeRewardPointsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryTradeRewardPointsRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTradeRewardPointsRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut accounts__ = None;
                let mut pending_pool_timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Accounts => {
                            if accounts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accounts"));
                            }
                            accounts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PendingPoolTimestamp => {
                            if pending_pool_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "pendingPoolTimestamp",
                                ));
                            }
                            pending_pool_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(QueryTradeRewardPointsRequest {
                    accounts: accounts__.unwrap_or_default(),
                    pending_pool_timestamp: pending_pool_timestamp__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardPointsRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTradeRewardPointsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account_trade_reward_points.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardPointsResponse",
            len,
        )?;
        if !self.account_trade_reward_points.is_empty() {
            struct_ser.serialize_field(
                "accountTradeRewardPoints",
                &self.account_trade_reward_points,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTradeRewardPointsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account_trade_reward_points", "accountTradeRewardPoints"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AccountTradeRewardPoints,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accountTradeRewardPoints" | "account_trade_reward_points" => {
                                Ok(GeneratedField::AccountTradeRewardPoints)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTradeRewardPointsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryTradeRewardPointsResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTradeRewardPointsResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account_trade_reward_points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AccountTradeRewardPoints => {
                            if account_trade_reward_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "accountTradeRewardPoints",
                                ));
                            }
                            account_trade_reward_points__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTradeRewardPointsResponse {
                    account_trade_reward_points: account_trade_reward_points__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTradeRewardPointsResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderDerivativeConditionalOrdersRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest",
            len,
        )?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderDerivativeConditionalOrdersRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "market_id", "marketId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            MarketId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderDerivativeConditionalOrdersRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderDerivativeConditionalOrdersRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut market_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderDerivativeConditionalOrdersRequest {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderDerivativeConditionalOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse",
            len,
        )?;
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderDerivativeConditionalOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderDerivativeConditionalOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderDerivativeConditionalOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderDerivativeConditionalOrdersResponse {
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderDerivativeOrdersRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderDerivativeOrdersRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "subaccount_id", "subaccountId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderDerivativeOrdersRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderDerivativeOrdersRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderDerivativeOrdersRequest {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderDerivativeOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse",
            len,
        )?;
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderDerivativeOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderDerivativeOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderDerivativeOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderDerivativeOrdersResponse {
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.quote_amount.is_empty() {
            len += 1;
        }
        if self.strategy != 0 {
            len += 1;
        }
        if !self.reference_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.quote_amount.is_empty() {
            struct_ser.serialize_field("quoteAmount", &self.quote_amount)?;
        }
        if self.strategy != 0 {
            let v = CancellationStrategy::try_from(self.strategy).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.strategy))
            })?;
            struct_ser.serialize_field("strategy", &v)?;
        }
        if !self.reference_price.is_empty() {
            struct_ser.serialize_field("referencePrice", &self.reference_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "quote_amount",
            "quoteAmount",
            "strategy",
            "reference_price",
            "referencePrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
            QuoteAmount,
            Strategy,
            ReferencePrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "quoteAmount" | "quote_amount" => Ok(GeneratedField::QuoteAmount),
                            "strategy" => Ok(GeneratedField::Strategy),
                            "referencePrice" | "reference_price" => {
                                Ok(GeneratedField::ReferencePrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderDerivativeOrdersToCancelUpToAmountRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderDerivativeOrdersToCancelUpToAmountRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut quote_amount__ = None;
                let mut strategy__ = None;
                let mut reference_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteAmount => {
                            if quote_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteAmount"));
                            }
                            quote_amount__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Strategy => {
                            if strategy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strategy"));
                            }
                            strategy__ = Some(map_.next_value::<CancellationStrategy>()? as i32);
                        }
                        GeneratedField::ReferencePrice => {
                            if reference_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("referencePrice"));
                            }
                            reference_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    quote_amount: quote_amount__.unwrap_or_default(),
                    strategy: strategy__.unwrap_or_default(),
                    reference_price: reference_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderSpotOrdersRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderSpotOrdersRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderSpotOrdersRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "subaccount_id", "subaccountId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderSpotOrdersRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryTraderSpotOrdersRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderSpotOrdersRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderSpotOrdersRequest {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderSpotOrdersRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderSpotOrdersResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderSpotOrdersResponse",
            len,
        )?;
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderSpotOrdersResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderSpotOrdersResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.QueryTraderSpotOrdersResponse")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderSpotOrdersResponse, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderSpotOrdersResponse {
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderSpotOrdersResponse",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryTraderSpotOrdersToCancelUpToAmountRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.base_amount.is_empty() {
            len += 1;
        }
        if !self.quote_amount.is_empty() {
            len += 1;
        }
        if self.strategy != 0 {
            len += 1;
        }
        if !self.reference_price.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest",
            len,
        )?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if !self.base_amount.is_empty() {
            struct_ser.serialize_field("baseAmount", &self.base_amount)?;
        }
        if !self.quote_amount.is_empty() {
            struct_ser.serialize_field("quoteAmount", &self.quote_amount)?;
        }
        if self.strategy != 0 {
            let v = CancellationStrategy::try_from(self.strategy).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.strategy))
            })?;
            struct_ser.serialize_field("strategy", &v)?;
        }
        if !self.reference_price.is_empty() {
            struct_ser.serialize_field("referencePrice", &self.reference_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for QueryTraderSpotOrdersToCancelUpToAmountRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "subaccount_id",
            "subaccountId",
            "base_amount",
            "baseAmount",
            "quote_amount",
            "quoteAmount",
            "strategy",
            "reference_price",
            "referencePrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            SubaccountId,
            BaseAmount,
            QuoteAmount,
            Strategy,
            ReferencePrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "baseAmount" | "base_amount" => Ok(GeneratedField::BaseAmount),
                            "quoteAmount" | "quote_amount" => Ok(GeneratedField::QuoteAmount),
                            "strategy" => Ok(GeneratedField::Strategy),
                            "referencePrice" | "reference_price" => {
                                Ok(GeneratedField::ReferencePrice)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QueryTraderSpotOrdersToCancelUpToAmountRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<QueryTraderSpotOrdersToCancelUpToAmountRequest, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut subaccount_id__ = None;
                let mut base_amount__ = None;
                let mut quote_amount__ = None;
                let mut strategy__ = None;
                let mut reference_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BaseAmount => {
                            if base_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("baseAmount"));
                            }
                            base_amount__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteAmount => {
                            if quote_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteAmount"));
                            }
                            quote_amount__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Strategy => {
                            if strategy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strategy"));
                            }
                            strategy__ = Some(map_.next_value::<CancellationStrategy>()? as i32);
                        }
                        GeneratedField::ReferencePrice => {
                            if reference_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("referencePrice"));
                            }
                            reference_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(QueryTraderSpotOrdersToCancelUpToAmountRequest {
                    market_id: market_id__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    base_amount: base_amount__.unwrap_or_default(),
                    quote_amount: quote_amount__.unwrap_or_default(),
                    strategy: strategy__.unwrap_or_default(),
                    reference_price: reference_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for RewardPointUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account_address.is_empty() {
            len += 1;
        }
        if !self.new_points.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.RewardPointUpdate", len)?;
        if !self.account_address.is_empty() {
            struct_ser.serialize_field("accountAddress", &self.account_address)?;
        }
        if !self.new_points.is_empty() {
            struct_ser.serialize_field("newPoints", &self.new_points)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for RewardPointUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "account_address",
            "accountAddress",
            "new_points",
            "newPoints",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AccountAddress,
            NewPoints,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accountAddress" | "account_address" => {
                                Ok(GeneratedField::AccountAddress)
                            }
                            "newPoints" | "new_points" => Ok(GeneratedField::NewPoints),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RewardPointUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.RewardPointUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RewardPointUpdate, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account_address__ = None;
                let mut new_points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AccountAddress => {
                            if account_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountAddress"));
                            }
                            account_address__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NewPoints => {
                            if new_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newPoints"));
                            }
                            new_points__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RewardPointUpdate {
                    account_address: account_address__.unwrap_or_default(),
                    new_points: new_points__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.RewardPointUpdate",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotLimitOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.order_info.is_some() {
            len += 1;
        }
        if self.order_type != 0 {
            len += 1;
        }
        if !self.fillable.is_empty() {
            len += 1;
        }
        if !self.trigger_price.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SpotLimitOrder", len)?;
        if let Some(v) = self.order_info.as_ref() {
            struct_ser.serialize_field("orderInfo", v)?;
        }
        if self.order_type != 0 {
            let v = OrderType::try_from(self.order_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.order_type))
            })?;
            struct_ser.serialize_field("orderType", &v)?;
        }
        if !self.fillable.is_empty() {
            struct_ser.serialize_field("fillable", &self.fillable)?;
        }
        if !self.trigger_price.is_empty() {
            struct_ser.serialize_field("triggerPrice", &self.trigger_price)?;
        }
        if !self.order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "orderHash",
                pbjson::private::base64::encode(&self.order_hash).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotLimitOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "order_info",
            "orderInfo",
            "order_type",
            "orderType",
            "fillable",
            "trigger_price",
            "triggerPrice",
            "order_hash",
            "orderHash",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderInfo,
            OrderType,
            Fillable,
            TriggerPrice,
            OrderHash,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderInfo" | "order_info" => Ok(GeneratedField::OrderInfo),
                            "orderType" | "order_type" => Ok(GeneratedField::OrderType),
                            "fillable" => Ok(GeneratedField::Fillable),
                            "triggerPrice" | "trigger_price" => Ok(GeneratedField::TriggerPrice),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotLimitOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SpotLimitOrder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpotLimitOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_info__ = None;
                let mut order_type__ = None;
                let mut fillable__ = None;
                let mut trigger_price__ = None;
                let mut order_hash__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderInfo => {
                            if order_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderInfo"));
                            }
                            order_info__ = map_.next_value()?;
                        }
                        GeneratedField::OrderType => {
                            if order_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderType"));
                            }
                            order_type__ = Some(map_.next_value::<OrderType>()? as i32);
                        }
                        GeneratedField::Fillable => {
                            if fillable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fillable"));
                            }
                            fillable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TriggerPrice => {
                            if trigger_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggerPrice"));
                            }
                            trigger_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(SpotLimitOrder {
                    order_info: order_info__,
                    order_type: order_type__.unwrap_or_default(),
                    fillable: fillable__.unwrap_or_default(),
                    trigger_price: trigger_price__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotLimitOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.base_denom.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.status != 0 {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if !self.admin.is_empty() {
            len += 1;
        }
        if self.admin_permissions != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SpotMarket", len)?;
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.base_denom.is_empty() {
            struct_ser.serialize_field("baseDenom", &self.base_denom)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            struct_ser.serialize_field("relayerFeeShareRate", &self.relayer_fee_share_rate)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.status != 0 {
            let v = MarketStatus::try_from(self.status).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.status))
            })?;
            struct_ser.serialize_field("status", &v)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if !self.admin.is_empty() {
            struct_ser.serialize_field("admin", &self.admin)?;
        }
        if self.admin_permissions != 0 {
            struct_ser.serialize_field("adminPermissions", &self.admin_permissions)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ticker",
            "base_denom",
            "baseDenom",
            "quote_denom",
            "quoteDenom",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "relayer_fee_share_rate",
            "relayerFeeShareRate",
            "market_id",
            "marketId",
            "status",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "min_notional",
            "minNotional",
            "admin",
            "admin_permissions",
            "adminPermissions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ticker,
            BaseDenom,
            QuoteDenom,
            MakerFeeRate,
            TakerFeeRate,
            RelayerFeeShareRate,
            MarketId,
            Status,
            MinPriceTickSize,
            MinQuantityTickSize,
            MinNotional,
            Admin,
            AdminPermissions,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ticker" => Ok(GeneratedField::Ticker),
                            "baseDenom" | "base_denom" => Ok(GeneratedField::BaseDenom),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "relayerFeeShareRate" | "relayer_fee_share_rate" => {
                                Ok(GeneratedField::RelayerFeeShareRate)
                            }
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "status" => Ok(GeneratedField::Status),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "admin" => Ok(GeneratedField::Admin),
                            "adminPermissions" | "admin_permissions" => {
                                Ok(GeneratedField::AdminPermissions)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SpotMarket")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpotMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut ticker__ = None;
                let mut base_denom__ = None;
                let mut quote_denom__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut relayer_fee_share_rate__ = None;
                let mut market_id__ = None;
                let mut status__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut min_notional__ = None;
                let mut admin__ = None;
                let mut admin_permissions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BaseDenom => {
                            if base_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("baseDenom"));
                            }
                            base_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RelayerFeeShareRate => {
                            if relayer_fee_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "relayerFeeShareRate",
                                ));
                            }
                            relayer_fee_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<MarketStatus>()? as i32);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Admin => {
                            if admin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("admin"));
                            }
                            admin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminPermissions => {
                            if admin_permissions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminPermissions"));
                            }
                            admin_permissions__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(SpotMarket {
                    ticker: ticker__.unwrap_or_default(),
                    base_denom: base_denom__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    relayer_fee_share_rate: relayer_fee_share_rate__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    status: status__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin: admin__.unwrap_or_default(),
                    admin_permissions: admin_permissions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotMarketLaunchProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.base_denom.is_empty() {
            len += 1;
        }
        if !self.quote_denom.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if self.admin_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.SpotMarketLaunchProposal", len)?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.base_denom.is_empty() {
            struct_ser.serialize_field("baseDenom", &self.base_denom)?;
        }
        if !self.quote_denom.is_empty() {
            struct_ser.serialize_field("quoteDenom", &self.quote_denom)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if let Some(v) = self.admin_info.as_ref() {
            struct_ser.serialize_field("adminInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotMarketLaunchProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "ticker",
            "base_denom",
            "baseDenom",
            "quote_denom",
            "quoteDenom",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "min_notional",
            "minNotional",
            "admin_info",
            "adminInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            Ticker,
            BaseDenom,
            QuoteDenom,
            MinPriceTickSize,
            MinQuantityTickSize,
            MakerFeeRate,
            TakerFeeRate,
            MinNotional,
            AdminInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "baseDenom" | "base_denom" => Ok(GeneratedField::BaseDenom),
                            "quoteDenom" | "quote_denom" => Ok(GeneratedField::QuoteDenom),
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "adminInfo" | "admin_info" => Ok(GeneratedField::AdminInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotMarketLaunchProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SpotMarketLaunchProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<SpotMarketLaunchProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut ticker__ = None;
                let mut base_denom__ = None;
                let mut quote_denom__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut min_notional__ = None;
                let mut admin_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BaseDenom => {
                            if base_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("baseDenom"));
                            }
                            base_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::QuoteDenom => {
                            if quote_denom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenom"));
                            }
                            quote_denom__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminInfo => {
                            if admin_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminInfo"));
                            }
                            admin_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SpotMarketLaunchProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    base_denom: base_denom__.unwrap_or_default(),
                    quote_denom: quote_denom__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin_info: admin_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotMarketLaunchProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotMarketOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.order_info.is_some() {
            len += 1;
        }
        if !self.balance_hold.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if self.order_type != 0 {
            len += 1;
        }
        if !self.trigger_price.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SpotMarketOrder", len)?;
        if let Some(v) = self.order_info.as_ref() {
            struct_ser.serialize_field("orderInfo", v)?;
        }
        if !self.balance_hold.is_empty() {
            struct_ser.serialize_field("balanceHold", &self.balance_hold)?;
        }
        if !self.order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "orderHash",
                pbjson::private::base64::encode(&self.order_hash).as_str(),
            )?;
        }
        if self.order_type != 0 {
            let v = OrderType::try_from(self.order_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.order_type))
            })?;
            struct_ser.serialize_field("orderType", &v)?;
        }
        if !self.trigger_price.is_empty() {
            struct_ser.serialize_field("triggerPrice", &self.trigger_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotMarketOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "order_info",
            "orderInfo",
            "balance_hold",
            "balanceHold",
            "order_hash",
            "orderHash",
            "order_type",
            "orderType",
            "trigger_price",
            "triggerPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OrderInfo,
            BalanceHold,
            OrderHash,
            OrderType,
            TriggerPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "orderInfo" | "order_info" => Ok(GeneratedField::OrderInfo),
                            "balanceHold" | "balance_hold" => Ok(GeneratedField::BalanceHold),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "orderType" | "order_type" => Ok(GeneratedField::OrderType),
                            "triggerPrice" | "trigger_price" => Ok(GeneratedField::TriggerPrice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotMarketOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SpotMarketOrder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpotMarketOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order_info__ = None;
                let mut balance_hold__ = None;
                let mut order_hash__ = None;
                let mut order_type__ = None;
                let mut trigger_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OrderInfo => {
                            if order_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderInfo"));
                            }
                            order_info__ = map_.next_value()?;
                        }
                        GeneratedField::BalanceHold => {
                            if balance_hold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceHold"));
                            }
                            balance_hold__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::OrderType => {
                            if order_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderType"));
                            }
                            order_type__ = Some(map_.next_value::<OrderType>()? as i32);
                        }
                        GeneratedField::TriggerPrice => {
                            if trigger_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggerPrice"));
                            }
                            trigger_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SpotMarketOrder {
                    order_info: order_info__,
                    balance_hold: balance_hold__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    order_type: order_type__.unwrap_or_default(),
                    trigger_price: trigger_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotMarketOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotMarketOrderResults {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.fee.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.SpotMarketOrderResults", len)?;
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.fee.is_empty() {
            struct_ser.serialize_field("fee", &self.fee)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotMarketOrderResults {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["quantity", "price", "fee"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Quantity,
            Price,
            Fee,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "quantity" => Ok(GeneratedField::Quantity),
                            "price" => Ok(GeneratedField::Price),
                            "fee" => Ok(GeneratedField::Fee),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotMarketOrderResults;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SpotMarketOrderResults")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<SpotMarketOrderResults, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut quantity__ = None;
                let mut price__ = None;
                let mut fee__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fee => {
                            if fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fee"));
                            }
                            fee__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SpotMarketOrderResults {
                    quantity: quantity__.unwrap_or_default(),
                    price: price__.unwrap_or_default(),
                    fee: fee__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotMarketOrderResults",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotMarketParamUpdateProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.maker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.taker_fee_rate.is_empty() {
            len += 1;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            len += 1;
        }
        if !self.min_price_tick_size.is_empty() {
            len += 1;
        }
        if !self.min_quantity_tick_size.is_empty() {
            len += 1;
        }
        if self.status != 0 {
            len += 1;
        }
        if !self.ticker.is_empty() {
            len += 1;
        }
        if !self.min_notional.is_empty() {
            len += 1;
        }
        if self.admin_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.SpotMarketParamUpdateProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.maker_fee_rate.is_empty() {
            struct_ser.serialize_field("makerFeeRate", &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            struct_ser.serialize_field("takerFeeRate", &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            struct_ser.serialize_field("relayerFeeShareRate", &self.relayer_fee_share_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            struct_ser.serialize_field("minPriceTickSize", &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            struct_ser.serialize_field("minQuantityTickSize", &self.min_quantity_tick_size)?;
        }
        if self.status != 0 {
            let v = MarketStatus::try_from(self.status).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.status))
            })?;
            struct_ser.serialize_field("status", &v)?;
        }
        if !self.ticker.is_empty() {
            struct_ser.serialize_field("ticker", &self.ticker)?;
        }
        if !self.min_notional.is_empty() {
            struct_ser.serialize_field("minNotional", &self.min_notional)?;
        }
        if let Some(v) = self.admin_info.as_ref() {
            struct_ser.serialize_field("adminInfo", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotMarketParamUpdateProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "market_id",
            "marketId",
            "maker_fee_rate",
            "makerFeeRate",
            "taker_fee_rate",
            "takerFeeRate",
            "relayer_fee_share_rate",
            "relayerFeeShareRate",
            "min_price_tick_size",
            "minPriceTickSize",
            "min_quantity_tick_size",
            "minQuantityTickSize",
            "status",
            "ticker",
            "min_notional",
            "minNotional",
            "admin_info",
            "adminInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            MarketId,
            MakerFeeRate,
            TakerFeeRate,
            RelayerFeeShareRate,
            MinPriceTickSize,
            MinQuantityTickSize,
            Status,
            Ticker,
            MinNotional,
            AdminInfo,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "makerFeeRate" | "maker_fee_rate" => Ok(GeneratedField::MakerFeeRate),
                            "takerFeeRate" | "taker_fee_rate" => Ok(GeneratedField::TakerFeeRate),
                            "relayerFeeShareRate" | "relayer_fee_share_rate" => {
                                Ok(GeneratedField::RelayerFeeShareRate)
                            }
                            "minPriceTickSize" | "min_price_tick_size" => {
                                Ok(GeneratedField::MinPriceTickSize)
                            }
                            "minQuantityTickSize" | "min_quantity_tick_size" => {
                                Ok(GeneratedField::MinQuantityTickSize)
                            }
                            "status" => Ok(GeneratedField::Status),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "minNotional" | "min_notional" => Ok(GeneratedField::MinNotional),
                            "adminInfo" | "admin_info" => Ok(GeneratedField::AdminInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotMarketParamUpdateProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.SpotMarketParamUpdateProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<SpotMarketParamUpdateProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut market_id__ = None;
                let mut maker_fee_rate__ = None;
                let mut taker_fee_rate__ = None;
                let mut relayer_fee_share_rate__ = None;
                let mut min_price_tick_size__ = None;
                let mut min_quantity_tick_size__ = None;
                let mut status__ = None;
                let mut ticker__ = None;
                let mut min_notional__ = None;
                let mut admin_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MakerFeeRate => {
                            if maker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerFeeRate"));
                            }
                            maker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerFeeRate => {
                            if taker_fee_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerFeeRate"));
                            }
                            taker_fee_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RelayerFeeShareRate => {
                            if relayer_fee_share_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "relayerFeeShareRate",
                                ));
                            }
                            relayer_fee_share_rate__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinPriceTickSize => {
                            if min_price_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minPriceTickSize"));
                            }
                            min_price_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinQuantityTickSize => {
                            if min_quantity_tick_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "minQuantityTickSize",
                                ));
                            }
                            min_quantity_tick_size__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<MarketStatus>()? as i32);
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinNotional => {
                            if min_notional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minNotional"));
                            }
                            min_notional__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdminInfo => {
                            if admin_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adminInfo"));
                            }
                            admin_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SpotMarketParamUpdateProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    market_id: market_id__.unwrap_or_default(),
                    maker_fee_rate: maker_fee_rate__.unwrap_or_default(),
                    taker_fee_rate: taker_fee_rate__.unwrap_or_default(),
                    relayer_fee_share_rate: relayer_fee_share_rate__.unwrap_or_default(),
                    min_price_tick_size: min_price_tick_size__.unwrap_or_default(),
                    min_quantity_tick_size: min_quantity_tick_size__.unwrap_or_default(),
                    status: status__.unwrap_or_default(),
                    ticker: ticker__.unwrap_or_default(),
                    min_notional: min_notional__.unwrap_or_default(),
                    admin_info: admin_info__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotMarketParamUpdateProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.order_info.is_some() {
            len += 1;
        }
        if self.order_type != 0 {
            len += 1;
        }
        if !self.trigger_price.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SpotOrder", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if let Some(v) = self.order_info.as_ref() {
            struct_ser.serialize_field("orderInfo", v)?;
        }
        if self.order_type != 0 {
            let v = OrderType::try_from(self.order_type).map_err(|_| {
                serde::ser::Error::custom(format!("Invalid variant {}", self.order_type))
            })?;
            struct_ser.serialize_field("orderType", &v)?;
        }
        if !self.trigger_price.is_empty() {
            struct_ser.serialize_field("triggerPrice", &self.trigger_price)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "order_info",
            "orderInfo",
            "order_type",
            "orderType",
            "trigger_price",
            "triggerPrice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            OrderInfo,
            OrderType,
            TriggerPrice,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "orderInfo" | "order_info" => Ok(GeneratedField::OrderInfo),
                            "orderType" | "order_type" => Ok(GeneratedField::OrderType),
                            "triggerPrice" | "trigger_price" => Ok(GeneratedField::TriggerPrice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SpotOrder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpotOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut order_info__ = None;
                let mut order_type__ = None;
                let mut trigger_price__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderInfo => {
                            if order_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderInfo"));
                            }
                            order_info__ = map_.next_value()?;
                        }
                        GeneratedField::OrderType => {
                            if order_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderType"));
                            }
                            order_type__ = Some(map_.next_value::<OrderType>()? as i32);
                        }
                        GeneratedField::TriggerPrice => {
                            if trigger_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggerPrice"));
                            }
                            trigger_price__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SpotOrder {
                    market_id: market_id__.unwrap_or_default(),
                    order_info: order_info__,
                    order_type: order_type__.unwrap_or_default(),
                    trigger_price: trigger_price__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SpotOrderBook {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_buy_side {
            len += 1;
        }
        if !self.orders.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SpotOrderBook", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_buy_side {
            struct_ser.serialize_field("isBuySide", &self.is_buy_side)?;
        }
        if !self.orders.is_empty() {
            struct_ser.serialize_field("orders", &self.orders)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SpotOrderBook {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["market_id", "marketId", "isBuySide", "orders"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            IsBuySide,
            Orders,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isBuySide" => Ok(GeneratedField::IsBuySide),
                            "orders" => Ok(GeneratedField::Orders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpotOrderBook;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SpotOrderBook")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpotOrderBook, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut is_buy_side__ = None;
                let mut orders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuySide => {
                            if is_buy_side__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuySide"));
                            }
                            is_buy_side__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Orders => {
                            if orders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orders"));
                            }
                            orders__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SpotOrderBook {
                    market_id: market_id__.unwrap_or_default(),
                    is_buy_side: is_buy_side__.unwrap_or_default(),
                    orders: orders__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SpotOrderBook",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Subaccount {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.trader.is_empty() {
            len += 1;
        }
        if self.subaccount_nonce != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.Subaccount", len)?;
        if !self.trader.is_empty() {
            struct_ser.serialize_field("trader", &self.trader)?;
        }
        if self.subaccount_nonce != 0 {
            struct_ser.serialize_field("subaccountNonce", &self.subaccount_nonce)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for Subaccount {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["trader", "subaccount_nonce", "subaccountNonce"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Trader,
            SubaccountNonce,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "trader" => Ok(GeneratedField::Trader),
                            "subaccountNonce" | "subaccount_nonce" => {
                                Ok(GeneratedField::SubaccountNonce)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Subaccount;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.Subaccount")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Subaccount, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut trader__ = None;
                let mut subaccount_nonce__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Trader => {
                            if trader__.is_some() {
                                return Err(serde::de::Error::duplicate_field("trader"));
                            }
                            trader__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountNonce => {
                            if subaccount_nonce__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountNonce"));
                            }
                            subaccount_nonce__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(Subaccount {
                    trader: trader__.unwrap_or_default(),
                    subaccount_nonce: subaccount_nonce__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.Subaccount",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountDeposit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if self.deposit.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SubaccountDeposit", len)?;
        if !self.subaccount_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "subaccountId",
                pbjson::private::base64::encode(&self.subaccount_id).as_str(),
            )?;
        }
        if let Some(v) = self.deposit.as_ref() {
            struct_ser.serialize_field("deposit", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountDeposit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_id", "subaccountId", "deposit"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            Deposit,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "deposit" => Ok(GeneratedField::Deposit),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountDeposit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountDeposit")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubaccountDeposit, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut deposit__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Deposit => {
                            if deposit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deposit"));
                            }
                            deposit__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SubaccountDeposit {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    deposit: deposit__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountDeposit",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountIDs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SubaccountIDs", len)?;
        if !self.subaccount_ids.is_empty() {
            struct_ser.serialize_field(
                "subaccountIds",
                &self
                    .subaccount_ids
                    .iter()
                    .map(pbjson::private::base64::encode)
                    .collect::<Vec<_>>(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountIDs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["subaccount_ids", "subaccountIds"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountIds" | "subaccount_ids" => Ok(GeneratedField::SubaccountIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountIDs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountIDs")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubaccountIDs, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountIds => {
                            if subaccount_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountIds"));
                            }
                            subaccount_ids__ = Some(
                                map_.next_value::<Vec<::pbjson::private::BytesDeserialize<_>>>()?
                                    .into_iter()
                                    .map(|x| x.0)
                                    .collect(),
                            );
                        }
                    }
                }
                Ok(SubaccountIDs {
                    subaccount_ids: subaccount_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountIDs",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountNonce {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if self.subaccount_trade_nonce.is_some() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SubaccountNonce", len)?;
        if !self.subaccount_id.is_empty() {
            struct_ser.serialize_field("subaccountId", &self.subaccount_id)?;
        }
        if let Some(v) = self.subaccount_trade_nonce.as_ref() {
            struct_ser.serialize_field("subaccountTradeNonce", v)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountNonce {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subaccount_id",
            "subaccountId",
            "subaccount_trade_nonce",
            "subaccountTradeNonce",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubaccountId,
            SubaccountTradeNonce,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "subaccountTradeNonce" | "subaccount_trade_nonce" => {
                                Ok(GeneratedField::SubaccountTradeNonce)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountNonce;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountNonce")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubaccountNonce, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut subaccount_id__ = None;
                let mut subaccount_trade_nonce__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountTradeNonce => {
                            if subaccount_trade_nonce__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "subaccountTradeNonce",
                                ));
                            }
                            subaccount_trade_nonce__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SubaccountNonce {
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    subaccount_trade_nonce: subaccount_trade_nonce__,
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountNonce",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        if self.is_reduce_only {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SubaccountOrder", len)?;
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if self.is_reduce_only {
            struct_ser.serialize_field("isReduceOnly", &self.is_reduce_only)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["price", "quantity", "isReduceOnly", "cid"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Price,
            Quantity,
            IsReduceOnly,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "price" => Ok(GeneratedField::Price),
                            "quantity" => Ok(GeneratedField::Quantity),
                            "isReduceOnly" => Ok(GeneratedField::IsReduceOnly),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountOrder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubaccountOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut price__ = None;
                let mut quantity__ = None;
                let mut is_reduce_only__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsReduceOnly => {
                            if is_reduce_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isReduceOnly"));
                            }
                            is_reduce_only__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SubaccountOrder {
                    price: price__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                    is_reduce_only: is_reduce_only__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountOrderData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.order.is_some() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SubaccountOrderData", len)?;
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        if !self.order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "orderHash",
                pbjson::private::base64::encode(&self.order_hash).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountOrderData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["order", "order_hash", "orderHash"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Order,
            OrderHash,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "order" => Ok(GeneratedField::Order),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountOrderData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountOrderData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubaccountOrderData, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut order__ = None;
                let mut order_hash__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = map_.next_value()?;
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(SubaccountOrderData {
                    order: order__,
                    order_hash: order_hash__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountOrderData",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountOrderbookMetadata {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.vanilla_limit_order_count != 0 {
            len += 1;
        }
        if self.reduce_only_limit_order_count != 0 {
            len += 1;
        }
        if !self.aggregate_reduce_only_quantity.is_empty() {
            len += 1;
        }
        if !self.aggregate_vanilla_quantity.is_empty() {
            len += 1;
        }
        if self.vanilla_conditional_order_count != 0 {
            len += 1;
        }
        if self.reduce_only_conditional_order_count != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.SubaccountOrderbookMetadata",
            len,
        )?;
        if self.vanilla_limit_order_count != 0 {
            struct_ser
                .serialize_field("vanillaLimitOrderCount", &self.vanilla_limit_order_count)?;
        }
        if self.reduce_only_limit_order_count != 0 {
            struct_ser.serialize_field(
                "reduceOnlyLimitOrderCount",
                &self.reduce_only_limit_order_count,
            )?;
        }
        if !self.aggregate_reduce_only_quantity.is_empty() {
            struct_ser.serialize_field(
                "aggregateReduceOnlyQuantity",
                &self.aggregate_reduce_only_quantity,
            )?;
        }
        if !self.aggregate_vanilla_quantity.is_empty() {
            struct_ser
                .serialize_field("aggregateVanillaQuantity", &self.aggregate_vanilla_quantity)?;
        }
        if self.vanilla_conditional_order_count != 0 {
            struct_ser.serialize_field(
                "vanillaConditionalOrderCount",
                &self.vanilla_conditional_order_count,
            )?;
        }
        if self.reduce_only_conditional_order_count != 0 {
            struct_ser.serialize_field(
                "reduceOnlyConditionalOrderCount",
                &self.reduce_only_conditional_order_count,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountOrderbookMetadata {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "vanilla_limit_order_count",
            "vanillaLimitOrderCount",
            "reduce_only_limit_order_count",
            "reduceOnlyLimitOrderCount",
            "aggregate_reduce_only_quantity",
            "aggregateReduceOnlyQuantity",
            "aggregate_vanilla_quantity",
            "aggregateVanillaQuantity",
            "vanilla_conditional_order_count",
            "vanillaConditionalOrderCount",
            "reduce_only_conditional_order_count",
            "reduceOnlyConditionalOrderCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VanillaLimitOrderCount,
            ReduceOnlyLimitOrderCount,
            AggregateReduceOnlyQuantity,
            AggregateVanillaQuantity,
            VanillaConditionalOrderCount,
            ReduceOnlyConditionalOrderCount,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "vanillaLimitOrderCount" | "vanilla_limit_order_count" => {
                                Ok(GeneratedField::VanillaLimitOrderCount)
                            }
                            "reduceOnlyLimitOrderCount" | "reduce_only_limit_order_count" => {
                                Ok(GeneratedField::ReduceOnlyLimitOrderCount)
                            }
                            "aggregateReduceOnlyQuantity" | "aggregate_reduce_only_quantity" => {
                                Ok(GeneratedField::AggregateReduceOnlyQuantity)
                            }
                            "aggregateVanillaQuantity" | "aggregate_vanilla_quantity" => {
                                Ok(GeneratedField::AggregateVanillaQuantity)
                            }
                            "vanillaConditionalOrderCount" | "vanilla_conditional_order_count" => {
                                Ok(GeneratedField::VanillaConditionalOrderCount)
                            }
                            "reduceOnlyConditionalOrderCount"
                            | "reduce_only_conditional_order_count" => {
                                Ok(GeneratedField::ReduceOnlyConditionalOrderCount)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountOrderbookMetadata;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountOrderbookMetadata")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<SubaccountOrderbookMetadata, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut vanilla_limit_order_count__ = None;
                let mut reduce_only_limit_order_count__ = None;
                let mut aggregate_reduce_only_quantity__ = None;
                let mut aggregate_vanilla_quantity__ = None;
                let mut vanilla_conditional_order_count__ = None;
                let mut reduce_only_conditional_order_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VanillaLimitOrderCount => {
                            if vanilla_limit_order_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "vanillaLimitOrderCount",
                                ));
                            }
                            vanilla_limit_order_count__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::ReduceOnlyLimitOrderCount => {
                            if reduce_only_limit_order_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "reduceOnlyLimitOrderCount",
                                ));
                            }
                            reduce_only_limit_order_count__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::AggregateReduceOnlyQuantity => {
                            if aggregate_reduce_only_quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "aggregateReduceOnlyQuantity",
                                ));
                            }
                            aggregate_reduce_only_quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AggregateVanillaQuantity => {
                            if aggregate_vanilla_quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "aggregateVanillaQuantity",
                                ));
                            }
                            aggregate_vanilla_quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::VanillaConditionalOrderCount => {
                            if vanilla_conditional_order_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "vanillaConditionalOrderCount",
                                ));
                            }
                            vanilla_conditional_order_count__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::ReduceOnlyConditionalOrderCount => {
                            if reduce_only_conditional_order_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "reduceOnlyConditionalOrderCount",
                                ));
                            }
                            reduce_only_conditional_order_count__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(SubaccountOrderbookMetadata {
                    vanilla_limit_order_count: vanilla_limit_order_count__.unwrap_or_default(),
                    reduce_only_limit_order_count: reduce_only_limit_order_count__
                        .unwrap_or_default(),
                    aggregate_reduce_only_quantity: aggregate_reduce_only_quantity__
                        .unwrap_or_default(),
                    aggregate_vanilla_quantity: aggregate_vanilla_quantity__.unwrap_or_default(),
                    vanilla_conditional_order_count: vanilla_conditional_order_count__
                        .unwrap_or_default(),
                    reduce_only_conditional_order_count: reduce_only_conditional_order_count__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountOrderbookMetadata",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountOrderbookMetadataWithMarket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.market_id.is_empty() {
            len += 1;
        }
        if self.is_buy {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket",
            len,
        )?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if self.is_buy {
            struct_ser.serialize_field("isBuy", &self.is_buy)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountOrderbookMetadataWithMarket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["metadata", "market_id", "marketId", "isBuy"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            MarketId,
            IsBuy,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "isBuy" => Ok(GeneratedField::IsBuy),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountOrderbookMetadataWithMarket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<SubaccountOrderbookMetadataWithMarket, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut market_id__ = None;
                let mut is_buy__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map_.next_value()?;
                        }
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuy => {
                            if is_buy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuy"));
                            }
                            is_buy__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SubaccountOrderbookMetadataWithMarket {
                    metadata: metadata__,
                    market_id: market_id__.unwrap_or_default(),
                    is_buy: is_buy__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountPosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.position.is_some() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SubaccountPosition", len)?;
        if let Some(v) = self.position.as_ref() {
            struct_ser.serialize_field("position", v)?;
        }
        if !self.subaccount_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "subaccountId",
                pbjson::private::base64::encode(&self.subaccount_id).as_str(),
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountPosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["position", "subaccount_id", "subaccountId"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Position,
            SubaccountId,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "position" => Ok(GeneratedField::Position),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountPosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountPosition")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubaccountPosition, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut position__ = None;
                let mut subaccount_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Position => {
                            if position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("position"));
                            }
                            position__ = map_.next_value()?;
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(SubaccountPosition {
                    position: position__,
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountPosition",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for SubaccountTradeNonce {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.nonce != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.SubaccountTradeNonce", len)?;
        if self.nonce != 0 {
            struct_ser.serialize_field("nonce", &self.nonce)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for SubaccountTradeNonce {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["nonce"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Nonce,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nonce" => Ok(GeneratedField::Nonce),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubaccountTradeNonce;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.SubaccountTradeNonce")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<SubaccountTradeNonce, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut nonce__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Nonce => {
                            if nonce__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonce"));
                            }
                            nonce__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(SubaccountTradeNonce {
                    nonce: nonce__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.SubaccountTradeNonce",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TierStatistic {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tier != 0 {
            len += 1;
        }
        if self.count != 0 {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.TierStatistic", len)?;
        if self.tier != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("tier", ToString::to_string(&self.tier).as_str())?;
        }
        if self.count != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("count", ToString::to_string(&self.count).as_str())?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TierStatistic {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["tier", "count"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Tier,
            Count,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tier" => Ok(GeneratedField::Tier),
                            "count" => Ok(GeneratedField::Count),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TierStatistic;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TierStatistic")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TierStatistic, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut tier__ = None;
                let mut count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Tier => {
                            if tier__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tier"));
                            }
                            tier__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("count"));
                            }
                            count__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                    }
                }
                Ok(TierStatistic {
                    tier: tier__.unwrap_or_default(),
                    count: count__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TierStatistic",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradeHistoryOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.trade_grouping_sec != 0 {
            len += 1;
        }
        if self.max_age != 0 {
            len += 1;
        }
        if self.include_raw_history {
            len += 1;
        }
        if self.include_metadata {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.TradeHistoryOptions", len)?;
        if self.trade_grouping_sec != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "tradeGroupingSec",
                ToString::to_string(&self.trade_grouping_sec).as_str(),
            )?;
        }
        if self.max_age != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field("maxAge", ToString::to_string(&self.max_age).as_str())?;
        }
        if self.include_raw_history {
            struct_ser.serialize_field("includeRawHistory", &self.include_raw_history)?;
        }
        if self.include_metadata {
            struct_ser.serialize_field("includeMetadata", &self.include_metadata)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradeHistoryOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "trade_grouping_sec",
            "tradeGroupingSec",
            "max_age",
            "maxAge",
            "include_raw_history",
            "includeRawHistory",
            "include_metadata",
            "includeMetadata",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TradeGroupingSec,
            MaxAge,
            IncludeRawHistory,
            IncludeMetadata,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tradeGroupingSec" | "trade_grouping_sec" => {
                                Ok(GeneratedField::TradeGroupingSec)
                            }
                            "maxAge" | "max_age" => Ok(GeneratedField::MaxAge),
                            "includeRawHistory" | "include_raw_history" => {
                                Ok(GeneratedField::IncludeRawHistory)
                            }
                            "includeMetadata" | "include_metadata" => {
                                Ok(GeneratedField::IncludeMetadata)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradeHistoryOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TradeHistoryOptions")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TradeHistoryOptions, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut trade_grouping_sec__ = None;
                let mut max_age__ = None;
                let mut include_raw_history__ = None;
                let mut include_metadata__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TradeGroupingSec => {
                            if trade_grouping_sec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tradeGroupingSec"));
                            }
                            trade_grouping_sec__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::MaxAge => {
                            if max_age__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxAge"));
                            }
                            max_age__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::IncludeRawHistory => {
                            if include_raw_history__.is_some() {
                                return Err(serde::de::Error::duplicate_field("includeRawHistory"));
                            }
                            include_raw_history__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IncludeMetadata => {
                            if include_metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("includeMetadata"));
                            }
                            include_metadata__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradeHistoryOptions {
                    trade_grouping_sec: trade_grouping_sec__.unwrap_or_default(),
                    max_age: max_age__.unwrap_or_default(),
                    include_raw_history: include_raw_history__.unwrap_or_default(),
                    include_metadata: include_metadata__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradeHistoryOptions",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradeLog {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.subaccount_id.is_empty() {
            len += 1;
        }
        if !self.fee.is_empty() {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.fee_recipient_address.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.TradeLog", len)?;
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.subaccount_id.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "subaccountId",
                pbjson::private::base64::encode(&self.subaccount_id).as_str(),
            )?;
        }
        if !self.fee.is_empty() {
            struct_ser.serialize_field("fee", &self.fee)?;
        }
        if !self.order_hash.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "orderHash",
                pbjson::private::base64::encode(&self.order_hash).as_str(),
            )?;
        }
        if !self.fee_recipient_address.is_empty() {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "feeRecipientAddress",
                pbjson::private::base64::encode(&self.fee_recipient_address).as_str(),
            )?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradeLog {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "quantity",
            "price",
            "subaccount_id",
            "subaccountId",
            "fee",
            "order_hash",
            "orderHash",
            "fee_recipient_address",
            "feeRecipientAddress",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Quantity,
            Price,
            SubaccountId,
            Fee,
            OrderHash,
            FeeRecipientAddress,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "quantity" => Ok(GeneratedField::Quantity),
                            "price" => Ok(GeneratedField::Price),
                            "subaccountId" | "subaccount_id" => Ok(GeneratedField::SubaccountId),
                            "fee" => Ok(GeneratedField::Fee),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "feeRecipientAddress" | "fee_recipient_address" => {
                                Ok(GeneratedField::FeeRecipientAddress)
                            }
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradeLog;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TradeLog")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TradeLog, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut quantity__ = None;
                let mut price__ = None;
                let mut subaccount_id__ = None;
                let mut fee__ = None;
                let mut order_hash__ = None;
                let mut fee_recipient_address__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubaccountId => {
                            if subaccount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subaccountId"));
                            }
                            subaccount_id__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Fee => {
                            if fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fee"));
                            }
                            fee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::FeeRecipientAddress => {
                            if fee_recipient_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "feeRecipientAddress",
                                ));
                            }
                            fee_recipient_address__ = Some(
                                map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradeLog {
                    quantity: quantity__.unwrap_or_default(),
                    price: price__.unwrap_or_default(),
                    subaccount_id: subaccount_id__.unwrap_or_default(),
                    fee: fee__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    fee_recipient_address: fee_recipient_address__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradeLog",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradeRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.timestamp != 0 {
            len += 1;
        }
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.TradeRecord", len)?;
        if self.timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser
                .serialize_field("timestamp", ToString::to_string(&self.timestamp).as_str())?;
        }
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradeRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["timestamp", "price", "quantity"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Price,
            Quantity,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "price" => Ok(GeneratedField::Price),
                            "quantity" => Ok(GeneratedField::Quantity),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradeRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TradeRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TradeRecord, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut price__ = None;
                let mut quantity__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradeRecord {
                    timestamp: timestamp__.unwrap_or_default(),
                    price: price__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradeRecord",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradeRecords {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.market_id.is_empty() {
            len += 1;
        }
        if !self.latest_trade_records.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.TradeRecords", len)?;
        if !self.market_id.is_empty() {
            struct_ser.serialize_field("marketId", &self.market_id)?;
        }
        if !self.latest_trade_records.is_empty() {
            struct_ser.serialize_field("latestTradeRecords", &self.latest_trade_records)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradeRecords {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "market_id",
            "marketId",
            "latest_trade_records",
            "latestTradeRecords",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarketId,
            LatestTradeRecords,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "marketId" | "market_id" => Ok(GeneratedField::MarketId),
                            "latestTradeRecords" | "latest_trade_records" => {
                                Ok(GeneratedField::LatestTradeRecords)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradeRecords;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TradeRecords")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TradeRecords, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut market_id__ = None;
                let mut latest_trade_records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarketId => {
                            if market_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketId"));
                            }
                            market_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LatestTradeRecords => {
                            if latest_trade_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "latestTradeRecords",
                                ));
                            }
                            latest_trade_records__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradeRecords {
                    market_id: market_id__.unwrap_or_default(),
                    latest_trade_records: latest_trade_records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradeRecords",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradingRewardCampaignAccountPendingPoints {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reward_pool_start_timestamp != 0 {
            len += 1;
        }
        if !self.account_points.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints",
            len,
        )?;
        if self.reward_pool_start_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "rewardPoolStartTimestamp",
                ToString::to_string(&self.reward_pool_start_timestamp).as_str(),
            )?;
        }
        if !self.account_points.is_empty() {
            struct_ser.serialize_field("accountPoints", &self.account_points)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradingRewardCampaignAccountPendingPoints {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reward_pool_start_timestamp",
            "rewardPoolStartTimestamp",
            "account_points",
            "accountPoints",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RewardPoolStartTimestamp,
            AccountPoints,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "rewardPoolStartTimestamp" | "reward_pool_start_timestamp" => {
                                Ok(GeneratedField::RewardPoolStartTimestamp)
                            }
                            "accountPoints" | "account_points" => Ok(GeneratedField::AccountPoints),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradingRewardCampaignAccountPendingPoints;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TradingRewardCampaignAccountPendingPoints, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut reward_pool_start_timestamp__ = None;
                let mut account_points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RewardPoolStartTimestamp => {
                            if reward_pool_start_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "rewardPoolStartTimestamp",
                                ));
                            }
                            reward_pool_start_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::AccountPoints => {
                            if account_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accountPoints"));
                            }
                            account_points__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradingRewardCampaignAccountPendingPoints {
                    reward_pool_start_timestamp: reward_pool_start_timestamp__.unwrap_or_default(),
                    account_points: account_points__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradingRewardCampaignAccountPoints {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.account.is_empty() {
            len += 1;
        }
        if !self.points.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignAccountPoints",
            len,
        )?;
        if !self.account.is_empty() {
            struct_ser.serialize_field("account", &self.account)?;
        }
        if !self.points.is_empty() {
            struct_ser.serialize_field("points", &self.points)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradingRewardCampaignAccountPoints {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["account", "points"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
            Points,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "account" => Ok(GeneratedField::Account),
                            "points" => Ok(GeneratedField::Points),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradingRewardCampaignAccountPoints;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.TradingRewardCampaignAccountPoints",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TradingRewardCampaignAccountPoints, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                let mut points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            account__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Points => {
                            if points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("points"));
                            }
                            points__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradingRewardCampaignAccountPoints {
                    account: account__.unwrap_or_default(),
                    points: points__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignAccountPoints",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradingRewardCampaignBoostInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.boosted_spot_market_ids.is_empty() {
            len += 1;
        }
        if !self.spot_market_multipliers.is_empty() {
            len += 1;
        }
        if !self.boosted_derivative_market_ids.is_empty() {
            len += 1;
        }
        if !self.derivative_market_multipliers.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo",
            len,
        )?;
        if !self.boosted_spot_market_ids.is_empty() {
            struct_ser.serialize_field("boostedSpotMarketIds", &self.boosted_spot_market_ids)?;
        }
        if !self.spot_market_multipliers.is_empty() {
            struct_ser.serialize_field("spotMarketMultipliers", &self.spot_market_multipliers)?;
        }
        if !self.boosted_derivative_market_ids.is_empty() {
            struct_ser.serialize_field(
                "boostedDerivativeMarketIds",
                &self.boosted_derivative_market_ids,
            )?;
        }
        if !self.derivative_market_multipliers.is_empty() {
            struct_ser.serialize_field(
                "derivativeMarketMultipliers",
                &self.derivative_market_multipliers,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradingRewardCampaignBoostInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "boosted_spot_market_ids",
            "boostedSpotMarketIds",
            "spot_market_multipliers",
            "spotMarketMultipliers",
            "boosted_derivative_market_ids",
            "boostedDerivativeMarketIds",
            "derivative_market_multipliers",
            "derivativeMarketMultipliers",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BoostedSpotMarketIds,
            SpotMarketMultipliers,
            BoostedDerivativeMarketIds,
            DerivativeMarketMultipliers,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "boostedSpotMarketIds" | "boosted_spot_market_ids" => {
                                Ok(GeneratedField::BoostedSpotMarketIds)
                            }
                            "spotMarketMultipliers" | "spot_market_multipliers" => {
                                Ok(GeneratedField::SpotMarketMultipliers)
                            }
                            "boostedDerivativeMarketIds" | "boosted_derivative_market_ids" => {
                                Ok(GeneratedField::BoostedDerivativeMarketIds)
                            }
                            "derivativeMarketMultipliers" | "derivative_market_multipliers" => {
                                Ok(GeneratedField::DerivativeMarketMultipliers)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradingRewardCampaignBoostInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter
                    .write_str("struct injective.exchange.v1beta1.TradingRewardCampaignBoostInfo")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TradingRewardCampaignBoostInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut boosted_spot_market_ids__ = None;
                let mut spot_market_multipliers__ = None;
                let mut boosted_derivative_market_ids__ = None;
                let mut derivative_market_multipliers__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BoostedSpotMarketIds => {
                            if boosted_spot_market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "boostedSpotMarketIds",
                                ));
                            }
                            boosted_spot_market_ids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SpotMarketMultipliers => {
                            if spot_market_multipliers__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "spotMarketMultipliers",
                                ));
                            }
                            spot_market_multipliers__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BoostedDerivativeMarketIds => {
                            if boosted_derivative_market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "boostedDerivativeMarketIds",
                                ));
                            }
                            boosted_derivative_market_ids__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DerivativeMarketMultipliers => {
                            if derivative_market_multipliers__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "derivativeMarketMultipliers",
                                ));
                            }
                            derivative_market_multipliers__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradingRewardCampaignBoostInfo {
                    boosted_spot_market_ids: boosted_spot_market_ids__.unwrap_or_default(),
                    spot_market_multipliers: spot_market_multipliers__.unwrap_or_default(),
                    boosted_derivative_market_ids: boosted_derivative_market_ids__
                        .unwrap_or_default(),
                    derivative_market_multipliers: derivative_market_multipliers__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradingRewardCampaignInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.campaign_duration_seconds != 0 {
            len += 1;
        }
        if !self.quote_denoms.is_empty() {
            len += 1;
        }
        if self.trading_reward_boost_info.is_some() {
            len += 1;
        }
        if !self.disqualified_market_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer
            .serialize_struct("injective.exchange.v1beta1.TradingRewardCampaignInfo", len)?;
        if self.campaign_duration_seconds != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "campaignDurationSeconds",
                ToString::to_string(&self.campaign_duration_seconds).as_str(),
            )?;
        }
        if !self.quote_denoms.is_empty() {
            struct_ser.serialize_field("quoteDenoms", &self.quote_denoms)?;
        }
        if let Some(v) = self.trading_reward_boost_info.as_ref() {
            struct_ser.serialize_field("tradingRewardBoostInfo", v)?;
        }
        if !self.disqualified_market_ids.is_empty() {
            struct_ser.serialize_field("disqualifiedMarketIds", &self.disqualified_market_ids)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradingRewardCampaignInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "campaign_duration_seconds",
            "campaignDurationSeconds",
            "quote_denoms",
            "quoteDenoms",
            "trading_reward_boost_info",
            "tradingRewardBoostInfo",
            "disqualified_market_ids",
            "disqualifiedMarketIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CampaignDurationSeconds,
            QuoteDenoms,
            TradingRewardBoostInfo,
            DisqualifiedMarketIds,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "campaignDurationSeconds" | "campaign_duration_seconds" => {
                                Ok(GeneratedField::CampaignDurationSeconds)
                            }
                            "quoteDenoms" | "quote_denoms" => Ok(GeneratedField::QuoteDenoms),
                            "tradingRewardBoostInfo" | "trading_reward_boost_info" => {
                                Ok(GeneratedField::TradingRewardBoostInfo)
                            }
                            "disqualifiedMarketIds" | "disqualified_market_ids" => {
                                Ok(GeneratedField::DisqualifiedMarketIds)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradingRewardCampaignInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TradingRewardCampaignInfo")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TradingRewardCampaignInfo, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut campaign_duration_seconds__ = None;
                let mut quote_denoms__ = None;
                let mut trading_reward_boost_info__ = None;
                let mut disqualified_market_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CampaignDurationSeconds => {
                            if campaign_duration_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "campaignDurationSeconds",
                                ));
                            }
                            campaign_duration_seconds__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::QuoteDenoms => {
                            if quote_denoms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quoteDenoms"));
                            }
                            quote_denoms__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradingRewardBoostInfo => {
                            if trading_reward_boost_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "tradingRewardBoostInfo",
                                ));
                            }
                            trading_reward_boost_info__ = map_.next_value()?;
                        }
                        GeneratedField::DisqualifiedMarketIds => {
                            if disqualified_market_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "disqualifiedMarketIds",
                                ));
                            }
                            disqualified_market_ids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradingRewardCampaignInfo {
                    campaign_duration_seconds: campaign_duration_seconds__.unwrap_or_default(),
                    quote_denoms: quote_denoms__.unwrap_or_default(),
                    trading_reward_boost_info: trading_reward_boost_info__,
                    disqualified_market_ids: disqualified_market_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignInfo",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradingRewardCampaignLaunchProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if self.campaign_info.is_some() {
            len += 1;
        }
        if !self.campaign_reward_pools.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if let Some(v) = self.campaign_info.as_ref() {
            struct_ser.serialize_field("campaignInfo", v)?;
        }
        if !self.campaign_reward_pools.is_empty() {
            struct_ser.serialize_field("campaignRewardPools", &self.campaign_reward_pools)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradingRewardCampaignLaunchProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "campaign_info",
            "campaignInfo",
            "campaign_reward_pools",
            "campaignRewardPools",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            CampaignInfo,
            CampaignRewardPools,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "campaignInfo" | "campaign_info" => Ok(GeneratedField::CampaignInfo),
                            "campaignRewardPools" | "campaign_reward_pools" => {
                                Ok(GeneratedField::CampaignRewardPools)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradingRewardCampaignLaunchProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TradingRewardCampaignLaunchProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut campaign_info__ = None;
                let mut campaign_reward_pools__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CampaignInfo => {
                            if campaign_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("campaignInfo"));
                            }
                            campaign_info__ = map_.next_value()?;
                        }
                        GeneratedField::CampaignRewardPools => {
                            if campaign_reward_pools__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "campaignRewardPools",
                                ));
                            }
                            campaign_reward_pools__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradingRewardCampaignLaunchProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    campaign_info: campaign_info__,
                    campaign_reward_pools: campaign_reward_pools__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradingRewardCampaignUpdateProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if self.campaign_info.is_some() {
            len += 1;
        }
        if !self.campaign_reward_pools_additions.is_empty() {
            len += 1;
        }
        if !self.campaign_reward_pools_updates.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if let Some(v) = self.campaign_info.as_ref() {
            struct_ser.serialize_field("campaignInfo", v)?;
        }
        if !self.campaign_reward_pools_additions.is_empty() {
            struct_ser.serialize_field(
                "campaignRewardPoolsAdditions",
                &self.campaign_reward_pools_additions,
            )?;
        }
        if !self.campaign_reward_pools_updates.is_empty() {
            struct_ser.serialize_field(
                "campaignRewardPoolsUpdates",
                &self.campaign_reward_pools_updates,
            )?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradingRewardCampaignUpdateProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "campaign_info",
            "campaignInfo",
            "campaign_reward_pools_additions",
            "campaignRewardPoolsAdditions",
            "campaign_reward_pools_updates",
            "campaignRewardPoolsUpdates",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            CampaignInfo,
            CampaignRewardPoolsAdditions,
            CampaignRewardPoolsUpdates,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "campaignInfo" | "campaign_info" => Ok(GeneratedField::CampaignInfo),
                            "campaignRewardPoolsAdditions" | "campaign_reward_pools_additions" => {
                                Ok(GeneratedField::CampaignRewardPoolsAdditions)
                            }
                            "campaignRewardPoolsUpdates" | "campaign_reward_pools_updates" => {
                                Ok(GeneratedField::CampaignRewardPoolsUpdates)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradingRewardCampaignUpdateProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TradingRewardCampaignUpdateProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut campaign_info__ = None;
                let mut campaign_reward_pools_additions__ = None;
                let mut campaign_reward_pools_updates__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CampaignInfo => {
                            if campaign_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("campaignInfo"));
                            }
                            campaign_info__ = map_.next_value()?;
                        }
                        GeneratedField::CampaignRewardPoolsAdditions => {
                            if campaign_reward_pools_additions__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "campaignRewardPoolsAdditions",
                                ));
                            }
                            campaign_reward_pools_additions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CampaignRewardPoolsUpdates => {
                            if campaign_reward_pools_updates__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "campaignRewardPoolsUpdates",
                                ));
                            }
                            campaign_reward_pools_updates__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradingRewardCampaignUpdateProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    campaign_info: campaign_info__,
                    campaign_reward_pools_additions: campaign_reward_pools_additions__
                        .unwrap_or_default(),
                    campaign_reward_pools_updates: campaign_reward_pools_updates__
                        .unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TradingRewardPendingPointsUpdateProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if self.pending_pool_timestamp != 0 {
            len += 1;
        }
        if !self.reward_point_updates.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if self.pending_pool_timestamp != 0 {
            #[allow(clippy::needless_borrow)]
            struct_ser.serialize_field(
                "pendingPoolTimestamp",
                ToString::to_string(&self.pending_pool_timestamp).as_str(),
            )?;
        }
        if !self.reward_point_updates.is_empty() {
            struct_ser.serialize_field("rewardPointUpdates", &self.reward_point_updates)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TradingRewardPendingPointsUpdateProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "pending_pool_timestamp",
            "pendingPoolTimestamp",
            "reward_point_updates",
            "rewardPointUpdates",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            PendingPoolTimestamp,
            RewardPointUpdates,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "pendingPoolTimestamp" | "pending_pool_timestamp" => {
                                Ok(GeneratedField::PendingPoolTimestamp)
                            }
                            "rewardPointUpdates" | "reward_point_updates" => {
                                Ok(GeneratedField::RewardPointUpdates)
                            }
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TradingRewardPendingPointsUpdateProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TradingRewardPendingPointsUpdateProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut pending_pool_timestamp__ = None;
                let mut reward_point_updates__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PendingPoolTimestamp => {
                            if pending_pool_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "pendingPoolTimestamp",
                                ));
                            }
                            pending_pool_timestamp__ = Some(
                                map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?
                                    .0,
                            );
                        }
                        GeneratedField::RewardPointUpdates => {
                            if reward_point_updates__.is_some() {
                                return Err(serde::de::Error::duplicate_field(
                                    "rewardPointUpdates",
                                ));
                            }
                            reward_point_updates__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TradingRewardPendingPointsUpdateProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    pending_pool_timestamp: pending_pool_timestamp__.unwrap_or_default(),
                    reward_point_updates: reward_point_updates__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TrimmedDerivativeConditionalOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.margin.is_empty() {
            len += 1;
        }
        if !self.trigger_price.is_empty() {
            len += 1;
        }
        if self.is_buy {
            len += 1;
        }
        if self.is_limit {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder",
            len,
        )?;
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.margin.is_empty() {
            struct_ser.serialize_field("margin", &self.margin)?;
        }
        if !self.trigger_price.is_empty() {
            struct_ser.serialize_field("triggerPrice", &self.trigger_price)?;
        }
        if self.is_buy {
            struct_ser.serialize_field("isBuy", &self.is_buy)?;
        }
        if self.is_limit {
            struct_ser.serialize_field("isLimit", &self.is_limit)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TrimmedDerivativeConditionalOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "price",
            "quantity",
            "margin",
            "triggerPrice",
            "isBuy",
            "isLimit",
            "order_hash",
            "orderHash",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Price,
            Quantity,
            Margin,
            TriggerPrice,
            IsBuy,
            IsLimit,
            OrderHash,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "price" => Ok(GeneratedField::Price),
                            "quantity" => Ok(GeneratedField::Quantity),
                            "margin" => Ok(GeneratedField::Margin),
                            "triggerPrice" => Ok(GeneratedField::TriggerPrice),
                            "isBuy" => Ok(GeneratedField::IsBuy),
                            "isLimit" => Ok(GeneratedField::IsLimit),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TrimmedDerivativeConditionalOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str(
                    "struct injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder",
                )
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TrimmedDerivativeConditionalOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut price__ = None;
                let mut quantity__ = None;
                let mut margin__ = None;
                let mut trigger_price__ = None;
                let mut is_buy__ = None;
                let mut is_limit__ = None;
                let mut order_hash__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Margin => {
                            if margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("margin"));
                            }
                            margin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TriggerPrice => {
                            if trigger_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("triggerPrice"));
                            }
                            trigger_price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuy => {
                            if is_buy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuy"));
                            }
                            is_buy__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsLimit => {
                            if is_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isLimit"));
                            }
                            is_limit__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TrimmedDerivativeConditionalOrder {
                    price: price__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                    margin: margin__.unwrap_or_default(),
                    trigger_price: trigger_price__.unwrap_or_default(),
                    is_buy: is_buy__.unwrap_or_default(),
                    is_limit: is_limit__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TrimmedDerivativeLimitOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.margin.is_empty() {
            len += 1;
        }
        if !self.fillable.is_empty() {
            len += 1;
        }
        if self.is_buy {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.TrimmedDerivativeLimitOrder",
            len,
        )?;
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.margin.is_empty() {
            struct_ser.serialize_field("margin", &self.margin)?;
        }
        if !self.fillable.is_empty() {
            struct_ser.serialize_field("fillable", &self.fillable)?;
        }
        if self.is_buy {
            struct_ser.serialize_field("isBuy", &self.is_buy)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TrimmedDerivativeLimitOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "price",
            "quantity",
            "margin",
            "fillable",
            "isBuy",
            "order_hash",
            "orderHash",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Price,
            Quantity,
            Margin,
            Fillable,
            IsBuy,
            OrderHash,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "price" => Ok(GeneratedField::Price),
                            "quantity" => Ok(GeneratedField::Quantity),
                            "margin" => Ok(GeneratedField::Margin),
                            "fillable" => Ok(GeneratedField::Fillable),
                            "isBuy" => Ok(GeneratedField::IsBuy),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TrimmedDerivativeLimitOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TrimmedDerivativeLimitOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TrimmedDerivativeLimitOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut price__ = None;
                let mut quantity__ = None;
                let mut margin__ = None;
                let mut fillable__ = None;
                let mut is_buy__ = None;
                let mut order_hash__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Margin => {
                            if margin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("margin"));
                            }
                            margin__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fillable => {
                            if fillable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fillable"));
                            }
                            fillable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuy => {
                            if is_buy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuy"));
                            }
                            is_buy__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TrimmedDerivativeLimitOrder {
                    price: price__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                    margin: margin__.unwrap_or_default(),
                    fillable: fillable__.unwrap_or_default(),
                    is_buy: is_buy__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TrimmedDerivativeLimitOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for TrimmedSpotLimitOrder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.price.is_empty() {
            len += 1;
        }
        if !self.quantity.is_empty() {
            len += 1;
        }
        if !self.fillable.is_empty() {
            len += 1;
        }
        if self.is_buy {
            len += 1;
        }
        if !self.order_hash.is_empty() {
            len += 1;
        }
        if !self.cid.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.TrimmedSpotLimitOrder", len)?;
        if !self.price.is_empty() {
            struct_ser.serialize_field("price", &self.price)?;
        }
        if !self.quantity.is_empty() {
            struct_ser.serialize_field("quantity", &self.quantity)?;
        }
        if !self.fillable.is_empty() {
            struct_ser.serialize_field("fillable", &self.fillable)?;
        }
        if self.is_buy {
            struct_ser.serialize_field("isBuy", &self.is_buy)?;
        }
        if !self.order_hash.is_empty() {
            struct_ser.serialize_field("orderHash", &self.order_hash)?;
        }
        if !self.cid.is_empty() {
            struct_ser.serialize_field("cid", &self.cid)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for TrimmedSpotLimitOrder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "price",
            "quantity",
            "fillable",
            "isBuy",
            "order_hash",
            "orderHash",
            "cid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Price,
            Quantity,
            Fillable,
            IsBuy,
            OrderHash,
            Cid,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "price" => Ok(GeneratedField::Price),
                            "quantity" => Ok(GeneratedField::Quantity),
                            "fillable" => Ok(GeneratedField::Fillable),
                            "isBuy" => Ok(GeneratedField::IsBuy),
                            "orderHash" | "order_hash" => Ok(GeneratedField::OrderHash),
                            "cid" => Ok(GeneratedField::Cid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TrimmedSpotLimitOrder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.TrimmedSpotLimitOrder")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<TrimmedSpotLimitOrder, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut price__ = None;
                let mut quantity__ = None;
                let mut fillable__ = None;
                let mut is_buy__ = None;
                let mut order_hash__ = None;
                let mut cid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Quantity => {
                            if quantity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quantity"));
                            }
                            quantity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fillable => {
                            if fillable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fillable"));
                            }
                            fillable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsBuy => {
                            if is_buy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isBuy"));
                            }
                            is_buy__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OrderHash => {
                            if order_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderHash"));
                            }
                            order_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cid => {
                            if cid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cid"));
                            }
                            cid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TrimmedSpotLimitOrder {
                    price: price__.unwrap_or_default(),
                    quantity: quantity__.unwrap_or_default(),
                    fillable: fillable__.unwrap_or_default(),
                    is_buy: is_buy__.unwrap_or_default(),
                    order_hash: order_hash__.unwrap_or_default(),
                    cid: cid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.TrimmedSpotLimitOrder",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for UpdateDenomDecimalsProposal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title.is_empty() {
            len += 1;
        }
        if !self.description.is_empty() {
            len += 1;
        }
        if !self.denom_decimals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct(
            "injective.exchange.v1beta1.UpdateDenomDecimalsProposal",
            len,
        )?;
        if !self.title.is_empty() {
            struct_ser.serialize_field("title", &self.title)?;
        }
        if !self.description.is_empty() {
            struct_ser.serialize_field("description", &self.description)?;
        }
        if !self.denom_decimals.is_empty() {
            struct_ser.serialize_field("denomDecimals", &self.denom_decimals)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for UpdateDenomDecimalsProposal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["title", "description", "denom_decimals", "denomDecimals"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            DenomDecimals,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "denomDecimals" | "denom_decimals" => Ok(GeneratedField::DenomDecimals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UpdateDenomDecimalsProposal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.UpdateDenomDecimalsProposal")
            }

            fn visit_map<V>(
                self,
                mut map_: V,
            ) -> std::result::Result<UpdateDenomDecimalsProposal, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut denom_decimals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DenomDecimals => {
                            if denom_decimals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denomDecimals"));
                            }
                            denom_decimals__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(UpdateDenomDecimalsProposal {
                    title: title__.unwrap_or_default(),
                    description: description__.unwrap_or_default(),
                    denom_decimals: denom_decimals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.UpdateDenomDecimalsProposal",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for VolumeRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.maker_volume.is_empty() {
            len += 1;
        }
        if !self.taker_volume.is_empty() {
            len += 1;
        }
        let mut struct_ser =
            serializer.serialize_struct("injective.exchange.v1beta1.VolumeRecord", len)?;
        if !self.maker_volume.is_empty() {
            struct_ser.serialize_field("makerVolume", &self.maker_volume)?;
        }
        if !self.taker_volume.is_empty() {
            struct_ser.serialize_field("takerVolume", &self.taker_volume)?;
        }
        struct_ser.end()
    }
}
#[cfg(feature = "serde")]
impl<'de> serde::Deserialize<'de> for VolumeRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &["maker_volume", "makerVolume", "taker_volume", "takerVolume"];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MakerVolume,
            TakerVolume,
        }
        #[cfg(feature = "serde")]
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "makerVolume" | "maker_volume" => Ok(GeneratedField::MakerVolume),
                            "takerVolume" | "taker_volume" => Ok(GeneratedField::TakerVolume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VolumeRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct injective.exchange.v1beta1.VolumeRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VolumeRecord, V::Error>
            where
                V: serde::de::MapAccess<'de>,
            {
                let mut maker_volume__ = None;
                let mut taker_volume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MakerVolume => {
                            if maker_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makerVolume"));
                            }
                            maker_volume__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TakerVolume => {
                            if taker_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("takerVolume"));
                            }
                            taker_volume__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(VolumeRecord {
                    maker_volume: maker_volume__.unwrap_or_default(),
                    taker_volume: taker_volume__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct(
            "injective.exchange.v1beta1.VolumeRecord",
            FIELDS,
            GeneratedVisitor,
        )
    }
}
